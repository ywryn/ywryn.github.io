<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ywrby Blog</title>
  
  <subtitle>Less is more</subtitle>
  <link href="http://ywrby.com/atom.xml" rel="self"/>
  
  <link href="http://ywrby.com/"/>
  <updated>2023-06-10T22:47:47.364Z</updated>
  <id>http://ywrby.com/</id>
  
  <author>
    <name>Ywrby</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>1-计算机安全概述</title>
    <link href="http://ywrby.com/2023/06/03/1-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0/"/>
    <id>http://ywrby.com/2023/06/03/1-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0/</id>
    <published>2023-06-02T22:52:47.000Z</published>
    <updated>2023-06-10T22:47:47.364Z</updated>
    
    <content type="html"><![CDATA[<p>参考书目：Computer Security: Principles and Practice, Fourth Edition, by William Stallings and Lawrie Brown. Pearson Higher Ed USA. ISBN 1292220635.</p><h1 id="计算机安全的概念"><a href="#计算机安全的概念" class="headerlink" title="计算机安全的概念"></a>计算机安全的概念</h1><h2 id="计算机安全（computer-security）的定义"><a href="#计算机安全（computer-security）的定义" class="headerlink" title="计算机安全（computer security）的定义"></a>计算机安全（computer security）的定义</h2><p>保证信息系统资产的<strong>机密性、完整性以及可用性</strong>的措施和控制方法，其中资产包括硬件、软件、固件、以及要处理、存储和通信的信息</p><p>机密性、完整性和可用性一起被并称为CIA三元组</p><h3 id="机密性（confidentiality）"><a href="#机密性（confidentiality）" class="headerlink" title="机密性（confidentiality）"></a>机密性（confidentiality）</h3><p>保持对信息访问和披露的限制，包括对个人隐私和专有信息保护的措施。机密性缺失是指非授权的信息披露</p><p>换言之机密性是指个人对资产的访问与披露具有控制能力，在未经许可或授权的情况下，他人无法访问相关数据。在现实中的实例就包括高校学生的教务系统，学生可以在登陆后查阅到个人的考试成绩等隐私信息，而他人在未经许可的情况下无法访问或知晓相关数据。</p><p>机密性包含两个相关概念：</p><ul><li>数据机密性：确保隐私或机密信息不被非授权的个人利用，或被泄露给非授权的个人</li><li>隐私性：确保个人能够控制或影响与自身相关的信息的收集和存储，也能够控制这些信息可以由谁披露或向谁披露</li></ul><h3 id="完整性（integrity）"><a href="#完整性（integrity）" class="headerlink" title="完整性（integrity）"></a>完整性（integrity）</h3><p>防范不正当的信息修改和破坏，包括保证信息的抵抗赖性和真实性。完整性缺失是指非授权的信息修改或破坏。</p><p>和机密性不同，完整性主要强调个人对资产的修改具有控制能力，他人在未经许可的情况下，无法修改或破坏相关数据。在现实中的实例就包括医院的过敏史信息数据库，医生可以在系统中增加修改或删除病人的相关病史，而他人不可以在未经授权的情况下修改或破坏病史，否则会造成严重的后果。</p><p>完整性包含两个相关概念：</p><ul><li>数据完整性：确保信息和程序只能在指定的和得到授权的情况下才能够改变</li><li>系统完整性：确保系统在未受损的方式下执行预期的功能，避免对系统进行有意或无意的非授权操作</li></ul><h3 id="可用性（availability）"><a href="#可用性（availability）" class="headerlink" title="可用性（availability）"></a>可用性（availability）</h3><p>确保系统能够及时响应，并且不能拒绝<strong>授权用户</strong>的服务请求。可用性缺失是指对信息或信息系统的访问和使用的破坏。</p><p>简言之，可用性就是指<strong>授权用户</strong>在任何情况下都应该能够访问系统并且获得服务。在现实中的实例就包括在线交易系统，如果交易系统可用性被破坏，授权用户无法通过系统进行资金交易，则会影响用户的交易热情，造成严重后果。</p><h1 id="威胁、攻击和资产"><a href="#威胁、攻击和资产" class="headerlink" title="威胁、攻击和资产"></a>威胁、攻击和资产</h1><p>在这里首先说明几个重要术语的概念：</p><ul><li>威胁（threat）：任何可能通过<strong>未经授权</strong>的访问、销毁、披露、修改信息以及拒绝服务而对组织运营、组织资产、个人、其他组织或国家产生不利影响的情况或事件</li><li>攻击（attack）：任何类型的恶意活动，试图收集、破坏、拒绝、降级或者破坏信息系统资源或信息本身</li><li>资产（Asset）：也叫系统资源（system resource），主要包括硬件、软件、数据、通信设施和网络</li></ul><h2 id="威胁与攻击"><a href="#威胁与攻击" class="headerlink" title="威胁与攻击"></a>威胁与攻击</h2><table><thead><tr><th>威胁后果（威胁）</th><th>威胁动作（攻击）</th></tr></thead><tbody><tr><td><strong>非授权泄露</strong><br/>实体未经授权而获得对数据访问的情况或事件</td><td>暴露：敏感数据被直接泄露给非授权实体<br/>截获：非授权实体直接访问在授权的源和目的地之间传输的敏感数据<br/>推理：非授权实体通过基于特征的推理或通信产品间接访问敏感数据<br/>入侵：非授权实体通过躲避系统安全保护措施来获得对敏感数据的访问</td></tr><tr><td><strong>欺骗</strong><br/>导致授权实体接收虚假数据并相信其正确性的情况或事件</td><td>冒充：非授权实体通过佯装成授权实体来访问系统或执行恶意行为<br/>伪造：以虚假数据欺骗授权实体<br/>抵赖：一个实体通过虚伪地否认对行为的责任而欺骗另一个实体</td></tr><tr><td><strong>破坏</strong><br/>中断或阻止系统服务和功能正确运行的情况或事件</td><td>失能：通过禁用系统组件来阻止或中断系统运行<br/>损坏：通过对系统功能或数据的不利修改来对系统运行进行非期望的改变<br/>阻碍：通过阻止系统运行来中断系统服务交付的威胁活动</td></tr><tr><td><strong>篡夺</strong><br/>导致系统服务或功能被非授权实体控制的情况或事件</td><td>盗用：实体对系统资源采取非授权的逻辑或物理控制<br/>误用：导致系统组件执行对系统有害的功能或服务</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考书目：Computer Security: Principles and Practice, Fourth Edition, by William Stallings and Lawrie Brown. Pearson Higher Ed USA. ISBN 12922</summary>
      
    
    
    
    
    <category term="网络安全" scheme="http://ywrby.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="计算机安全" scheme="http://ywrby.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>集乐-统一多媒体文件资源管理器</title>
    <link href="http://ywrby.com/2023/05/27/%E9%9B%86%E4%B9%90-%E7%BB%9F%E4%B8%80%E5%A4%9A%E5%AA%92%E4%BD%93%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8/"/>
    <id>http://ywrby.com/2023/05/27/%E9%9B%86%E4%B9%90-%E7%BB%9F%E4%B8%80%E5%A4%9A%E5%AA%92%E4%BD%93%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8/</id>
    <published>2023-05-26T22:24:05.000Z</published>
    <updated>2023-05-26T22:29:27.699Z</updated>
    
    <content type="html"><![CDATA[<p>项目地址：<a href="https://github.com/Ywrby/JiLe">https://github.com/Ywrby/JiLe</a></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>随着互联网的发展与短视频等流媒体展示分享方式的普及，如何同时进行多种多媒体文件资源的管理与分类逐渐成为困扰人们进行文件管理的主要问题。本项目为解决上述问题，设计了一款多媒体集成管理器，采用前后端分离的方式，使用 Electron 和 Vue.js 作为前端框架，Springboot 作为后端框架。项目主要模块分为电子书管理模块，图片管理模块以及影视资源管理模块。项目基本功能主要有：文件元数据编辑，文件标签操作，文件夹同步，高级文件搜索，本地文件操作，瀑布流展示，文件分享，应用内预览，页面自动截图，拟物播放器等。最后对系统进行了综合测试与结果分析，结果表明：项目交互性良好，兼容性高，实现了目标功能。具有实际应用意义。</p><h1 id="系统详细设计"><a href="#系统详细设计" class="headerlink" title="系统详细设计"></a>系统详细设计</h1><p>通过对项目整体进行可行性分析与需求分析，项目设计的基本方向和功能内容相对明确，项目以普通用户为设计视角，详细介绍对应功能与界面的设计和实现。</p><h2 id="系统总体架构设计"><a href="#系统总体架构设计" class="headerlink" title="系统总体架构设计"></a>系统总体架构设计</h2><p>项目总体架构设计采用前后端分离的设计模式，前端使用 Electron 和 Vue.js 作为前端开发框架，同时使用 Node.js 中的 Axios 作为网络通信库与后端通过 Http 请求进行数据通信和功能通信。后端使用 Spring boot 作为开发框架，利用 MyBatis 与 MySQL 数据库进行数据传输。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230526223546.png"></p><h2 id="系统数据库设计"><a href="#系统数据库设计" class="headerlink" title="系统数据库设计"></a>系统数据库设计</h2><p>项目内共使用 14 张数据表，表间关系通过外键相连接，下图为项目 E-R 图</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230526223732.png"></p><h3 id="数据库表设计"><a href="#数据库表设计" class="headerlink" title="数据库表设计"></a>数据库表设计</h3><p>数据表主要分为三大类，与影视资源相关数据表（vc_info,video_info,video_tag 等）与电子书资源相关数据表（ec_info,ebook_info,ebook_tag,ebook_author 等），与图片资源相关数据表（ic_info,image_info,image_tag 等）。下面以相对全面的影视资源数据表为例介绍项目建表原则。</p><center><p>表 4.1 影视合集数据表</p></center><table><thead><tr><th>字段</th><th>数据类型</th><th>说明</th></tr></thead><tbody><tr><td>ID(主键)</td><td>INT</td><td>影视合集数据表主键，唯一标识符，自增</td></tr><tr><td>VC_NAME</td><td>VARCHAR</td><td>影视合集名称</td></tr><tr><td>VC_PATH</td><td>VARCHAR</td><td>影视合集所在文件夹路径</td></tr><tr><td>VC_DESC</td><td>VARCHAR</td><td>影视合集简介</td></tr><tr><td>VC_COVER</td><td>VARCHAR</td><td>影视合集封面（缓存）</td></tr></tbody></table><center><p>表4.2 视频资源数据表</p></center><table><thead><tr><th>字段</th><th>数据类型</th><th>说明</th></tr></thead><tbody><tr><td>VC_ID</td><td>INT</td><td>视频资源所属影视合集 ID，外键</td></tr><tr><td>videoID</td><td>INT</td><td>视频资源主键，视频资源唯一标识符，自增</td></tr><tr><td>videoName</td><td>VARCHAR</td><td>视频资源名称，即用于辨识也用于标识路径</td></tr><tr><td>videoCover</td><td>VARCHAR</td><td>视频资源封面（缓存）</td></tr><tr><td>videoScore</td><td>TINYINT</td><td>0-5 数字，用于表示用户对视频的评分</td></tr><tr><td>Followed</td><td>TINYINT</td><td>0 或 1 数字，用于表示用户是否关注该视频</td></tr><tr><td>Intro</td><td>VARCHAR</td><td>视频资源简介</td></tr><tr><td>releaseDate</td><td>DATETIME</td><td>视频资源发布日期</td></tr><tr><td>url</td><td>VARCHAR</td><td>视频资源相关网址链接</td></tr></tbody></table><h2 id="项目前端界面功能设计"><a href="#项目前端界面功能设计" class="headerlink" title="项目前端界面功能设计"></a>项目前端界面功能设计</h2><p>整个项目中，界面展示部分作为用户最直接接触以及感知的部分，对用户的第一使用体验以及软件综合感受起着决定性作用。在界面设计过程中应严格以用户使用体验为第一要义，同时保证软件使用过程中的功能完善以及呈现效果等方面。</p><h3 id="综合展示模块界面设计"><a href="#综合展示模块界面设计" class="headerlink" title="综合展示模块界面设计"></a>综合展示模块界面设计</h3><p>综合展示模块负责统计并展示不同类型资源合集相关情况以及进行随机的相关资源推荐，主要分为书库综合展示，图集综合展示以及影集综合展示部分。该模块是用户在进入软件后首先要体验到的部分，也是最高层面上管理整个多媒体资源集成管理器系统内文件的模块。</p><p>该部分流程主要为用户进入系统后点击进入指定类型文件综合管理模块内部，展示界面分别对随机推荐的相关类型文件进行展示，同时对该类型下所有合集内容进行展示，展示内容包括合集名称，合集封面以及合集基本简介等。</p><p>用户右键点击指定合集卡片，弹出扩展操作选项，主要分为打开书库详情界面，编辑书库元数据，删除指定书库，在文件夹内按路径打开指定书库。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230526224421.png"></p><p>在该过程中文件夹默认打开指定合集路径涉及到对系统进行直接操作，其主要操作流程见下图。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230526224452.png"></p><h3 id="书库展示界面设计"><a href="#书库展示界面设计" class="headerlink" title="书库展示界面设计"></a>书库展示界面设计</h3><p>在设计书库展示界面时，应考虑到用户的实际体验，一方面要兼顾图书信息的全面展示，另一方面应尽可能简化用户操作降低用户学习成本。综上，主要应综合保证以下内容：</p><ol><li>界面布局：应该采用简洁明了的布局方式，使得用户可以快速浏览和选择电子书，可以使用网格布局、列表布局等方式来展示电子书。</li><li>电子书信息：应该展示电子书的基本信息，如书名、作者、出版社、出版时间、简介等，方便用户了解电子书的基本情况。</li><li>封面展示：应该展示电子书的封面图片，以吸引用户的眼球，同时方便用户快速识别电子书。</li><li>排序和筛选：应该提供排序和筛选功能，方便用户按照自己的需求进行电子书的选择和浏览。</li><li>评分和评论：应该提供用户评分和评论的功能，方便用户了解其他用户的评价和意见，同时也可以为其他用户提供参考。</li><li>搜索功能：应该提供搜索功能，方便用户快速查找自己需要的电子书，提高用户的使用效率。</li><li>标签功能，每个资源身上可以打上一系列“标签”, 以表明这个资源的属性, 对其进行分类。“标签”具有层次性, 是资源类别的一个体现[5]。<br>总的来说，一个好的电子书合集界面应该简洁明了、易于使用、能够满足用户的需求，并且提供优秀的用户体验。</li></ol><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230526224553.png"></p><p>在进行高级搜索过程中，主要流程是在搜索界面首先进行搜索类型的类型选择，确定是按照书名，作者，出版商还是其他内容进行搜索。确定好搜索类型后，进行搜索内容的输入，前端在接收到搜索内容后对搜索内容进行切分，随后将相关数据传输到后端进行模糊查询，前端向后端发送请求过程中需要调用 Node.js 下的 Axios 库进行网络通信，Axios 是一款易用、简洁且高效的 http 库，是一个可以用在浏览器和 Node.js 中的异步通信框架，其主要作用就是实现 Ajax 异步通信，由于 Vue 只关注视图层内容，使用 Axios 更为便捷。使用 Axios 控制网络通信过程具有以下特点：（1）从浏览器中创建 XMLHttpRequests，（2）从 node.js 创建 http 请求，（3）支持 Promise API（在 JS 中进行链式编程），（4）拦截请求和相应，（5）转换请求数据和响应数据，（6）取消请求，（7）自动转换 JSON 数据，（8）客户端支持防御 XSRF。整个高级搜索流程如下图所示</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230526224615.png"></p><h3 id="图集展示界面"><a href="#图集展示界面" class="headerlink" title="图集展示界面"></a>图集展示界面</h3><p>图集展示界面需要同时对用户的大量图片进行展示，以瀑布流形式进行整个内容的展示相对更加合理，在该过程中需要注意到：</p><ol><li>图片尺寸和比例：瀑布流展示图片的界面中，图片的尺寸和比例是非常重要的。应该确保每一张图片都能够清晰地展示，同时不影响用户体验。</li><li>瀑布流布局：瀑布流布局的设计应该考虑到用户的浏览习惯，让用户能够轻松浏览大量图片，同时不会感到拥挤或混乱。布局应该简洁明了，突出重点。</li><li>加载速度和响应速度：瀑布流展示图片需要大量的图片数据，因此加载速度和响应速度非常重要。应该采用高效的代码和缓存机制，确保界面能够快速加载和响应用户的操作。</li><li>用户交互：瀑布流展示图片的界面中，用户交互是非常重要的。应该设计简单、直观的交互方式，让用户能够快速地浏览、筛选和返回上一页/页码等操作。</li><li>颜色和字体：颜色和字体的设计应该考虑到整个界面的协调性和可读性。应该采用明亮、清晰的颜色和字体，确保用户能够轻松识别信息和进行操作。</li><li>可访问性：瀑布流展示图片的界面应该考虑到可访问性，确保所有功能和信息都能够方便地访问和使用。应该采用易于理解和使用的导航和搜索功能，同时考虑到视力和听力有障碍的用户使用。</li></ol><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230526224721.png"></p><p>在实现瀑布流的过程中，步骤主要分为：</p><ol><li>初始化数据：首先需要从后端或缓存中获取瀑布流所需的图片数据，并将其存储在本地或缓存中。</li><li>设置瀑布流容器：创建瀑布流容器，通常使用 HTML 元素，例如<code>&lt;div&gt;</code>或<code>&lt;canvas&gt;</code>。</li><li>设置瀑布流布局：根据所需的瀑布流布局，例如流式布局或分块布局，使用 CSS 设置瀑布流容器的样式。</li><li>加载图片：使用 JavaScript 异步加载图片，并将其添加到瀑布流容器中。可以使用 HTML5 的<code>&lt;img&gt;</code>标签或 Canvas 元素加载图片。</li><li>设置瀑布流事件：设置事件监听器，例如点击事件或滚动事件，以便用户可以与瀑布流交互，对瀑布流布局大小进行调整。</li><li>更新瀑布流：当图片数据更新或用户交互时，需要更新瀑布流的布局和样式。</li><li>缓存图片：由于需要同时加载大量图片，提前对图片进行缓存可以大大减少系统加载实践，提高用户使用体验。</li><li>优化性能：为了提高瀑布流的性能和用户体验，可以使用图片懒加载等设计，避免过多图片同时加载造成系统崩溃。</li></ol><p>在进行主色调分析过程中，需要从后端进行图片的加载以及主色调分析，具体流程如下图所示。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230526224839.png"></p><h3 id="影集展示界面"><a href="#影集展示界面" class="headerlink" title="影集展示界面"></a>影集展示界面</h3><p>在设计影视资源展示界面的过程中，首先应该注意的是如何设计一个用户友好的交互界面，让用户可以轻松地浏览、搜索、播放视频。在交互设计中，需要考虑用户的使用习惯、心理需求等因素，以提高用户体验。综合用户日常使用视频网站的行为习惯与可能性，将影视资源的展示界面向主流视频媒体网站设计是一个相对正确可行的方向。</p><p>一方面，以封面图作为每个视频资源展示的核心内容，占据展示界面的主要位置，另一方面，完善的功能栏在下方作为辅助工具，帮助用户在使用过程中可以便捷的对指定视频资源进行高效的控制编辑等操作。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230526224913.png"></p><p>封面作为视频资源的重要展示因素，可以很大程度上说明视频的主要内容，部分视频网站采用用户上传封面的形式进行封面展示，这种方式能够准确的由用户控制封面展示内容但相对繁琐，本地系统一般会随机生成视频封面，十分便捷却容易出现封面混乱等问题，项目设计过程中支持用户自行上传或是随机生成封面，最大程度上满足用户核心需求，而随机生成封面的过程中涉及到对视频核心数据的获取与随机帧数的生成，大致流程如图所示。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230526224937.png"></p><p>除此以外，对于影视资源而言最重要的就是如何在应用内进行信息和流媒体内容的展示和播放，普通形式的播放器无论从使用便利性角度还是趣味性角度而言都相对薄弱，所以在设计播放器形式过程中项目引入拟物设计的形式，拟物设计可以让用户更好地理解和使用网页。它模拟了现实世界中的物品和操作方式，让用户更容易上手，从而提高用户满意度。同时拟物设计可以让网页看起来更加真实，用户可以更自然地操作和感知网页的内容和功能。这种设计方式能够提高用户的体验和忠诚度吗。另外拟物设计可以让用户感觉更受信任，因为它模拟了现实世界中的操作方式。这种设计方式可以增加用户的信任感。</p><p>综上所述，项目对播放器进行了拟物设计。以 Nintendo Switch（任天堂公司生产的掌上游戏机）为原型，进行视频播放器的设计。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230526225011.png"></p><h2 id="项目后端功能设计"><a href="#项目后端功能设计" class="headerlink" title="项目后端功能设计"></a>项目后端功能设计</h2><p>项目后端使用 SpringBoot 作为后端开发框架，使用 MyBatis 作为持久层开发框架，严格遵守 MVC 三层结构的设计过程。控制器层作为应用程序中用于处理用户输入和控制应用程序流程的部分，负责接收用户输入，调用模型层进行数据处理，并将处理结果传递给视图层进行显示。视图层作为应用程序中用于呈现用户界面的部分，负责将模型层中的数据呈现给用户。模型层则是应用程序中用于处理业务逻辑和数据处理的部分，负责处理数据的存储、检索、更新等操作。<br>在开发过程中，后端主要处理业务逻辑以及实际功能实现，并对外提供接口供前端调用。</p><p>这个过程中就包括，设计数据库结构和建立数据表，根据业务需求，设计并建立相应的数据表，用于存储多媒体资源的相关信息，例如视频、图片、电子书的名称、路径、大小、上传时间等。实现数据访问层，利用 Mybatis 框架实现数据访问层以进行对数据库的相关操作，包括定义数据访问接口和实现数据访问接口，用于对数据库进行增删改查等操作。实现业务逻辑层，在控制器层和数据访问层之间实现业务逻辑层，用于处理业务逻辑，例如主色调分析、分页处理等。实现控制器层，使用 Springboot 框架实现控制器层，处理前端的请求，调用业务逻辑层和数据访问层，返回处理结果给前端。编写测试用例：编写测试用例，对后端代码进行单元测试和集成测试，确保代码的正确性和可靠性。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230527060848.png"></p><h1 id="系统具体实现"><a href="#系统具体实现" class="headerlink" title="系统具体实现"></a>系统具体实现</h1><h2 id="全部书库展示界面"><a href="#全部书库展示界面" class="headerlink" title="全部书库展示界面"></a>全部书库展示界面</h2><p>在设计全部书库的展示界面时，一方面要重视界面的美观与简洁，另一方面也要保证用户的功能体验充足且高效，所以全部书库界面设计从第一视角分为两个主要部分。</p><p>界面上方为随机推荐部分，会从数据库随机读取指定数目的电子书数据，以其封面生成走马灯，用户可以通过点击走马灯上的图片使用默认方式打开电子书文件。</p><p>界面下部分为各个书库展示界面，每个展示卡片左半部分为书库封面，右半部分则为书库的名称与简介，单击书库卡片则会跳转对应书库界面，右键则会弹出响应补充功能按钮：打开书库，编辑书库，删除书库，以及打开书库所在文件夹。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230527060944.png"></p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230527060956.png"></p><h2 id="书库展示界面"><a href="#书库展示界面" class="headerlink" title="书库展示界面"></a>书库展示界面</h2><p>界面最上方展示功能栏，功能栏第一项为上传书籍按钮，点击后调用系统文件管理器进行电子书文件选择并上传，第二项为刷新与同步按钮，点击后对本地电子书库进行数据同步，并刷新数据库，第三项为多功能搜索栏，用户可以根据指定搜索条件进行书籍的搜索。</p><p>功能栏下方为电子书展示与选择界面，用户可以查看所有电子书基本信息（书名，作者，出版商，评分，语言，出版日期，书号，页数，类型，标签等），并且可以根据指定栏目进行数据的排序展示。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230527061023.png"></p><p>界面右部分为电子书详细信息展示界面，最上方展示电子书封面，右键电子书封面部分，弹出补充功能栏，主要有默认方式打开，书籍元数据编辑，移除书籍，文件夹打开以及豆瓣搜索指定书籍。封面下方展示书籍详细信息，最下方为对应功能按钮：编辑元数据信息，默认方式打开电子书以及移除电子书。</p><p>拖拽上传是一种非常简单的文件上传方式，不需要进行复杂的选择或点击操作，只需要在文件管理器中拖拽文件或文件夹到上传窗口即可。这种方式能够节省用户的时间，提高上传效率。支持多文件上传，用户可以将多个文件或文件夹拖拽到上传窗口中，然后一次性上传它们。这种方式能够帮助用户快速上传大量文件，节省时间和精力。项目重新实现了全局拖拽上传方式，具体核心代码见附录 1-核心代码 1：拖拽上传图书（前端）。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230527061053.png"></p><h2 id="书籍元数据编辑界面"><a href="#书籍元数据编辑界面" class="headerlink" title="书籍元数据编辑界面"></a>书籍元数据编辑界面</h2><p>编辑书籍元数据界面，在用户点击功能键后弹出，界面左半部分以展示封面图为主，最上方展示封面图，图片下方是切换封面图按钮，点击后调出系统文件选择器进行图片选择并缓存后设置为封面，最下方是切换收藏状态按钮。界面右部分是编辑书籍元数据表单，按照书籍内数据特性分配表单选项情况。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230527061118.png"></p><h2 id="全部图集界面"><a href="#全部图集界面" class="headerlink" title="全部图集界面"></a>全部图集界面</h2><p>全部图集界面基本与全部书库界面保持一致，上方从数据库随机选择进行随机图片资源推荐，下方以栅栏式进行书库卡片的设计，自适应界面大小变化，其余功能键也与全部书库界面基本保持一致。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230527061147.png"></p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230527061156.png"></p><h2 id="图集展示界面-1"><a href="#图集展示界面-1" class="headerlink" title="图集展示界面"></a>图集展示界面</h2><p>图集展示界面采用瀑布流式布局进行展示，一方面瀑布流布局可以使页面看起来更加美观，具有视觉冲击力。图片、文字、视频等元素可以根据不同的尺寸、比例进行排列，使得整个页面呈现出错落有致的感觉，给人以美感。另一方面瀑布流布局可以让用户轻松地快速浏览大量内容，不需要像传统布局方式一样翻页或者滚动到底部查看更多内容，用户可以浏览更多的内容，提高了用户的使用体验。同时，瀑布流布局可以节约页面空间，因为它可以让网页上的元素紧凑地排列，使得页面可以呈现更多内容，同时使得页面不显得过于拥挤。最重要的是瀑布流布局可以适应不同屏幕尺寸，因为它可以根据屏幕宽度自动调整元素的排列方式，从而使得页面可以在不同的设备上呈现出最佳的布局效果。</p><p>项目中重写了整个瀑布流的实现逻辑，保证了完整实现后的瀑布流更加适应桌面化应用开发与使用，同时为瀑布流增加了除自适应宽度外的手动调节栅栏宽度大小功能，用户可以通过功能键或者快捷键（CTRL+鼠标滚轮上滑/下滑）进行页面中瀑布流栅栏宽度的自定义。</p><p>界面上方为图集展示界面分页部分与功能区，主要包括返回按钮与瀑布流宽度调节按钮以及同步功能键和文件上传功能键。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230527061241.png"></p><h2 id="图集元数据编辑界面"><a href="#图集元数据编辑界面" class="headerlink" title="图集元数据编辑界面"></a>图集元数据编辑界面</h2><p>在图集展示界面单击图片会展开图片资源展示与编辑界面栏，界面最上方是图片资源预览缓存图，图片下方展示图片的五个主色调色块，单击或右键可以选择复制色块的 RGB 值或 16 进制值。随后的是收藏状态切换栏，之后是图片信息编辑栏，支持用户编辑图片的相关网址链接，图片基本信息或简介，以及图片的标签内容。最下方是图片基本信息内容，会调用系统指令分析图片的分辨率，类型以及创建日期等基本信息。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230527061307.png"></p><h2 id="图片详情界面"><a href="#图片详情界面" class="headerlink" title="图片详情界面"></a>图片详情界面</h2><p>点击图片下方链接或者右键进入详情，即可进入图片详情界面，页面分为左右两个卡片界面，左半部分卡片主要进行图片内容的展示，点击缓存图片可以唤起预览窗口，在应用内预览图片情况，下方进行图片主色调分析，将图片的五个主色调以色块的形式进行展示。最下方对应两个主要功能键，页面截图和文件夹内打开。</p><p>页面右半部分则是功能键与基本信息展示卡片，最上方三个按钮分别支持用户将图片分享至 QQ 空间与微信或是复制文件路径，下方展示了图片的评分，相关链接，图片信息备注，标签，创建日期以及分辨率和图片类型等基本信息。最后一部分则是默认方式打开图片以及收藏状态切换按钮。</p><p>为了方便用户在使用过程中将软件内图片或使用情况分享给其他用户，项目重写了页面截图功能方法</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230527061346.png"></p><h2 id="全部影集界面"><a href="#全部影集界面" class="headerlink" title="全部影集界面"></a>全部影集界面</h2><p>全部影集界面设计方案与前面两部分（全部书库，全部图集）异曲同工，上半部分进行影视的随机推荐，点击后唤起默认视频播放器进行播放。页面下半部分以栅栏式进行书库卡片的设计，自适应界面大小变化，其余功能键也与全部书库界面基本保持一致。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230527061418.png"></p><h2 id="影集展示界面-1"><a href="#影集展示界面-1" class="headerlink" title="影集展示界面"></a>影集展示界面</h2><p>影集展示界面主要参考主流视频网站设计方式，以分立格式对视频资源进行管理，上方提供视频上传功能按钮以及本地文件同步功能。</p><p>下方逐个展示视频资源，展示栏大小同样使用栅栏式设计，随页面大小变化进行动态变化，每个视频展示栏上方展示封面，封面支持自动生成或主动上传，下方展示视频评分，名称以及功能键栏，用户可以通过功能栏，修改视频基本信息，默认方式打开，文件夹内打开或是删除指定视频。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230527061449.png"></p><h2 id="视频元数据编辑界面"><a href="#视频元数据编辑界面" class="headerlink" title="视频元数据编辑界面"></a>视频元数据编辑界面</h2><p>编辑视频基本信息界面，左半部分为视频封面以及收藏状态修改按钮，用户可以通过在此处修改视频封面，右半部分为视频基本信息编辑表单，按照每个栏目相关属性对表单进行优化，方便用户快捷修改，提高用户使用体验。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230527061527.png"></p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230527061537.png"></p><h2 id="视频详情展示界面"><a href="#视频详情展示界面" class="headerlink" title="视频详情展示界面"></a>视频详情展示界面</h2><p>影视详情界面，最上方展示视频名称，下方以标签形式展示视频相关 tag，随后是视频基本信息卡片，分栏形式展示视频的简介，导演，编剧，演员等相关人员，上映日期，相应链接，以及帧长，时长，声道等细节信息，最下方是默认播放按钮以及收藏状态切换栏。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230527061606.png"></p><p>最下方重写了原生视频播放器，对视频播放器进行拟物设计，并实现相应功能键。实现了对视频的播放/暂停切换，音量调节，进度调节，页面截图，视频搜做，静音，重置播放器，全屏切换，返回等功能。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230527061624.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/Ywrby/JiLe&quot;&gt;https://github.com/Ywrby/JiLe&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要</summary>
      
    
    
    
    
    <category term="Electron" scheme="http://ywrby.com/tags/Electron/"/>
    
    <category term="Java" scheme="http://ywrby.com/tags/Java/"/>
    
    <category term="JavaWeb" scheme="http://ywrby.com/tags/JavaWeb/"/>
    
    <category term="Vue" scheme="http://ywrby.com/tags/Vue/"/>
    
    <category term="集乐" scheme="http://ywrby.com/tags/%E9%9B%86%E4%B9%90/"/>
    
    <category term="开发记录" scheme="http://ywrby.com/tags/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>集乐-统一多媒体文件资源管理器-开发记录</title>
    <link href="http://ywrby.com/2022/10/03/%E9%9B%86%E4%B9%90-%E7%BB%9F%E4%B8%80%E5%A4%9A%E5%AA%92%E4%BD%93%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8-%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
    <id>http://ywrby.com/2022/10/03/%E9%9B%86%E4%B9%90-%E7%BB%9F%E4%B8%80%E5%A4%9A%E5%AA%92%E4%BD%93%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8-%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/</id>
    <published>2022-10-03T14:18:40.000Z</published>
    <updated>2022-10-03T04:18:16.619Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开发初衷"><a href="#开发初衷" class="headerlink" title="开发初衷"></a>开发初衷</h1><p>市面上常见的多媒体资源管理器并不少见，比如很有名的本地电子书管理工具-Calibre，图片管理工具-Eagle，以及音频爱好者喜爱的foobar2000。它们在各自的领域内都完美解决了诸多痛点，但人的需求是在不断变化的，互联网的环境也是在不断发生改变的。</p><p>作为一名仓鼠党，很多时候面对资源的收集与整理都会手足无措，起初多媒体文件数量相对较少的情况下，可以采用较为随意的管理方式对文件进行管理，但随着文件资源数量的增加，如果没有或缺乏一个合理的文件管理方式就会导致文件之间关系混乱，渐渐地，自己也会疲于维护与管理。而避免这种问题的方式就是通过文件管理工具对我们收集的资源或文件进行统一管理。</p><p>理想的情况是我们在软件使用初期定义我们的行为习惯，后续我们只需要将所有文件统一化的保存，工具就会帮我们进行统一的管理。这种管理方式在Calibre中就有所体现，我们在初次使用过程中定义电子书的保存地址，同时定义我们的元数据链接，后续我们在保存电子书的过程中就可以自动帮我们利用元数据链接（豆瓣，亚马逊等）获取电子书基本信息，从而进行统一管理。</p><p>而现有的多媒体文件资源管理器应用虽然数量众多，但有些在功能性上有所欠缺，有些在兼容性上出现问题，无法真正确保对大部分资源的统一管理。所以才有了开发针对于个人的统一多媒体文件资源管理器的想法。</p><h1 id="功能分析"><a href="#功能分析" class="headerlink" title="功能分析"></a>功能分析</h1><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%99%BD%E6%9D%BFdhuahdshahdsa22.jpg" alt="暂定合集类型"></p><h1 id="开发过程记录"><a href="#开发过程记录" class="headerlink" title="开发过程记录"></a>开发过程记录</h1><h2 id="图片的瀑布流展示实现"><a href="#图片的瀑布流展示实现" class="headerlink" title="图片的瀑布流展示实现"></a>图片的瀑布流展示实现</h2><p>瀑布流实现的主要思路是：</p><ol><li>确定所有图片的固定宽度</li><li>实时监听-获取窗口当前宽度</li><li>根据图片固定宽度和窗口宽度确定每行排列的图片数量</li><li>依次获取图片信息，准备开始进行瀑布流渲染</li><li>根据图片原尺寸信息以及固定宽度进行图片的缩放并保存缩放后的图片长度</li><li>第一行图片只需要按照顺序依次渲染图片</li><li>从第二行开始，根据之前保存的缩放图片长度确定当前最短列，在该位置渲染图片，直到整个渲染过程结束</li></ol><p>瀑布流扩展功能：</p><ol><li>通过功能键（CTRL+鼠标滚轮滑动）实现图片的放大缩小（主要在于调整图片的固定宽度计算图片新长度以及重新实现渲染图片过程）</li><li>懒加载，在滑动到图片位置前不加载图片以节省系统开销</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">el-scrollbar</span> <span class="attr">v-if</span>=<span class="string">&quot;targetVal == contentArr.length&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;enlargeImage&quot;</span>&gt;</span>enlargeImage<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;decreaseImage&quot;</span>&gt;</span>decreaseImage<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;getContentArr&quot;</span>&gt;</span>getContentArr<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;position: relative&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(column, index) in columns&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span> <span class="attr">class</span>=<span class="string">&quot;column&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, i) in column.columnArr&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;i&quot;</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; width: itemWidth + &#x27;px&#x27; &#125;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">el-image</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">              <span class="attr">:src</span>=<span class="string">&quot;item.src&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">              <span class="attr">fit</span>=<span class="string">&quot;cover&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">              <span class="attr">:style</span>=<span class="string">&quot;&#123; height: item.height + &#x27;px&#x27;, width: itemWidth + &#x27;px&#x27; &#125;&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">              <span class="attr">class</span>=<span class="string">&quot;image&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">              <span class="attr">lazy</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            /&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">el-scrollbar</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">props</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//从父组件获取图集信息</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">contentArr</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">type</span>: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">required</span>: <span class="literal">true</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">itemWidth</span>: <span class="number">220</span>, <span class="comment">//默认图片框宽度</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">targetVal</span>: <span class="number">0</span>, <span class="comment">//标志值，用来记录已读取图片信息数目，待全部读取完成后显示瀑布流</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">columns</span>: [],</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">arrIndex</span>: []</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">// pageSize: 25,</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">// startPage: 1,</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">// pageNum: 1</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">watch</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//监听标志值变化，直到所有图片长度成功获取</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">targetVal</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="function"><span class="title">handler</span>(<span class="params">newValue, oldValue</span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">if</span> (newValue == <span class="built_in">this</span>.contentArr.length) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="built_in">this</span>.initPage()</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">immediate</span>: <span class="literal">true</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="built_in">this</span>.getImgHeight()</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">// this.initPage()</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//监听键盘与鼠标（CTRL+鼠标滚轮）实现瀑布流图片缩放</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="built_in">this</span>.keyDownAndScroll()</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//初始化页面</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">initPage</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">//调用初始化方法</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">this</span>.init()</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">//在页面大小出现变化时重新加载瀑布流</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">window</span>.onresize = <span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">this</span>.init()</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//获取当前列下最短长度位置（用来确定下一张图片插入位置）</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">getMinHeight</span>(<span class="params">arr</span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">let</span> a = []</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        a.push(<span class="built_in">parseInt</span>(arr[i].height) + <span class="built_in">parseInt</span>(arr[i].top))</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">return</span> <span class="built_in">Math</span>.min.apply(<span class="literal">null</span>, a)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//获取指定长度位置后，进一步获取该位置索引值以确定图片插入位置</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">getMinIndex</span>(<span class="params">val</span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.columns.length; i++) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">let</span> height = <span class="built_in">this</span>.columns[i].columnArr[<span class="built_in">this</span>.columns[i].columnArr.length - <span class="number">1</span>].height</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">let</span> top = <span class="built_in">this</span>.columns[i].columnArr[<span class="built_in">this</span>.columns[i].columnArr.length - <span class="number">1</span>].top</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">if</span> (<span class="built_in">parseInt</span>(height) + <span class="built_in">parseInt</span>(top) == val) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="built_in">this</span>.arrIndex.push(i)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//异步获取图像宽高等基本信息</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">async</span> <span class="function"><span class="title">getImgHeight</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">//在异步方法下的this与JS全局中的this意义不同，</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">//所以在方法开始时重新定义全局this变量用来获得全局数据</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">let</span> sel = <span class="built_in">this</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">//遍历contentArr（从父组件获取并传递过来）</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.contentArr.length; i++) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">console</span>.log(i)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">let</span> img = <span class="keyword">new</span> Image() <span class="comment">//初始化图像对象</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">//获取指定图像（在请求路径后加入随机数保证强制刷新请求）</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        img.src = <span class="built_in">this</span>.contentArr[i].src + <span class="string">&#x27;?&#x27;</span> + <span class="built_in">Date</span>.parse(<span class="keyword">new</span> <span class="built_in">Date</span>())</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">//利用promise异步构造获取图像宽高等基本信息</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">reslove</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="keyword">let</span> scale = sel.itemWidth / img.width <span class="comment">//通过固定宽度计算长度缩放比例</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="keyword">let</span> width = img.width</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="keyword">var</span> height = <span class="built_in">Math</span>.floor(scale * img.height) <span class="comment">//对原长度进行缩放（height是真实展示在页面上的长度）</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="keyword">let</span> trueHeight = img.height <span class="comment">//同时保存图片的实际长度（文件真实长度，用来方便后续在同步方法中刷新展示长度）</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="comment">//将展示长度与真实长度作为返回值传递出去</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="keyword">let</span> data = &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">              <span class="attr">height</span>: height,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">              <span class="attr">trueHeight</span>: trueHeight,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">              <span class="attr">width</span>: width</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            reslove(data)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">await</span> promise</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">//等待异步方法执行完成后，对图片列表数据进行刷新</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="built_in">console</span>.log(data)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          sel.contentArr[i].height = data.height</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          sel.contentArr[i].trueHeight = data.trueHeight</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          sel.contentArr[i].width = data.width</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          sel.targetVal++</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//测试方法，打印contentArr</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">getContentArr</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.contentArr)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//刷新图片高度</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">refreshImageHeight</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">//刷新图片高度（用于在页面中通过CTRL+鼠标滚轮或滑动条动态调整图片宽度后进行图片高度的刷新）</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">//由于在页面初始化中执行的getImgHeight方法已经获取到了图片的真实高度，</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">//所以在此处就只需要重新计算宽度修改过之后的长度缩放比例以及新的高度（避免了在刷新页面过程中使用异步方法）</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.contentArr.length; i++) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">//计算缩放比例</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">let</span> scale = <span class="built_in">this</span>.itemWidth / <span class="built_in">this</span>.contentArr[i].width</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">let</span> trueHeight = <span class="built_in">this</span>.contentArr[i].trueHeight</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">let</span> height = <span class="built_in">Math</span>.floor(scale * trueHeight) <span class="comment">//对原长度进行缩放（height是真实展示在页面上的长度）</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">//更新刷新后的新高度</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">this</span>.contentArr[i].height = height</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">// console.log(this.contentArr[i])</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//初始化（重载）页面瀑布流</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">this</span>.columns = []</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">let</span> contentLen = <span class="built_in">this</span>.contentArr.length</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">// let contentLen = this.pageSize</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">// 根据可视区域的宽度判断需要几列</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">let</span> cWidth = <span class="built_in">document</span>.documentElement.clientWidth || <span class="built_in">document</span>.body.clientWidth</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">// 假设图片宽度为240px</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">let</span> cLen = <span class="built_in">Math</span>.floor(cWidth / (<span class="built_in">this</span>.itemWidth + <span class="number">20</span>) - <span class="number">1</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">console</span>.log(cLen)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">// 初始化每一列的第一行元素</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cLen; i++) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">this</span>.contentArr[i].top = <span class="number">0</span> <span class="comment">//预设距离顶部值为0</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">this</span>.columns.push(&#123; <span class="attr">columnArr</span>: [<span class="built_in">this</span>.contentArr[i]] &#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">// 对剩余元素的判断，应该放到哪一列</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">for</span> (<span class="keyword">var</span> index = cLen; index &lt; contentLen; index++) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">this</span>.arrIndex = []</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">let</span> arr = [] <span class="comment">//找到高度最小的一列，可能有多个</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">let</span> minHeight = <span class="number">0</span> <span class="comment">//高度最小的一列的高度</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">let</span> pushIndex = <span class="number">0</span> <span class="comment">//高度最小的一列所在位置的索引</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.columns.length; i++) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          arr.push(&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="attr">height</span>: <span class="built_in">this</span>.columns[i].columnArr[<span class="built_in">this</span>.columns[i].columnArr.length - <span class="number">1</span>].height,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="attr">top</span>: <span class="built_in">this</span>.columns[i].columnArr[<span class="built_in">this</span>.columns[i].columnArr.length - <span class="number">1</span>].top</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          &#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        minHeight = <span class="built_in">this</span>.getMinHeight(arr)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">this</span>.getMinIndex(minHeight)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">if</span> (<span class="built_in">this</span>.arrIndex.length &gt; <span class="number">0</span>) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          pushIndex = <span class="built_in">Math</span>.min.apply(<span class="literal">null</span>, <span class="built_in">this</span>.arrIndex) <span class="comment">//出现高度一样的，去索引最小的</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">this</span>.contentArr[index].top = minHeight + <span class="number">20</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">this</span>.columns[pushIndex].columnArr.push(<span class="built_in">this</span>.contentArr[index])</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//图像放大（宽度加10）</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">enlargeImage</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">this</span>.itemWidth += <span class="number">10</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">this</span>.refreshImageHeight()</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">this</span>.init()</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//图片缩小（宽度减10）</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">decreaseImage</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">this</span>.itemWidth -= <span class="number">10</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">this</span>.refreshImageHeight()</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">this</span>.init()</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">// 监听键盘和鼠标滚轮组合</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">keyDownAndScroll</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">let</span> ctrlDown = <span class="literal">false</span> <span class="comment">//ctrl按键按压情况</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      ;(<span class="built_in">document</span>.onkeydown = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">//事件对象兼容</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">let</span> e1 = e || event || <span class="built_in">window</span>.event || <span class="built_in">arguments</span>.callee.caller.arguments[<span class="number">0</span>]</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">//按下CTRL键下后记录当前情况</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">if</span> (e1.keyCode === <span class="number">17</span>) ctrlDown = <span class="literal">true</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;),</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        (<span class="built_in">document</span>.onkeyup = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="keyword">let</span> e1 = e || event || <span class="built_in">window</span>.event || <span class="built_in">arguments</span>.callee.caller.arguments[<span class="number">0</span>]</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="comment">//松开后修改CTRL键按压情况</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="keyword">if</span> (e1.keyCode === <span class="number">17</span>) ctrlDown = <span class="literal">false</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;),</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">//监听鼠标滚轮情况</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">document</span>.addEventListener(</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="string">&#x27;mousewheel&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="comment">// e.preventDefault()</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="keyword">let</span> e1 = e || event || <span class="built_in">window</span>.event || <span class="built_in">arguments</span>.callee.caller.arguments[<span class="number">0</span>]</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="comment">//判断CTRL键是否被按下</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="keyword">if</span> (ctrlDown) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">              <span class="keyword">if</span> (e1.wheelDeltaY &gt; <span class="number">0</span>) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="comment">// 放大</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="built_in">console</span>.log(<span class="string">&#x27;放大&#x27;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="built_in">this</span>.enlargeImage()</span></span></span><br><span class="line"><span class="javascript"><span class="xml">              &#125; <span class="keyword">else</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="comment">// 缩小</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="built_in">console</span>.log(<span class="string">&#x27;缩小&#x27;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="built_in">this</span>.decreaseImage()</span></span></span><br><span class="line"><span class="javascript"><span class="xml">              &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="literal">false</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        )</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h1 id="开发进度"><a href="#开发进度" class="headerlink" title="开发进度"></a>开发进度</h1><table><thead><tr><th>日期</th><th>完成内容</th><th>待处理</th></tr></thead><tbody><tr><td>2022/1/26</td><td>框架搭建，文件夹选择器，IndexedDB测试用例</td><td>文件夹内文件预览，打开</td></tr><tr><td>2022/1/27</td><td>文件内文件预览，文件打开以及所在文件夹打开</td><td>文件信息编辑（加tag，改名，移除等）</td></tr><tr><td>2022/1/27-2</td><td>窗体最小宽度调整，图片预览部分功能按键设置</td><td></td></tr><tr><td>2022/1/28</td><td>在card下打开所在文件夹，删除该文件，编辑文件名等功能，以及打分模块示例</td><td></td></tr><tr><td>2022/1/30</td><td>视频封面选择测试，图片压缩功能测试</td><td></td></tr><tr><td>2022/2/3</td><td>右键菜单，视频封面图选择与删除</td><td>压缩文件第一张图片预览</td></tr><tr><td>2022/2/4</td><td>压缩文件读取与选择性解压，设置压缩文件封面</td><td>高级选择表单</td></tr><tr><td>2022/2/4-2</td><td>本地文件分页</td><td></td></tr><tr><td>2022/4/6</td><td>本地重新部署</td><td>调用python执行功能性文件，页面设计</td></tr><tr><td>2022/7/7</td><td>全局变量文件Global.vue测试</td><td></td></tr><tr><td>2022/7/8</td><td>引入NaiveUI</td><td></td></tr><tr><td>2022/7/9</td><td>完成全局路径基本配置,配置electron builder进行前端打包，解决打包后iconfont显示问题，后端基本部署完成，H2数据库引入完成，测试基本使用功能正常，由后端监听启动前端部分测试成功</td><td>资源管理方式定义，资源信息存储方式，后端打包方式，H2数据库可视化部分测试</td></tr><tr><td>2022/7/10</td><td>添加图集功能测试，前后端连接，H2数据库构建，图集录入功能实现</td><td>图集展示功能</td></tr><tr><td>2022/7/23</td><td>图集选择栏</td><td>图集展示功能</td></tr><tr><td>2022/7/25</td><td>瀑布流图片展示功能demo完成</td><td>进一步优化瀑布流展示</td></tr><tr><td>2022/7/26</td><td>瀑布流优化，还有进一步优化空间</td><td>creted,mounted选择</td></tr><tr><td>2022/7/27</td><td>瀑布流功能暂定版（修正数据加载跳闪，数据多次重加载）</td><td>图像信息表单主动填入，图像多种展示方式</td></tr><tr><td>2022/7/28</td><td>瀑布流下拉无线刷新初版</td><td></td></tr><tr><td>2022/8/26</td><td>瀑布流图片放大缩小功能实现，同时监听鼠标滚轮和CTRL按键后进行放大缩小实现</td><td>功能继续测试与整合</td></tr><tr><td>2022/8/28</td><td>实现后端自动获取视频缩略图功能，实现前端获取后端生成的视频缩略图功能</td><td>缩略图保存位置以及数据统一</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;开发初衷&quot;&gt;&lt;a href=&quot;#开发初衷&quot; class=&quot;headerlink&quot; title=&quot;开发初衷&quot;&gt;&lt;/a&gt;开发初衷&lt;/h1&gt;&lt;p&gt;市面上常见的多媒体资源管理器并不少见，比如很有名的本地电子书管理工具-Calibre，图片管理工具-Eagle，以及音频爱好</summary>
      
    
    
    
    
    <category term="Electron" scheme="http://ywrby.com/tags/Electron/"/>
    
    <category term="Java" scheme="http://ywrby.com/tags/Java/"/>
    
    <category term="JavaWeb" scheme="http://ywrby.com/tags/JavaWeb/"/>
    
    <category term="Vue" scheme="http://ywrby.com/tags/Vue/"/>
    
    <category term="集乐" scheme="http://ywrby.com/tags/%E9%9B%86%E4%B9%90/"/>
    
    <category term="开发记录" scheme="http://ywrby.com/tags/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>IndexedDB浏览器数据库基本概念</title>
    <link href="http://ywrby.com/2022/01/24/IndexedDB%E6%B5%8F%E8%A7%88%E5%99%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://ywrby.com/2022/01/24/IndexedDB%E6%B5%8F%E8%A7%88%E5%99%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2022-01-24T09:15:29.000Z</published>
    <updated>2022-10-03T03:44:48.363Z</updated>
    
    <content type="html"><![CDATA[<p>参考文档：<a href="https://www.cnblogs.com/chenjun1/p/11644866.html">https://www.cnblogs.com/chenjun1/p/11644866.html</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;scroll-y&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mb-2&quot;</span>&gt;</span>IndexDbDemo.vue<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addData()&quot;</span>&gt;</span>增加数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;updateData()&quot;</span>&gt;</span>编辑数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;deleteData()&quot;</span>&gt;</span>删除数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;findData()&quot;</span>&gt;</span>查找数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mt-2&quot;</span>&gt;</span>显示的数据<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; personData &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">//参考文档：https://www.cnblogs.com/chenjun1/p/11644866.html</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; reactive, toRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// 创建数据库</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// 第一个参数为数据库名称，第二个数据库为版本号，返回一个IDBOpenDBRequest对象用于操作数据库。</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// 对于open()的第一个参数数据库名，open()会先去查找本地是否已有这个数据库，如果有则直接将这个数据库返回，如果没有，则先创建这个数据库，再返回。对于第二个参数版本号，则是一个可选参数，如果不传，默认为1，但是如果传入必须是一个整数</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> request = indexedDB.open(<span class="string">&#x27;myDatabase&#x27;</span>)</span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> db</span></span><br><span class="line"><span class="javascript">request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  db = request.result</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">&#x27;数据库打开成功&#x27;</span>)</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">request.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">&#x27;数据库打开报错&#x27;</span>)</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="comment">//数据库升级事件</span></span></span><br><span class="line"><span class="javascript">request.onupgradeneeded = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  db = event.target.result</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> objectStore</span></span><br><span class="line"><span class="javascript">  <span class="comment">//新增一张叫做person的表格，主键是id,是否存在，如果不存在再新建</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">if</span> (!db.objectStoreNames.contains(<span class="string">&#x27;person&#x27;</span>)) &#123;</span></span><br><span class="line"><span class="javascript">    objectStore = db.createObjectStore(<span class="string">&#x27;person&#x27;</span>, &#123; <span class="attr">keyPath</span>: <span class="string">&#x27;id&#x27;</span> &#125;)</span></span><br><span class="line"><span class="javascript">    objectStore.createIndex(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, &#123; <span class="attr">unique</span>: <span class="literal">false</span> &#125;)</span></span><br><span class="line"><span class="javascript">    objectStore.createIndex(<span class="string">&#x27;email&#x27;</span>, <span class="string">&#x27;email&#x27;</span>, &#123; <span class="attr">unique</span>: <span class="literal">true</span> &#125;)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> addData = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> request = db</span></span><br><span class="line"><span class="javascript">    .transaction([<span class="string">&#x27;person&#x27;</span>], <span class="string">&#x27;readwrite&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    .objectStore(<span class="string">&#x27;person&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    .add(&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">age</span>: <span class="number">24</span>, <span class="attr">email</span>: <span class="string">&#x27;zhangsan@example.com&#x27;</span> &#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&#x27;数据写入成功&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  request.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&#x27;数据写入失败&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> state = reactive(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">personData</span>: &#123;&#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> &#123; personData &#125; = toRefs(state)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> findData = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> transaction = db.transaction([<span class="string">&#x27;person&#x27;</span>])</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> objectStore = transaction.objectStore(<span class="string">&#x27;person&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> request = objectStore.get(<span class="number">1</span>)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  request.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&#x27;事务失败&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (request.result) &#123;</span></span><br><span class="line"><span class="javascript">      state.personData = request.result</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;Name: &#x27;</span> + request.result.name)</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;Age: &#x27;</span> + request.result.age)</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;Email: &#x27;</span> + request.result.email)</span></span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;未获得数据记录&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> updateData = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> request = db</span></span><br><span class="line"><span class="javascript">    .transaction([<span class="string">&#x27;person&#x27;</span>], <span class="string">&#x27;readwrite&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    .objectStore(<span class="string">&#x27;person&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    .put(&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;李四&#x27;</span>, <span class="attr">age</span>: <span class="number">35</span>, <span class="attr">email</span>: <span class="string">&#x27;lisi@example.com&#x27;</span> &#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&#x27;数据更新成功&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  request.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&#x27;数据更新失败&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> deleteData = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> request = db.transaction([<span class="string">&#x27;person&#x27;</span>], <span class="string">&#x27;readwrite&#x27;</span>).objectStore(<span class="string">&#x27;person&#x27;</span>).delete(<span class="number">1</span>)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&#x27;数据删除成功&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span> <span class="attr">lang</span>=<span class="string">&quot;scss&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我的博客即将同步至腾讯云开发者社区，邀请大家一同入驻：<a href="https://cloud.tencent.com/developer/support-plan?invite_code=tnjsrr6rwrrk">https://cloud.tencent.com/developer/support-plan?invite_code=tnjsrr6rwrrk</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考文档：&lt;a href=&quot;https://www.cnblogs.com/chenjun1/p/11644866.html&quot;&gt;https://www.cnblogs.com/chenjun1/p/11644866.html&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;h</summary>
      
    
    
    
    
    <category term="IndexedDB" scheme="http://ywrby.com/tags/IndexedDB/"/>
    
  </entry>
  
  <entry>
    <title>25-两级页表</title>
    <link href="http://ywrby.com/2021/12/29/25-%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8/"/>
    <id>http://ywrby.com/2021/12/29/25-%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8/</id>
    <published>2021-12-29T10:16:26.000Z</published>
    <updated>2022-01-03T07:52:33.680Z</updated>
    
    <content type="html"><![CDATA[<h1 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h1><h2 id="单级页表的问题"><a href="#单级页表的问题" class="headerlink" title="单级页表的问题"></a>单级页表的问题</h2><p>某计算机系统按字节寻址，支持32位的逻辑地址，采用分页存储管理，页面大小为4KB，页表项长度为4B。</p><p>4KB = $2^{12}B$，因此页内地址要用12位表示，剩余20位表示页号。<br>因此，该系统中用户进程最多有220页。相应的，一个进程的页表中，最多会有220 = 1M = 1,048,576个页表项，所以一个页表最大需要220*4B=$2^{22}B$，共需要$2^{22}/2^{12}=2^{10}$个页框存储该页表。</p><p>根据页号查询页表的方法：K号页对应的页表项存放位置=页表始址＋K*4要在所有的页表项都连续存放的基础上才能用这种方法找到页表项</p><p>需要专门给进程分配$2^{10}=1024$个连续的页框来存放它的页表</p><p>同时根据局部性原理可知，很多时候，进程在一段时间内只需要访问某几个页面就可以正常运行了。因此没有必要让整个页表都常驻内存。</p><h3 id="问题一-页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。"><a href="#问题一-页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。" class="headerlink" title="问题一:页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。"></a>问题一:页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。</h3><p>解决方法：我们在解决“进程在内存中必须连续存储问题”时将进程地址空间分页，并为其建立一张页表，记录各页面的存放位置。同样的思路也可用于解决“页表必须连续存放”的问题，把必须连续存放的页表再分页</p><p>可将长长的页表进行分组，使每个内存块刚好可以放入一个分组（比如上个例子中，页面大小4KB,每个页表项4B，每个页面可存放1K个页表项，因此每1K个连续的页表项为一组，每组刚好占一个内存块，再讲各组离散地放到各个内存块中）</p><p>另外，要为离散分配的页表再建立一张页表，称为页目录表，或称外层页表，或称顶层页表</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211229185116.png"></p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211229185307.png"></p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211229185457.png"></p><h3 id="问题二-没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。"><a href="#问题二-没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。" class="headerlink" title="问题二:没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。"></a>问题二:没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。</h3><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211229185602.png"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211229185810.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;两级页表&quot;&gt;&lt;a href=&quot;#两级页表&quot; class=&quot;headerlink&quot; title=&quot;两级页表&quot;&gt;&lt;/a&gt;两级页表&lt;/h1&gt;&lt;h2 id=&quot;单级页表的问题&quot;&gt;&lt;a href=&quot;#单级页表的问题&quot; class=&quot;headerlink&quot; title=&quot;单级页</summary>
      
    
    
    
    
    <category term="操作系统" scheme="http://ywrby.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>24-基本分页存储管理</title>
    <link href="http://ywrby.com/2021/12/27/24-%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/"/>
    <id>http://ywrby.com/2021/12/27/24-%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/</id>
    <published>2021-12-27T12:13:32.000Z</published>
    <updated>2021-12-29T10:29:40.716Z</updated>
    
    <content type="html"><![CDATA[<h1 id="非连续分配管理方式-基本分页存储管理"><a href="#非连续分配管理方式-基本分页存储管理" class="headerlink" title="非连续分配管理方式-基本分页存储管理"></a>非连续分配管理方式-基本分页存储管理</h1><p>从之前文章介绍的两种连续分配管理方式中我们可以看到：</p><ul><li>固定分区分配：缺乏灵活性，会产生大量的内部碎片，内存利用率很低</li><li>动态分区分配：会产生大量外部碎片，虽然可以用紧凑技术处理，但时间成本会增加</li></ul><p>考虑到连续分配方式的缺陷，人们考虑到如果可以将一个进程分散然后分别装入到不相邻分区中就可以更加高效利用内存，基于这一思想，产生了“非连续分配方式”也成为离散分配方式</p><h2 id="把“固定分区分配”改造为“非连续分配”"><a href="#把“固定分区分配”改造为“非连续分配”" class="headerlink" title="把“固定分区分配”改造为“非连续分配”"></a>把“固定分区分配”改造为“非连续分配”</h2><p>假设进程A大小为23MB，但是每个分区大小只有10MB，如果进程只能占用一个分区，那显然放不下。</p><blockquote><p>解决思路:如果允许进程占用多个分区，那么可以把进程拆分成10MB+10MB+3MB三个部分，再把这三个部分分别放到三个分区中(这些分区不要求连续）…</p></blockquote><p>进程A的最后一个部分是3MB，放入分区后会产生7MB的内部碎片。<br>如果每个分区大小为2MB，那么进程A可以拆分成11*2MB +1MB共12个部分，只有最后一部分1MB占不满分区，会产生1MB的内部碎片。<br>显然，如果把分区大小设置的更小一些，内部碎片会更小，内存利用率会更高。</p><p>上面这种思想就是“基本分页存储管理”的思想――把内存分为一个个相等的小分区,再按照分区大小把进程拆分成一个个小部分</p><h2 id="分页存储管理的基本概念"><a href="#分页存储管理的基本概念" class="headerlink" title="分页存储管理的基本概念"></a>分页存储管理的基本概念</h2><p>将内存空间分为一个个大小相等的分区（比如:每个分区4KB），每个分区就是一个“页框”，或称“页帧”、“内存块”、“物理块”。每个页框有一个编号，即“页框号”(或者“内存块号”、“页帧号”、“物理块号”)页框号从0开始。</p><p>将用户进程的地址空间也分为与页框大小相等的一个个区域，称为“页”或“页面”。每个页面也有一个编号，即“页号”，页号也是从0开始。（注:进程的最后一个页面可能没有一个页框那么大。因此，页框不能太大，否则可能产生过大的内部碎片）</p><p>操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的页面与内存的页框有一一对应的关系。</p><p>各个页面不必连续存放，也不必按先后顺序来，可以放到不相邻的各个页框中。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211227202745.png"></p><h3 id="实现地址转换"><a href="#实现地址转换" class="headerlink" title="实现地址转换"></a>实现地址转换</h3><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211227203210.png"></p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211227203335.png"></p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211227203543.png"></p><p>结论:如果每个页面大小为2^K B，用二进制数表示逻辑地址，则末尾K位即为页内偏移量，其余部分就是页号。因此，如果让每个页面的大小为2的整数幂，计算机就可以很方便地得出一个逻辑地址对应的页号和页内偏移量。</p><p>分页存储管理的逻辑地址结构如下所示:</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211227204258.png"></p><p>地址结构包含两个部分:前一部分为页号，后一部分为页内偏移量w。在上图所示的例子中，地址长度为32位，其中0<del>11位为“页内偏移量”，或称“页内地址”，12</del>31位为“页号”。</p><ul><li>如果有K位表示“页内偏移量”，则说明该系统中一个页面的大小是2^K个内存单元</li><li>如果有M位表示“页号”，则说明在该系统中，一个进程最多允许有2^M个页面</li></ul><p>要如何知道该页号对应在内存中的起始地址</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211227204930.png"></p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211227205435.png"></p><h2 id="基本地址变换机构"><a href="#基本地址变换机构" class="headerlink" title="基本地址变换机构"></a>基本地址变换机构</h2><p>（基本地址变换机构是用于实现逻辑地址到物理地址转换的一组硬件机构）</p><p>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。</p><p>通常会在系统中设置一个页表寄存器（PTR），存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的始址和页表长度放在进程控制块（PCB）中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211229164109.png"></p><p>设页面大小为L，逻辑地址A到物理地址E的变换过程如下：</p><ol><li>计算页号Р和页内偏移量W（如果用十进制数手算，则P=A/L，W=A%L;但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量）</li><li>比较页号P和页表长度M，若P&gt;=M，则产生越界中断，否则继续执行。（注意:页号是从O开始的，而页表长度至少是1，因此 P=M时也会越界）</li><li>页表中页号P对应的页表项地址=页表起始地址F+页号P<em>页表项长度，取出该页表项内容b，即为内存块号。（注意区分页表项长度、页表长度、页面大小的区别。页表长度指的是这个页表中总共有几个页表项，即总共有几个页;页表项长度指的是每个页表项占多大的存储空间;页面大小指的是一个页面占多大的存储空间）<br>④计算E= b</em>L+W，用得到的物理地址E去访问内存。（如果内存块号、页面偏移量是用二进制表示的,那么把二者拼接起来就是最终的物理地址了）</li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>例:若页面大小L为1K字节，页号2对应的内存块号b=8，将逻辑地址A=2500转换为物理地址E。</p><blockquote><p>等价描述:某系统按字节寻址，逻辑地址结构中，页内偏移量占10位，页号2对应的内存块号b=8，将逻辑地址A=2500转换为物理地址E。</p></blockquote><ol><li>计算页号、页内偏移量<ul><li>页号P=A/L = 2500/1024 =2</li><li>页内偏移量W=A%L= 2500%1024= 452</li></ul></li><li>根据题中条件可知，页号2没有越界，其存放的内存块号b=8</li><li>物理地址E=b*L+W=8*1024+425=8644</li></ol><p>在分页存储管理（页式管理）的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，页式管理中地址是一维的。即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。</p><h2 id="具有快表的地址变换机构"><a href="#具有快表的地址变换机构" class="headerlink" title="具有快表的地址变换机构"></a>具有快表的地址变换机构</h2><h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">100</span>)&#123;</span><br><span class="line">    a[i]=i;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211229175757.png"></p><p>以上面这段代码为例，10号内存块中存放了程序执行涉及到的相关指令，23号代码块中存放了程序定义的变量，在程序执行过程中，显而易见会频繁的访问到10号和23号代码块</p><p>在此基础上，我们引申出来时间与空间的局部性</p><ul><li>时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再次被访问。(因为程序中存在大量的循环)<ul><li>以上面代码为例，我们定义了变量i，那么我们极有可能在之后频繁的调用变量i（在上文的while循环中不断执行累加操作）</li></ul></li><li>空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的)<ul><li>以上面的代码为例，我们创建了长度为100的数组a，并且为数组第一位赋值为0，那么我们接下来既有可能回去访问它的第二位第三位（在上文中按顺序为数组循环赋值）</li></ul></li></ul><p>上问介绍的基本地址变换机构中，每次要访问一个逻辑地址，都需要查询内存中的页表。由于局部性原理，可能连续很多次查到的都是同一个页表项。既然如此，人们就考虑利用这个特性减少访问页表的次数</p><h3 id="快表概念"><a href="#快表概念" class="headerlink" title="快表概念"></a>快表概念</h3><p>快表，又称联想寄存器（TLB），是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。</p><p>快表执行过程<br><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211229180721.png"></p><h3 id="引入快表后，地址变换的过程"><a href="#引入快表后，地址变换的过程" class="headerlink" title="引入快表后，地址变换的过程"></a>引入快表后，地址变换的过程</h3><ol><li>CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。</li><li>如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。</li><li>如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表未命中，则访问某个逻辑地址需要两次访存（注意:在找到页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换）</li></ol><p>由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。因为局部性原理，一般来说快表的命中率可以达到90%以上。</p><p>例：某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问一次快表耗时1us，访问一次内存耗时100us。若快表的命中率为90%，那么访问一个逻辑地址的平均耗时是多少?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(1+100)* 0.9+(1+100+100)* 0.1 =111 us</span><br><span class="line"></span><br><span class="line">有的系统支持快表和慢表同时查找，如果是这样，平均耗时应该是</span><br><span class="line">(1+100)*0.9+(100+100)* 0.1=110.9 us</span><br><span class="line"></span><br><span class="line">若未采用快表机制，则访问一个逻辑地址需要</span><br><span class="line">100+100= 200us</span><br></pre></td></tr></table></figure><p>显然，引入快表机制后，访问一个逻辑地址的速度快多了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;非连续分配管理方式-基本分页存储管理&quot;&gt;&lt;a href=&quot;#非连续分配管理方式-基本分页存储管理&quot; class=&quot;headerlink&quot; title=&quot;非连续分配管理方式-基本分页存储管理&quot;&gt;&lt;/a&gt;非连续分配管理方式-基本分页存储管理&lt;/h1&gt;&lt;p&gt;从之前文章介</summary>
      
    
    
    
    
    <category term="操作系统" scheme="http://ywrby.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>23-内存空间的分配与回收</title>
    <link href="http://ywrby.com/2021/12/25/23-%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6/"/>
    <id>http://ywrby.com/2021/12/25/23-%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6/</id>
    <published>2021-12-25T11:12:46.000Z</published>
    <updated>2021-12-27T12:15:50.746Z</updated>
    
    <content type="html"><![CDATA[<h1 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h1><blockquote><p>连续分配：指系统为用户进程分配的必须是一个连续的内存空间</p></blockquote><h2 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h2><p>在单一连续分配方式中，内存被分为系统区和用户区。</p><ul><li>系统区通常位于内存的低地址部分，用于存放操作系统相关数据</li><li>用户区用于存放用户进程相关数据。内存中只能有一道用户程序，用户程序独占整个用户区空间。</li></ul><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211225191718.png"></p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点：实现简单，无外部碎片，可以采用覆盖技术扩充内存，不一定需要内存保护机制</li><li>缺点：只能用于单用户，单任务的操作系统中，有内部碎片，存储器利用率极低</li></ul><blockquote><p>内部碎片：分配给某进程的内存区域中，如果有些部分没有用上，这些内存部分就被称为“内部碎片”</p></blockquote><h2 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h2><p>20世纪60年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。</p><p>固定分区分配又可以细分为分区大小相等与分区大小不等两种情况</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211225192123.png"></p><p>针对分区大小不等的情况，系统为了维护分区状态以及管理各个分区，需要建立一个数据结构–分区说明表：</p><table><thead><tr><th>分区号</th><th>大小（MB）</th><th>起始地址（M）</th><th>状态</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>8</td><td>未分配</td></tr><tr><td>2</td><td>2</td><td>10</td><td>未分配</td></tr><tr><td>3</td><td>4</td><td>12</td><td>已分配</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table><p>当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为“已分配”。</p><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>分区大小相等：<ul><li>优点：适用于计算机控制多个相同对象的场合</li><li>缺点：缺乏灵活性</li></ul></li><li>分区大小不等：<ul><li>优点：实现简单，无外部碎片，增加了灵活性，可以按照不同大小的进程需求，根据系统中运行的作业大小情况进行划分</li><li>缺点：当用户程序过大时，可能所有分区都不能满足需求，此时不得不采用覆盖技术解决，但这又会降低性能，会产生内部碎片，内存效率低</li></ul></li></ul><h2 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h2><p>动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。(eg:假设某计算机内存大小为64MB，系统区8MB，用户区共56 MB..)</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.jpg"></p><p>动态分区分配中首先我们要考虑“系统要用什么样的数据结构记录内存使用情况？”，另外从进程4进入过程中我们看到，有多个空闲分区满足它的要求，所以我们要考虑“当很多空闲分区都能满足需求时，应该选择哪个分区进行分配”，最后我们看到，在进程3执行结束后，几个空闲分区在物理位置上相连，是否要将它们几个结合，所以我们还需要考虑“如何进行分区的分配与回收”</p><h3 id="系统要用什么样的数据结构记录内存使用情况？"><a href="#系统要用什么样的数据结构记录内存使用情况？" class="headerlink" title="系统要用什么样的数据结构记录内存使用情况？"></a>系统要用什么样的数据结构记录内存使用情况？</h3><p>最长采用两种常用的数据结构：空闲分区表和空闲分区链</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211225194753.png"></p><h3 id="当很多空闲分区都能满足需求时，应该选择哪个分区进行分配"><a href="#当很多空闲分区都能满足需求时，应该选择哪个分区进行分配" class="headerlink" title="当很多空闲分区都能满足需求时，应该选择哪个分区进行分配"></a>当很多空闲分区都能满足需求时，应该选择哪个分区进行分配</h3><p>把一个新作业装入内存时，须按照一定的动态分区分配算法，从空闲分区表（或空闲分区链）中选出一个分区分配给该作业。由于分配算法算法对系统性能有很大的影响，因此人们对它进行了广泛的研究。并在此基础上完成了<a href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95">多种动态分区分配算法</a></p><h3 id="如何进行分区的分配与回收"><a href="#如何进行分区的分配与回收" class="headerlink" title="如何进行分区的分配与回收"></a>如何进行分区的分配与回收</h3><p>首先是在分配过程中，可能会出现将进程大小与空闲分区大小不相等的情况，此时对于空闲分区表来说就需要修改对应分区大小以及起始地址。也可能出现进程大小恰好等于空闲分区大小的情况，此时就需要删除空闲分区表中的一行，对空闲分区链也同理</p><p>而对于回收过程，需要注意的就是，如果一个进程执行结束，其所在分区由分配状态变为空闲状态，就需要检查该分区前后是否还存在空闲分区，如果前方或后方存在空闲分区，就需要将他们合并为一个分区，并修改空闲分区表。如果前后都不存在空闲分区，则需要在空闲分区表中新增一行</p><p>动态分区分配没有内部碎片，但是有外部碎片。</p><blockquote><ul><li>内部碎片：分配给某进程的内存区域中，如果有些部分没有用上。</li><li>外部碎片：是指内存中的某些空闲分区由于太小而难以利用。</li><li>紧凑技术：如果内存中空闲空间的总和本来可以满足某进程的要求,但由于进程需要的是一整块连续的内存空间，因此这些“碎片”不能满足进程的需求。可以通过紧凑（拼凑，Compaction)技术来解决外部碎片。</li></ul></blockquote><h2 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h2><h3 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h3><ul><li>算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。</li><li>如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</li></ul><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211227170023.png"></p><h3 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h3><ul><li>算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即优先使用更小的空闲区。</li><li>如何实现：空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</li></ul><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211227170350.png"></p><p>缺点：每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多的外部碎片。</p><h3 id="最坏适应算法"><a href="#最坏适应算法" class="headerlink" title="最坏适应算法"></a>最坏适应算法</h3><p>又称最大适应算法（Largest Fit）</p><ul><li>算法思想：为了解决最佳适应算法的问题–即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。</li><li>如何实现：空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</li></ul><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211227170723.png"></p><p>缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后有“大进程”到达，就没有内存分区可用了。</p><h3 id="临近适应算法"><a href="#临近适应算法" class="headerlink" title="临近适应算法"></a>临近适应算法</h3><p>基于首次适应算法的一种改良</p><ul><li>算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。</li><li>如何实现：空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</li></ul><p>首次适应算法每次都要从头查找，每次都需要检索低地址的小分区。但是这种规则也决定了当低地址部分有更小的分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的天分区保留下来（最佳适应算法的优点）</p><p>邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用（最大适应算法的缺点）</p><h3 id="四种动态分配算法比较"><a href="#四种动态分配算法比较" class="headerlink" title="四种动态分配算法比较"></a>四种动态分配算法比较</h3><table><thead><tr><th>算法</th><th>算法思想</th><th>分区排列顺序</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>首次适应</td><td>从头到尾找适合的分区</td><td>空闲分区以地址递增次序排列</td><td>综合看性能最好。算法开销小,回收分区后一般不需要对空闲分区队列重新排序</td><td></td></tr><tr><td>最佳适应</td><td>优先使用更小的分区，以保留更多大分区</td><td>空闲分区以容量递增次序排列</td><td>会有更多的大分区被保留下来，更能满足大进程需求</td><td>会产生很多的，难以利用的碎片;算法开销大,回收分区后可能需要对空闲分区队列重新排序</td></tr><tr><td>最坏适应</td><td>优先使用更大的分区，以防止产生太小的不可用的碎片</td><td>空闲分区以容量递减次序排列</td><td>可以减少难以利用的小碎片</td><td>大分区容易被用完，不利于大进程:算法开销大(原因同上)</td></tr><tr><td>临近适应</td><td>由首次适应演变而来，每次从上次查找结束位置开始查找</td><td>空闲分区以地址递增次序排列（可排列成循环链表）</td><td>不用灭磁都从低地址的小分区开始检索，算法开销小</td><td>会使高地址的大分区也被用完</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;连续分配管理方式&quot;&gt;&lt;a href=&quot;#连续分配管理方式&quot; class=&quot;headerlink&quot; title=&quot;连续分配管理方式&quot;&gt;&lt;/a&gt;连续分配管理方式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;连续分配：指系统为用户进程分配的必须是一个连续的内存空间&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="操作系统" scheme="http://ywrby.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>22-内存空间扩充（覆盖与交换）</title>
    <link href="http://ywrby.com/2021/12/25/22-%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E6%89%A9%E5%85%85%EF%BC%88%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2%EF%BC%89/"/>
    <id>http://ywrby.com/2021/12/25/22-%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E6%89%A9%E5%85%85%EF%BC%88%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2%EF%BC%89/</id>
    <published>2021-12-25T08:15:49.000Z</published>
    <updated>2021-12-25T08:57:12.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h1><p>早期计算机内存很小，因此经常出现内存大小不够使用的情况，因此人们引入了覆盖技术，用来解决“程序大小超过物理内存总和”的问题</p><p>覆盖技术的思想在于，将程序分为多个段（多个执行模块），常用的模块常驻在内存中，不常用的模块在需要时调入，使用后调出。实现这种功能还需要将内存划分为固定区和若干个覆盖区</p><p>需要常驻在内存的模块进入固定区后就不再调出，直到整个程序运行结束，不常用的模块在需要时调入覆盖区，用不到时调出</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211225163447.png"></p><p>以上图为例，A模块作为需要常驻的模块，在程序开始运行后就进入常驻区，直到程序运行结束。B，C模块只能由A调用，并且不可能同时调用，所以B，C共用一个覆盖区，覆盖区大小由最大模块决定，而D模块只能由B模块调用，E，F模块只能由C模块调用，显而易见，DEF三个模块同一时间只可能有一个运行，所以DEF可以共用一个覆盖区，同时由最大的程序D决定覆盖区大小</p><p>这种覆盖技术的缺点在于：必须由程序员声明覆盖结构，操作系统完成自动覆盖。对用户不透明，增加了用户编程负担。覆盖技术只用于早期的操作系统中，现在已成为历史。</p><h1 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h1><p>交换（对换）技术的设计思想:内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）</p><p>之前所讲过的中级调度（内存调度），就是要决定哪个处于挂起状态的进程重新调入内存</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211225164351.png"></p><p>可以看到，在将进程存入外存的过程中，内存保留了这些进程的PCB，并将他们添加到挂起队列中，这是因为PCB中保存了这些进程的运行情况以及在外存中的位置信息，必须保留它们才能重新将这些挂起进程调回内存中</p><blockquote><p>回忆部分： 暂时换出外存等待的进程状态称为挂起状态（挂起态，suspend）挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态</p></blockquote><p><a href="https://ywrby.cn/2021/11/01/8-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%EF%BC%8C%E6%8E%A7%E5%88%B6%E4%B8%8E%E9%80%9A%E4%BF%A1/">进程的状态，控制与通信</a></p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211225165109.png" alt="七状态模型"></p><h2 id="交换技术需要考虑的问题"><a href="#交换技术需要考虑的问题" class="headerlink" title="交换技术需要考虑的问题"></a>交换技术需要考虑的问题</h2><ol><li>应该在外存（磁盘）的什么位置保存被换出的进程?<ul><li>具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式。对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式。总之，对换区的I/O速度比文件区的更快。</li></ul></li><li>什么时候应该交换?<ul><li>交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如:在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程;如果缺页率明显下降，就可以暂停换出。</li></ul></li><li>应该换出哪些进程?<ul><li>可优先换出阻塞进程;可换出优先级低的进程;为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间…</li></ul></li></ol><p>需要注意的一点就是整个过程中，进程的PCB始终还是存放在内存队列中的，不会被换出到外存中</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;覆盖技术&quot;&gt;&lt;a href=&quot;#覆盖技术&quot; class=&quot;headerlink&quot; title=&quot;覆盖技术&quot;&gt;&lt;/a&gt;覆盖技术&lt;/h1&gt;&lt;p&gt;早期计算机内存很小，因此经常出现内存大小不够使用的情况，因此人们引入了覆盖技术，用来解决“程序大小超过物理内存总和”的问题&lt;</summary>
      
    
    
    
    
    <category term="操作系统" scheme="http://ywrby.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>21-内存与内存管理</title>
    <link href="http://ywrby.com/2021/12/19/21-%E5%86%85%E5%AD%98%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://ywrby.com/2021/12/19/21-%E5%86%85%E5%AD%98%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2021-12-19T09:57:53.000Z</published>
    <updated>2021-12-21T13:07:26.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存基础知识"><a href="#内存基础知识" class="headerlink" title="内存基础知识"></a>内存基础知识</h1><blockquote><p>内存(Memory)是计算机的重要部件之一，也称内存储器和主存储器，它用于暂时存放CPU中的运算数据，与硬盘等外部存储器交换的数据。它是外存与CPU进行沟通的桥梁。只要计算机开始运行，操作系统就会把需要运算的数据从内存调到CPU中进行运算，当运算完成，CPU将结果传送出来。</p></blockquote><p>在多道程序环境下，同一时间可能会有多个程序并发执行，即有多个程序的数据需要同时存放在内存中，此时，为了区分内存中不同数据存放的位置，就需要引入存储单元的概念</p><blockquote><p>存储单元：一般应具有存储数据和读写数据的功能，以8位二进制作为一个存储单元，也就是一个字节。每个单元有一个地址，是一个整数编码，可以表示为二进制整数。程序中的变量和主存储器的存储单元相对应。变量的名字对应着存储单元的地址，变量内容对应着单元所存储的数据。存储地址一般用十六进制数表示，而每一个存储器地址中又存放着一组二进制（或十六进制）表示的数，通常称为该地址的内容。</p><ol><li>如果计算机“按字节编址”则每个存储单元大小为1字节即1B，即8个二进制位</li><li>如果字长为16位的计算机“按字编址”，则每个存储单元大小为1字，每个字大小为16个二进制位</li></ol></blockquote><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/dhauidhwuiahuidwhaui.png"></p><p>内存在进程运行过程中的操作</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211220184336.png"></p><p>可见，我们写的代码要翻译成CPU能识别的指令。这些指令会告诉CPU应该去内存的哪个地址存/取数据，这个数据应该做什么样的处理。在这个例子中，指令中直接给出了变量x的实际存放地址（物理地址）。但实际在生成机器指令的时候并不知道该进程的数据会被放到什么位置。所以编译生成的指令中一般是使用逻辑地址（相对地址)</p><p>逻辑地址与相对地址的区别</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211220184704.png"></p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211220184911.png"></p><p>链接的三种方式</p><ol><li>静态链接:在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块)，之后不再拆开。</li><li>装入时动态链接:将各目标模块装入内存时，边装入边链接的链接方式。</li><li>运行时动态链接:在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。</li></ol><p>装入的三种方式：<br><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211220185617.png"></p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211220190022.png"></p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211220190215.png"></p><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>操作系统作为系统资源的管理者，当然也需要对内存进行管理，这些管理涉及到：</p><ol><li>操作系统负责<strong>内存控件的分配与回收</strong></li><li>操作系统需要提供某种技术从逻辑上<strong>对内存控件进行扩充</strong></li><li>操作系统需要提供<strong>地址转换功能</strong>，负责程序的逻辑地址与物理地址的转换（通过上文所说的三种装入方法）</li><li>操作系统需要提供<strong>内存保护</strong>功能，保证各个进程在各自的存储空间内运行，互不干扰</li></ol><h2 id="内存保护的概念与实现方法"><a href="#内存保护的概念与实现方法" class="headerlink" title="内存保护的概念与实现方法"></a>内存保护的概念与实现方法</h2><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211221210302.png"></p><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>在CPU中设置一堆上下限寄存器，存放进程的上下限地址。进程的指令要访问某个地址时，CPU检查是否越界</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211221210449.png"></p><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>采用重定位寄存器（又称基址寄存器）和界地址寄存器(又称限长寄存器)进行越界检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211221210621.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;内存基础知识&quot;&gt;&lt;a href=&quot;#内存基础知识&quot; class=&quot;headerlink&quot; title=&quot;内存基础知识&quot;&gt;&lt;/a&gt;内存基础知识&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;内存(Memory)是计算机的重要部件之一，也称内存储器和主存储器，它用于暂时存放</summary>
      
    
    
    
    
    <category term="操作系统" scheme="http://ywrby.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>20-死锁</title>
    <link href="http://ywrby.com/2021/12/11/20-%E6%AD%BB%E9%94%81/"/>
    <id>http://ywrby.com/2021/12/11/20-%E6%AD%BB%E9%94%81/</id>
    <published>2021-12-11T06:20:20.000Z</published>
    <updated>2021-12-19T09:57:03.669Z</updated>
    
    <content type="html"><![CDATA[<h1 id="死锁的基本概念"><a href="#死锁的基本概念" class="headerlink" title="死锁的基本概念"></a>死锁的基本概念</h1><p>在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里资源，导致各个进程都阻塞，无法向前推进的现象，称为“死锁”。发生死锁后若无外力的干涉，这些进程都将无法向前推进</p><p>要注意的是，死锁，饥饿和死循环是三个比较容易混淆的概念</p><ul><li>饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。例如：在短进程优先算法（SPF）中，若有源源不断的短进程到来，则长进程一直得不到处理机，从而发生长进程“饥饿”</li><li>死循环：某进程执行过程中一直跳不出某个循环的现象，有时是因为程序逻辑bug导致，有时也可能是程序故意设计</li></ul><p>综上，可以总结三者的异同点：</p><table><thead><tr><th>-</th><th>共同点</th><th>区别</th></tr></thead><tbody><tr><td>死锁</td><td>都是进程无法顺利向前推进的现象</td><td>死锁一定是“循环等待对方手里的资源”导致的，因此如果有死锁现象，那至少有两个或以上的进程同时发生死锁。同时，由于是始终处于等待对方资源的状态，所以发生死锁的进程一定处于阻塞态</td></tr><tr><td>饥饿</td><td>-</td><td>可能只有一个进程发生饥饿（例如上文所提到的长进程饥饿）。发生饥饿的进程既可能是阻塞态（例如长期得不到I/O设备），也可能是就绪态（长期得不到处理机）</td></tr><tr><td>死循环</td><td>-</td><td>可能只有一个进程发生死循环。死循环的进程可以上处理机运行，即发生死循环的进程可能处于运行态。只不过无法像期待的那样顺利推进。死锁和饥饿的问题是由于操作系统分配资源的策略不合理所导致，而死循环是由于代码逻辑错误所导致。因此死锁和饥饿是操作系统的问题，死循环是程序员的问题</td></tr></tbody></table><h2 id="死锁的必要条件"><a href="#死锁的必要条件" class="headerlink" title="死锁的必要条件"></a>死锁的必要条件</h2><p>产生死锁必须同时满足以下的四个条件，任意条件不成立，死锁都不会发生</p><ul><li>互斥条件：只有对必须互斥使用的资源进行争抢才会导致死锁。例如哲学家就餐问题，打印机设备等。像内存，扬声器这种可以同时被多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这种资源）</li><li>不剥夺条件：进程获得的资源，在未使用完之前，不能被其他进程强行夺走，只能主动释放</li><li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放</li><li>循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求</li></ul><p>发生死锁一定又循环等待，但发生循环等待不一定有死锁</p><h2 id="发生死锁的时机"><a href="#发生死锁的时机" class="headerlink" title="发生死锁的时机"></a>发生死锁的时机</h2><ul><li>对系统资源的竞争：各个进程对不可剥夺资源的竞争（例如打印机）可能引起死锁，对可剥夺资源（CPU）的竞争不会引起死锁</li><li>进程推进顺序非法：请求和释放资源的顺序不当，同样会导致死锁。例如：并发执行的进程P1，P2分别申请并占有了资源R1，R2，之后进程P1又紧接着申请资源R2，P2申请资源R1，就会导致死锁</li><li>信号量的使用不当：例如在生产者与消费者问题中，如果实现互斥操作的P操作在实现同步操作的P操作之前，就可能导致死锁（这里可以把互斥信号量和同步信号量也堪称一种抽象的系统资源）</li></ul><p>总之，对不可剥夺资源的不合理分配，可能导致死锁</p><h2 id="死锁的处理策略–不允许死锁发生"><a href="#死锁的处理策略–不允许死锁发生" class="headerlink" title="死锁的处理策略–不允许死锁发生"></a>死锁的处理策略–不允许死锁发生</h2><ol><li>预防死锁：破坏死锁产生必要条件中的一个或几个</li><li>避免死锁：用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）</li></ol><h2 id="死锁的处理策略–允许死锁发生"><a href="#死锁的处理策略–允许死锁发生" class="headerlink" title="死锁的处理策略–允许死锁发生"></a>死锁的处理策略–允许死锁发生</h2><ol><li>死锁的检测和解除：允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁</li></ol><h1 id="静态策略：预防死锁"><a href="#静态策略：预防死锁" class="headerlink" title="静态策略：预防死锁"></a>静态策略：预防死锁</h1><p>破坏死锁产生必要条件中的一个或几个</p><h2 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h2><ul><li>互斥条件：只有对必须互斥使用的资源进行争抢才会导致死锁。</li></ul><p>如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。例如SPOOLing技术，操作系统可以使用SPOOLing技术把独占设备在逻辑上改造成共享设备，比如用SPOOLing技术将打印机改造为共享设备</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211211153530.png"></p><p>该策略的缺点：并不是所有资源都可以改造成可共享使用的资源。并且处于系统安全角度考虑，很多地方必须保护这种互斥性，所以破坏互斥条件的应用范围不广</p><h2 id="破坏不可剥夺条件"><a href="#破坏不可剥夺条件" class="headerlink" title="破坏不可剥夺条件"></a>破坏不可剥夺条件</h2><ul><li>不剥夺条件：进程获得的资源，在未使用完之前，不能被其他进程强行夺走，只能主动释放</li></ul><ol><li>方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时重新申请，也就是说，即使资源尚未使用完，也需要主动释放，从而破坏不可剥夺条件</li><li>方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑进程之间的优先级（优先级高的进程可以剥夺低优先级进程的资源）</li></ol><p>该策略的缺点：</p><ul><li>实现起来比较复杂</li><li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方式一般只适用于易保存和恢复状态的资源，例如CPU</li><li>反复申请和释放资源会增加系统开销，降低系统吞吐量</li><li>若采用方案一，意味着只要暂时得不到资源，之前的资源需要全部放弃，后面重新申请，如果该现象一直发生，会导致饥饿</li></ul><h2 id="破坏请求和保持条件"><a href="#破坏请求和保持条件" class="headerlink" title="破坏请求和保持条件"></a>破坏请求和保持条件</h2><ul><li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放</li></ul><p>可以采用静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行，一旦投入运行，这些资源就一直归他所有，该进程不会请求别的任何资源</p><p>该策略缺点：有些资源可能只需要使用很短的时间，因此如果进程的整个运行期间都保持所有资源，就会造成部分资源的严重浪费，资源利用率低。另外策略也可能导致某些进程饥饿</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211211155245.png"></p><p>例如上图中A类进程与B类进程分别需要使用资源1和资源2就可以运行，而C类进程需要同时等待两种资源全部空闲才可执行，此时若A类B类进程交替不断到来，则C类进程会由于没有全部资源陷入饥饿</p><h2 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h2><ul><li>循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求</li></ul><p>可采用顺序资源分配法。首先给系统中的资源编号，并且规定每个进程必须按照编号递增的顺序请求资源，同类资源（编号相同的资源）一次申请完</p><p>原理分析：一个进程已占有小编号资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程无法逆向申请小编号的资源，从而打破循环等待</p><p>该策略的缺点</p><ol><li>不方便新增设备，因为可能需要重新分配所有的编号</li><li>进程时机使用资源的顺序和编号递增顺序不一致，会导致资源浪费。例如某进程需要申请5号打印机资源和7号扫描仪资源，使用顺序是先使用扫描仪后使用打印机，但由于5号打印机编号较小，所以必须提前申请该资源并一直占用，知道申请并使用完7号扫描仪后，才能使用并释放，导致5号打印机被浪费</li><li>必须按规定次序申请资源，用户编程麻烦</li></ol><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211211160546.png"></p><h1 id="动态策略：避免死锁"><a href="#动态策略：避免死锁" class="headerlink" title="动态策略：避免死锁"></a>动态策略：避免死锁</h1><h2 id="基本概念-安全序列"><a href="#基本概念-安全序列" class="headerlink" title="基本概念-安全序列"></a>基本概念-安全序列</h2><blockquote><p>银行家算法:在银行中，客户申请贷款的数量是有限的，每个客户在第一次申请贷款时要声明完成该项目所需的最大资金量，在满足所有贷款要求时，客户应及时归还。银行家在客户申请的贷款数量不超过自己拥有的最大值时，都应尽量满足客户的需要。在这样的描述中，银行家就好比操作系统，资金就是资源，客户就相当于要申请资源的进程。</p></blockquote><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211215174819.png"></p><p>不合理请求<br><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211215175214.png"></p><p>合理请求<br><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211215174453.png"></p><p>根据上面的两个示例我们可以看到，在给B借30亿的情况下，如果B，A，T同时提出20亿借贷的请求，则我们所有企业都无法满足，此时系统陷入死锁状态，而与之相对的，在给A借20亿的情况下，我们有T-&gt;B-&gt;A这样的能够保证系统安全的系列存在</p><p>上面给出的T-&gt;B-&gt;A序列，就是一个安全序列，所谓安全序列，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个。</p><p>如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态，不过我们在分配资源之前总是要考虑到最坏的情况。</p><p>如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁（处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态）</p><p>因此可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。这也是“银行家算法”的核心思想。</p><h2 id="银行家算法核心思想"><a href="#银行家算法核心思想" class="headerlink" title="银行家算法核心思想"></a>银行家算法核心思想</h2><p>在进程提出资源申请时，预先判断此次分配是否会导致系统进入不安全状态(不存在安全序列)，如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待</p><p>但是上面的例子中，只涉及一种资源的分配（钱），而在计算机这种可能涉及多种资源分配的环境下，就需要通过高维向量来解决上述问题：例如系统中有五个进程P0-P4，三种资源R0-R2，初始数量为(10,5,7)则某一时刻的情况可以表示如下</p><table><thead><tr><th>进程</th><th>最大需求</th><th>已分配</th><th>最多还需要</th></tr></thead><tbody><tr><td>P0</td><td>(7,5,3)</td><td>(0,1,1)</td><td>(7,4,3)</td></tr><tr><td>P1</td><td>(3,2,2)</td><td>(2,0,0)</td><td>(1,2,2)</td></tr><tr><td>P2</td><td>(9,0,2)</td><td>(3,0,2)</td><td>(6,0,0)</td></tr><tr><td>P3</td><td>(2,2,2)</td><td>(2,1,1)</td><td>(0,1,1)</td></tr><tr><td>P4</td><td>(4,3,3)</td><td>(0,0,2)</td><td>(4,3,3)</td></tr></tbody></table><p>此时系统剩余可用资源(3,3,2)要判断系统是否处于安全状态，思路就是尝试找到一条安全序列，而方法就是自上而下依次检查剩余可用资源(3,3,2)是否能满足各进程需求</p><p>检查过程：</p><ol><li>首先P0最多需要资源(7,4,3)&gt;剩余资源(3,3,2)，所以P0暂时无法进入安全序列</li><li>接下来P1(1,2,2)&lt;(3,3,2)所以P1可以进入安全序列</li><li>P1进入安全序列分配资源并等待P1归还所有已分配资源</li><li>P1归还所有已分配资源，所以系统剩余资源(2,0,0)+(3,3,2)=(5,3,2)</li><li>继续向下执行P2(6,0,0)&gt;(5,3,2)，所以P2暂时不能进入安全序列</li><li>P3(0,1,1)&lt;(5,3,2)所以P3进入安全序列，分配资源，并等待P3归还所有已分配资源</li><li>P3归还资源，系统剩余资源(2,1,1)+(5,3,2)=(7,4,3)</li><li>继续向下执行P4(4,3,1)&lt;(7,4,3)，P4进入安全序列，分配资源，并归还</li><li>P4归还资源，系统剩余资源(0,0,2)+(7,4,3)=(7,4,5)</li><li>不断执行，此时所有进程都可进入安全序列</li><li>最终得到安全序列P1-&gt;P3-&gt;P4-&gt;P0-&gt;P2(安全序列不唯一)</li></ol><p>成功找到一条安全序列表明系统处于安全状态，不可能发生死锁</p><h2 id="银行家算法实现思路"><a href="#银行家算法实现思路" class="headerlink" title="银行家算法实现思路"></a>银行家算法实现思路</h2><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211215182345.png"></p><h1 id="死锁的检测和解除"><a href="#死锁的检测和解除" class="headerlink" title="死锁的检测和解除"></a>死锁的检测和解除</h1><h2 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h2><p>为了能对系统是否已经发生了死锁进行检测，我们需要：</p><ol><li>用某种数据结构来保存资源的请求和分配信息</li><li>提供一种算法，利用上述信息来检测系统是否已经进入死锁状态</li></ol><p>能够用来保存资源的请求与分配信息的结构就是资源分配图，资源分配图具有如下特点：</p><ul><li>具有两种节点<ul><li>进程节点：对应一个进程</li><li>资源节点：对应一类资源，一类资源可能有多个</li></ul></li><li>具有两种边<ul><li>请求边：从进程节点指向资源节点，表示进程想申请几个资源（一条边表示想要申请一个）</li><li>分配边：从资源节点指向进程节点，表示已经为该进程分配了几个资源（一条边表示已分配一个资源）</li></ul></li></ul><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211219172358.png"></p><p>介绍了一种保存资源和请求分配信息的数据结构后，我们就应该考虑如何利用算法，检测整个过程中系统是否发生死锁。</p><p>以上面这张资源分配图为例，P1进程请求一个R2资源，此时R2资源一共两个，其中一个被分配给P2进程，所以剩余资源足够分配给P1进程，此时P1进程不需要额外资源，可以正常执行。待执行结束后归还一个R2资源和两个R1资源，此时P2请求一个额外的R1资源，R1资源一共三个，其中一个已经分配给P2进程，剩余两个空闲，所以能够分配一个额外的R1资源给P2，P2进程也可顺利执行，则该情况下未发生死锁</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211219173206.png"></p><p>相对的，如果资源分配图变成这种情况，则P1进程请求两个R2资源，但空闲R2资源为0，P1被阻塞，P2进程请求一个R1资源，空闲R1资源为0，P2被阻塞，P3进程不请求额外资源，只有P3进程可以正常执行，执行后归还一个R2资源，但此时P1进程仍无法执行，P2进程也无法请求到额外资源，系统进入死锁状态</p><p>所以说，如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利地执行下去。如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。相应的，这些被激活的进程执行完了之后又会归还一些资源,这样可能又会激活另外一些阻塞的进程…</p><p>如果按照上述的过程分析最终能够消除所有边，则称该图是“可完全简化的”，此时一定没有死锁，如果最终不能消除所有边，则此时就发生了死锁，最终还连这边的进程就是处于死锁状态的进程</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211219173937.png"></p><p>综上，检测死锁的算法就可以描述为：</p><ol><li>在资源分配图中，找出既不阻塞又不是孤点的进程Pi(即找出一条存在有向边与它相连，且该有向边对应资源的申请数量小于等于系统中己有空闲资源数量。如下图中，R1没有空闲资源，R2有一个空闲资源。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源）。消去它所有的请求边和分配边，使之称为孤立的结点。在下图中，P1是满足这一条件的进程结点,于是将P1的所有边消去。</li><li>进程Pi所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。在下图中，P2就满足这样的条件。根据1)中的方法进行一系列简化后，若能消去途中所有的边，则称该图是可完全简化的。<br><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211219172358.png"></li></ol><h2 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h2><p>一旦检测出死锁的发生，就应该立即解除死锁。</p><p>注意:并不是系统中所有的进程都是死锁状态，用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程</p><p>解除死锁的主要方法有:</p><ol><li>资源剥夺法。挂起（暂时放到外存上)某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li><li>撤销进程法（或称终止进程法)。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，己经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。</li><li>进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息,设置还原点。</li></ol><h3 id="如何绝对挂起或剥夺哪些进程"><a href="#如何绝对挂起或剥夺哪些进程" class="headerlink" title="如何绝对挂起或剥夺哪些进程"></a>如何绝对挂起或剥夺哪些进程</h3><ol><li>考虑进程的优先级，对优先级低的进程进行剥夺</li><li>考虑已执行的时间，避免剥夺已经长时间运行的进程，造成损失</li><li>考虑进程完成时间，优先为可快速完成的进程分配资源</li><li>考虑进程已经使用了多少资源</li><li>考虑进程是交互式的还是批处理式的，避免交互式进程被剥夺影响用户体验</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;死锁的基本概念&quot;&gt;&lt;a href=&quot;#死锁的基本概念&quot; class=&quot;headerlink&quot; title=&quot;死锁的基本概念&quot;&gt;&lt;/a&gt;死锁的基本概念&lt;/h1&gt;&lt;p&gt;在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里资源，导致各个进程都阻塞，无法向前推进的现</summary>
      
    
    
    
    
    <category term="操作系统" scheme="http://ywrby.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>19-管程</title>
    <link href="http://ywrby.com/2021/11/28/19-%E7%AE%A1%E7%A8%8B/"/>
    <id>http://ywrby.com/2021/11/28/19-%E7%AE%A1%E7%A8%8B/</id>
    <published>2021-11-28T08:39:08.000Z</published>
    <updated>2021-11-28T09:03:25.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h1><h2 id="信号量机制存在的问题"><a href="#信号量机制存在的问题" class="headerlink" title="信号量机制存在的问题"></a>信号量机制存在的问题</h2><p>编写程序困难，容易出错。因此人们考虑使用另外设计的机制，保证程序员在编写程序过程中不需要关注复杂的PV操作。</p><h2 id="管程的定义和组成"><a href="#管程的定义和组成" class="headerlink" title="管程的定义和组成"></a>管程的定义和组成</h2><p>管程是一种特殊的软件模块，其组成部分为：</p><ol><li>局部与管程的共享数据结构（类似于局部变量的概念，该数据结构只能被管程所访问）</li><li>对该数据结构进行操作的一组过程（类似于局部方法）</li><li>对局部于管程的共享数据设置初始值的语句（初始化方法）</li><li>管程的名字</li></ol><h2 id="管程的基本特征"><a href="#管程的基本特征" class="headerlink" title="管程的基本特征"></a>管程的基本特征</h2><ol><li>局部与管程的数据只能被局部与管程的过程（方法）所访问</li><li>一个进程只有通过调用管程内的方法，才能进入管程并访问共享数据</li><li>每次仅允许一个进程在管程内执行某个内部过程（方法）</li></ol><h2 id="管程示例"><a href="#管程示例" class="headerlink" title="管程示例"></a>管程示例</h2><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211128165547.png"></p><p>这个过程中由编译器负责实现各个进程互斥的进入管程中的方法</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>引入管程的目的无非是为了更方便的实现进程的互斥与同步</li><li>需要在管程中定义共享数据（例如生产者消费者问题中的缓冲区）</li><li>需要在管程中定义用于访问共享数据的“入口”，即函数</li><li>只有通过管程中定义的方法才能进入管程，才能访问共享数据</li><li>管程存在很多方法，但每次只能开放其中一个方法作为“入口”，并且只允许一个进程或线程进入（这种互斥的特性是由编译器实现的，程序员不需要关心）</li><li>可在管程中设置条件变量以及等待/唤醒操作来解决进程同步问题</li><li>管程体现了一种封装思想，将复杂的PV操作进行封装方便程序设计人员使用</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;管程&quot;&gt;&lt;a href=&quot;#管程&quot; class=&quot;headerlink&quot; title=&quot;管程&quot;&gt;&lt;/a&gt;管程&lt;/h1&gt;&lt;h2 id=&quot;信号量机制存在的问题&quot;&gt;&lt;a href=&quot;#信号量机制存在的问题&quot; class=&quot;headerlink&quot; title=&quot;信号量机制</summary>
      
    
    
    
    
    <category term="操作系统" scheme="http://ywrby.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>18-信号量相关问题（吸烟者，读者-写者等）</title>
    <link href="http://ywrby.com/2021/11/17/18-%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%EF%BC%88%E5%90%B8%E7%83%9F%E8%80%85%EF%BC%8C%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E7%AD%89%EF%BC%89/"/>
    <id>http://ywrby.com/2021/11/17/18-%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%EF%BC%88%E5%90%B8%E7%83%9F%E8%80%85%EF%BC%8C%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E7%AD%89%EF%BC%89/</id>
    <published>2021-11-17T12:08:38.000Z</published>
    <updated>2021-11-17T13:18:09.143Z</updated>
    
    <content type="html"><![CDATA[<h1 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h1><p>假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料:烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复(让三个抽烟者轮流地抽烟)</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211117201635.png"></p><p>以上图为例，供应者向桌上摆放烟草和纸两种材料，缺少这两种材料的三号吸烟者就会取走材料吸烟，在吸烟结束后会提醒供应者放新的材料在桌上</p><p>根据题目我们直到，放在桌上的材料一共有三种组合方式</p><ol><li>纸和胶水（order1）会被一号吸烟者取走</li><li>烟草和胶水（order2）会被二号吸烟者取走</li><li>烟草和纸（order3）会被三号吸烟者取走</li></ol><p>本题可以看作是存在一个生产者和多个消费者的问题，同时生产者所生产的物品并不相同</p><h2 id="关系分析"><a href="#关系分析" class="headerlink" title="关系分析"></a>关系分析</h2><p>找出题目中描述的各个进程，分析同步互斥关系</p><ul><li>互斥关系：桌子可以抽象为容量为1的缓冲区，需要互斥访问</li><li>同步关系：桌上有组合一时第一个抽烟者取走物品</li><li>同步关系：桌上有组合二时第二个抽烟者取走物品</li><li>同步关系：桌上有组合三时第三个抽烟者取走物品</li><li>同步关系：抽烟者完成吸烟后发出完成信号，供应者将下一组组合放在桌上</li></ul><h2 id="整理思路"><a href="#整理思路" class="headerlink" title="整理思路"></a>整理思路</h2><p>根据各个进程的操作流程确定PV操作的大致顺序</p><p>对于互斥关系的处理只要遵循在访问临界资源前对临界资源上锁，访问之后解锁即可</p><p>对于同步关系的处理要遵循“前V后P”原则，必须先执行的操作后执行V操作，必须后执行的操作执行前执行P操作</p><h2 id="设置信号量"><a href="#设置信号量" class="headerlink" title="设置信号量"></a>设置信号量</h2><p>由于本题目中缓冲区大小为1，同一时间只可能至多有一个进程访问互斥资源，所以不需要设置互斥信号量mutex</p><p>同步信号量的设置要看对应资源初始值进行赋值</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211117205952.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">semaphore offer1=<span class="number">0</span>; <span class="comment">//桌上组合一的数量</span></span><br><span class="line">semaphore offer2=<span class="number">0</span>; <span class="comment">//桌上组合二的数量</span></span><br><span class="line">semaphore offer3=<span class="number">0</span>; <span class="comment">//桌上组合三的数量</span></span><br><span class="line">semaphore finish=<span class="number">0</span>; <span class="comment">//抽烟是否完成</span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>; <span class="comment">//用于实现三个吸烟者轮流吸烟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//供应者进程</span></span><br><span class="line">provider()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">            将组合一放桌上</span><br><span class="line">            V(offer1); <span class="comment">//题型一号吸烟者吸烟</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">            将组合二放桌上</span><br><span class="line">            V(offer2); <span class="comment">//题型二号吸烟者吸烟</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            将组合三放桌上</span><br><span class="line">            V(offer3); <span class="comment">//题型三号吸烟者吸烟</span></span><br><span class="line">        &#125;</span><br><span class="line">        i=(i+<span class="number">1</span>)%<span class="number">3</span>; <span class="comment">//实现让三个吸烟者轮流吸烟</span></span><br><span class="line">        P(finish); <span class="comment">//等待吸烟者吸烟完成后继续放组合</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一号吸烟者进程</span></span><br><span class="line">smoker1()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(offer1); <span class="comment">//等待组合一放到桌上</span></span><br><span class="line">        从桌上拿走组合一，吸烟</span><br><span class="line">        V(finish); <span class="comment">//题型供应者提供新组合</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二号吸烟者进程</span></span><br><span class="line">smoker2()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(offer2); <span class="comment">//等待组合二放到桌上</span></span><br><span class="line">        从桌上拿走组合二，吸烟</span><br><span class="line">        V(finish); <span class="comment">//题型供应者提供新组合</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//三号吸烟者进程</span></span><br><span class="line">smoker3()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(offer3); <span class="comment">//等待组合三放到桌上</span></span><br><span class="line">        从桌上拿走组合三，吸烟</span><br><span class="line">        V(finish); <span class="comment">//题型供应者提供新组合</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;吸烟者问题&quot;&gt;&lt;a href=&quot;#吸烟者问题&quot; class=&quot;headerlink&quot; title=&quot;吸烟者问题&quot;&gt;&lt;/a&gt;吸烟者问题&lt;/h1&gt;&lt;p&gt;假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种</summary>
      
    
    
    
    
    <category term="操作系统" scheme="http://ywrby.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>区块链网络中矿池选择的演化博弈</title>
    <link href="http://ywrby.com/2021/11/14/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9F%BF%E6%B1%A0%E9%80%89%E6%8B%A9%E7%9A%84%E6%BC%94%E5%8C%96%E5%8D%9A%E5%BC%88/"/>
    <id>http://ywrby.com/2021/11/14/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9F%BF%E6%B1%A0%E9%80%89%E6%8B%A9%E7%9A%84%E6%BC%94%E5%8C%96%E5%8D%9A%E5%BC%88/</id>
    <published>2021-11-14T12:53:03.000Z</published>
    <updated>2021-12-08T07:43:29.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="区块链网络中矿池选择的演化博弈"><a href="#区块链网络中矿池选择的演化博弈" class="headerlink" title="区块链网络中矿池选择的演化博弈"></a>区块链网络中矿池选择的演化博弈</h1><p><a href="https://ieeexplore.ieee.org/abstract/document/8326513">论文原文链接: Evolutionary Game for Mining Pool Selection in Blockchain Networks</a></p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>在基于工作量证明（POW）的区块链网络中，区块矿工参与解决加密难题的竞赛，以赢得发布（即挖掘）新区块的奖励。由于加密难题的显著难度，个体矿工倾向于加入矿池以确保稳定的利润。我们研究了区块链网络中矿池选择的动态，其中矿池可以选择任意块挖掘策略（<a href="#%E6%8C%96%E6%8E%98%E7%AD%96%E7%95%A5">补充</a>）。我们将解谜的哈希率和区块传播延迟确定为决定挖矿竞争结果的两个主要因素。然后我们将个体矿工的策略演化建模为演化博弈。我们提供了两个池情况下池选择动力学中演化稳定性的理论分析。数值模拟支持我们的理论发现，并证明了一般情况下矿工策略演变的稳定性</p><h2 id="Section1-Introduction"><a href="#Section1-Introduction" class="headerlink" title="Section1-Introduction"></a>Section1-Introduction</h2><p>公共区块链网络构建为覆盖点对点 (P2P) 网络，用于去中心化防篡改数据记录。中本聪共识协议 用于在利益角度上激励全节点（区块矿工）遵守区块链状态维护的“最长链规则”。遵循该协议，区块矿工将一组任意经过验证的交易打包成一个数据结构，称为候选“区块”，并将其广播到整个网络。区块链状态被维护为由散列指针以松散同步的方式链接的块的线性列表。即，矿工始终将观察到的最长链作为其本地区块链副本。</p><p>中本聪协议的激励机制由两部分组成：</p><ol><li>一个计算密集型的加密难题解决过程</li><li>一个奖励确认过程，用于在矿工发布的区块被网络认可时向矿工提供奖励</li></ol><p>密码谜题解决过程是通过工作量证明 (PoW) 竞赛实现的，其中矿工详尽地查询可信随机预言机，例如 SHA-256 哈希函数，以找到满足原像的随机字符串条件基于他们自己的区块提议。在奖励过程中，首先在网络上传播其候选区块的矿工因其在验证新交易方面的努力而获得数字代币奖励。与移动网络中流行的激励机制相比，中本聪协议的特点是在其区块确认功能中嵌入了去中心化的代币发行方案。在每个区块固定奖励的情况下，节点加入共识过程的意愿主要受能源消耗预期成本的影响。</p><p>赢得 PoW 竞赛的概率取决于矿工的哈希率（即矿工每秒对哈希函数的查询次数）与整个网络的总哈希率之间的比率。同时，P2P网络中的区块传播时间决定了一个共识回合内区块确认的最终结果，因为只有传播到大多数节点的第一个区块才会被接受为区块链的新头。实际上，由于网络中压倒性的哈希率，单个矿工赢得 PoW 竞赛的机会可以忽略不计。因此，现实世界的区块链网络由代表矿工联盟的代理节点主导，这些节点被称为矿池。矿池作为任务调度器，将原像搜索任务划分为更小的子任务，并根据矿工的投入/报告哈希率将它们分配给矿池中的矿工。通过聚合许多矿工的哈希率，矿池赢得区块奖励的概率变得非常大。然后，单个矿工可以根据其在池中的哈希率份额来确保其少量但稳定的奖励份额。</p><p>在这篇论文中，我们研究了基于 PoW 的区块链网络中的矿池选择问题。我们认为个体矿工是有限理性的，矿池采用任意的挖掘策略。我们将网络中的池选择动态建模为演化博弈模型。我们关注哈希率和传播延迟对策略演化的影响，并研究了两个矿池情况下矿池选择动态的演化稳定性。</p><h2 id="Section2-Problem-Formulation"><a href="#Section2-Problem-Formulation" class="headerlink" title="Section2-Problem Formulation"></a>Section2-Problem Formulation</h2><h3 id="涉及参数"><a href="#涉及参数" class="headerlink" title="涉及参数"></a>涉及参数</h3><ul><li>$$N: 区块链网络中独立矿工数量$$</li><li>$$M: 区块链网络中独立矿工形成的矿池数量$$</li><li>$$\mathcal {M}：所有矿池的集合$$</li><li>$$\omega _{i}: 矿池i要求每个独立矿工提供的哈希率$$</li><li>$$\pmb {\omega }: 所有矿池要求每个独立矿工提供的哈希率集合$$</li><li>$$x_{i}: 矿池i中矿工人数占总人数比例$$</li><li>$$\mathbf {x}: 各个矿池中矿工人数占总人数比例的集合$$</li><li>$${\Pr }^{\textrm {mine}}_{i}(\mathbf {x},\pmb {\omega }): 矿池i赢得挖矿竞赛的概率$$</li><li>$$s: 区块大小$$</li><li>$$\gamma: 网络规模相关参数$$</li><li>$$c: 每个链路平均有效信道容量$$</li><li>$$\tau _{p}(s): 大小为s的块的传输延迟时间$$</li><li>$$\beta: 由网络规模和每个节点的平均验证速度共同决定的参数$$</li><li>$$\tau _{v}(s): 验证大小为s的块所需的时间$$</li><li>$${\Pr }^{\textrm {orphan}}(s): 孤立大小为 s 的有效块的概率$$</li><li>$${\Pr }^{\textrm {win}}_{i}(\mathbf {x}, \pmb {\omega }, si): 矿池 i 最终赢得一个大小为si的区块的挖矿竞赛的概率是$$</li><li>$$R: 代币发行的奖励$$</li><li>$$\rho: 每单位数据大小的交易确认价格$$</li><li>$$\rho s_{i}: 区块交易的手续费$$</li><li>$$p: 在 T 期间维持单位哈希率的能源价格$$</li><li>$$p\omega _{i}: 能量成本$$</li><li>$$y_{i}(\mathbf {x}, \pmb {\omega }, s_{i}): 矿工在矿池 i 中的期望收益$$</li></ul><h3 id="A-利用POW机制进行挖矿的矿工收益计算"><a href="#A-利用POW机制进行挖矿的矿工收益计算" class="headerlink" title="A.利用POW机制进行挖矿的矿工收益计算"></a>A.利用POW机制进行挖矿的矿工收益计算</h3><p>现假设有一个基于POW的区块链网络，其中有N个独立矿工，这些矿工自行组织成M个矿池，这些矿池的集合可以表示为$$\mathcal {M}={1, 2, \ldots, M}$$，我们假设解谜过程是<a href="#%E6%8A%97asic">抗ASIC</a>的，换句话说，矿工使用通用计算单元进行哈希查询，并且具有大致相同的哈希效率，即每瓦特的哈希率。矿池i要求<strong>每个</strong>加入矿池的矿工提供一定的哈希率<br>$$\omega _{i}$$</p><p>$$\pmb {\omega }=[\omega _{1},\ldots, \omega _{M}]^{\top }$$</p><p>表示所有矿池要求每个独立矿工提供的哈希率集合，另外，让</p><p>$$\mathbf {x}=[x_{1},\ldots,x_{M}]^{\top }$$</p><p>表示矿池中矿工人数占总体矿工数的比例，即</p><p>$$\mathcal {X}=\left&lt;!–swig￼1–&gt; x_{i}=1}\right}$$</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211208153315.png"></p><p>综上所述，矿池i赢得挖矿竞赛的概率为：</p><p>$${\Pr }^{\textrm {mine}}_{i}(\mathbf {x},\pmb {\omega })=\frac {\omega <em>{i} x</em>{i}}{\sum _{j=1}^{M}\omega <em>{j} x</em>{j}}$$</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211208153412.png"></p><p>矿池 i 向所有P2P网络中的对等方广播一个成功开采的区块，以将其传播到整个网络。区块传播时间由每条链路上的传输延迟和每个中继节点的交易验证时间决定。对于大小为s的块，传输延迟可以建模为</p><p>$$\tau _{p}(s)=\frac {s}{\gamma c}$$</p><p>其中</p><p>$$\gamma$$</p><p>表示网络规模相关参数，c是每个链路的平均有效信道容量。同时，由于验证一笔交易需要固定的计算量，区块验证时间可以建模为线性函数</p><p>$$\tau _{v}(s)=\beta s$$</p><p>其中</p><p>$$\beta$$</p><p>是由网络规模和每个节点的平均验证速度共同决定的参数.然后，大小为 s 的块在网络中传播的平均时间为:</p><p>$$ \tau (s)=\tau _{p}(s)+\tau _{v}(s)=\frac {s}{\gamma c}+\beta s. $$</p><p>由于传播延迟而放弃（即孤立）有效候选块的发生率遵循泊松过程(<a href="#%E5%AD%A4%E7%AB%8B%E5%9D%97">补充</a>)，平均速率为 1/T，由网络维持为固定的平均挖掘速率。因此，孤立大小为 s 的有效块的概率为：</p><p>$${\Pr }^{\textrm {orphan}}(s)=1-e^{-\tau (s)/T}=1-e^{-\left({\frac {s}{\gamma c}+\beta s}\right) /T}.$$</p><p>所以，然后，矿池 i 最终赢得一个大小为 </p><p>$$s_{i}$$ </p><p>的区块的挖矿竞赛的概率是 ( 赢得竞赛的概率乘挖到的区块不被孤立的概率 ) ：</p><p>$${\Pr }^{\textrm {win}}<em>{i}(\mathbf {x}, \pmb {\omega }, s</em>{i})=(1-{\Pr }^{\textrm {orphan}}(s))*{\Pr }^{\textrm {mine}}<em>{i}(\mathbf {x},\pmb {\omega })=\frac {\omega <em>{i} x</em>{i}}{\sum <em>{j=1}^{M}\omega <em>{j} x</em>{j}} e^{-\left({\frac {s</em>{i}}{\gamma c}+\beta s</em>{i}}\right)/T}.$$</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211208153637.png"></p><p>一个区块的收益由固定的代币发行奖励和打包在新区块中的所有交易的交易费用组成。考虑到区块链用户为每笔交易支付固定费用并且交易记录具有相同的大小。令 R 表示代币发行奖励，</p><p>$$\rho$$ </p><p>表示每单位数据大小的交易确认价格。然后，交易费用可以表示为</p><p> $$\rho s_{i}$$</p><p> 由于哈希计算，矿工还必须考虑能源成本。让 p 表示在 T 期间维持单位哈希率的能源价格。能量成本可以表示为</p><p>$$p\omega _{i}$$</p><p>  结合之前的讨论，矿工在矿池 i 中的期望收益可以表示为</p><p>$$y_{i}(\mathbf {x}, \pmb {\omega }, s_{i})=\frac {R+\rho s_{i}}{N x_{i}}\frac {\omega <em>{i} x</em>{i}}{\sum <em>{j=1}^{M}\omega <em>{j} x</em>{j}} e^{-\left({\frac {s</em>{i}}{\gamma c}+\beta s_{i}}\right)/T}-p\omega _{i}.\qquad $$</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211208153743.png"></p><h3 id="B-矿池选择过程中的演化博弈"><a href="#B-矿池选择过程中的演化博弈" class="headerlink" title="B.矿池选择过程中的演化博弈"></a>B.矿池选择过程中的演化博弈</h3><p>考虑到每个矿工都是有限理性的，并且旨在最大化其个体的收益。所以我们可以将矿池选择过程中的演化博弈定义为一个四元组：</p><p>$$\mathcal {G}=\langle \mathcal {N}, \mathcal {M}, \mathbf {x}, {y_{i}(\mathbf {x}, \pmb {\omega }, s_{i})}_{i\in \mathcal {M}} \rangle$$</p><ul><li>$$其中\mathcal {N}表示个体矿工人数,并且\vert \mathcal {N}\vert =N$$</li><li>$$\mathcal {M}={1, 2, \ldots, M}表示所有矿池的集合$$</li><li>$$\mathbf {x}\in \mathcal {X}表示人口状态向量$$</li><li>$${y_{i}(\mathbf {x}, \pmb {\omega }, s_{i})}_{i\in \mathcal {M}}表示每个矿池中单个矿工收益的集合$$</li></ul><p>最后，根据成对比例模仿协议，我们完成了矿池选择过程中的演化博弈过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">初始化阶段</span></span><br><span class="line"><span class="comment">1. 所有矿工i堆积选择一个矿池加入</span></span><br><span class="line"><span class="comment">2. 初始化t为1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">while</span> x has <span class="keyword">not</span> converged <span class="keyword">and</span> t&lt;MAX_COUNTER <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i∈N <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">j ← Rand(<span class="number">1</span>,M) &#123;Randomly selects a pool j∈M &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Determine whether to switch to pool j according to the switching probability</span></span><br><span class="line"><span class="comment">//根据转换概率公式（下文给出）决定是否切换矿池</span></span><br><span class="line"><span class="function">Function <span class="title">switching_probability</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">end <span class="keyword">for</span></span><br><span class="line"></span><br><span class="line">t=t+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">end <span class="keyword">while</span></span><br></pre></td></tr></table></figure><p>转换概率公式：</p><p>$$\rho <em>{i,j}=x</em>{j}\max (y_{j}(\mathbf {x}, \pmb {\omega }, s_{j}) - y_{i}(\mathbf {x}, \pmb {\omega }, s_{i}), 0)$$</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211208153807.png"></p><h2 id="仿真过程"><a href="#仿真过程" class="headerlink" title="仿真过程"></a>仿真过程</h2><h2 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h2><h3 id="挖掘策略"><a href="#挖掘策略" class="headerlink" title="挖掘策略"></a>挖掘策略</h3><p>挖掘策略：指矿工在解谜过程以及最后公布区块阶段采取的相应策略，旨在通过合法的方式增大自己的收益，常见的挖掘策略有自私挖掘与合作挖掘，从而还衍生出了智能矿工的概念（不断动态分析各个矿池的数据,可以动态获到当前收益最高的矿池，选择收益最高的矿池）</p><p>自私挖掘：自私挖掘主要通过扣留区块，拖延公布区块的时间来达成。- 自私挖矿的目的不是破坏加密货币的区块链网络，而是获得更大利润。</p><blockquote><p>这种攻击主要由矿工发起。我们以比特币区块链作为例子。简单地说，攻击者挖到新区块后藏起来不公布，其他诚实矿工因为不知道新区块的存在，还是继续在旧区块基础上挖矿。等到攻击者挖到第二枚区块后便会同时公布手中藏着的两枚区块，这时，区块链分叉就出现了。只要攻击者比诚实矿工多挖一枚区块，攻击者所在的分叉就是最长链：根据比特币的共识机制，矿工只在最长链后面挖矿。因此，原本诚实矿工们所在的那条链，因为比攻击者的分叉短，便作废了。此时此刻，攻击者因为挖到了两枚新区块而获得相应收益；而诚实矿工的分叉被废弃，他们什么也得不到。</p></blockquote><blockquote><p>这种攻击的前提是对于算力（即挖矿速度）的比拼。如同刚才提到的，面对区块链出现分叉情况时（这里的分叉不是日常所说改变共识原则的硬分叉或软分叉，而是在共识原则不变前提下的分叉），最长的那一条链被视作合法链。如果自私挖矿攻击者能够迅速让原本的长链变成短链（即在短时间内发布自己挖到的两枚或多枚区块，让自己所在的区块链分叉变成最长链），那么所有诚实守法的矿工所做的努力都白费了。</p></blockquote><h3 id="抗ASIC"><a href="#抗ASIC" class="headerlink" title="抗ASIC"></a>抗ASIC</h3><p>ASIC是专用继承电路的缩写，是为特定目的而生产的微芯片，在加密货币领域，ASIC最常用于计算密码难题，特别是用于挖矿过程。</p><p>顾名思义，抗ASIC是指能够有效抗击ASIC的算法，常见的具有抗ASIC性的货币有以太坊等</p><h3 id="孤立块"><a href="#孤立块" class="headerlink" title="孤立块"></a>孤立块</h3><p>孤立块的出现是由于意外分叉，意外分叉即两个或以上的矿工在几乎相同的时间成功挖到区块，此时原来的区块链便会产生分叉，而收到不同区块的两组矿工便会在两条分叉的链上继续挖矿，直至其中一组矿工首先挖到下一枚区块，生成了更长链，此时网络中的矿工便会舍弃原来较短的链上的最后一枚区块，转而相信最长链的数据，分叉也随之消失，而被舍弃的那枚区块，就叫做孤立块。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;区块链网络中矿池选择的演化博弈&quot;&gt;&lt;a href=&quot;#区块链网络中矿池选择的演化博弈&quot; class=&quot;headerlink&quot; title=&quot;区块链网络中矿池选择的演化博弈&quot;&gt;&lt;/a&gt;区块链网络中矿池选择的演化博弈&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://i</summary>
      
    
    
    
    
    <category term="区块链" scheme="http://ywrby.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="演化博弈" scheme="http://ywrby.com/tags/%E6%BC%94%E5%8C%96%E5%8D%9A%E5%BC%88/"/>
    
  </entry>
  
  <entry>
    <title>17-生产者与消费者问题</title>
    <link href="http://ywrby.com/2021/11/12/17-%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98/"/>
    <id>http://ywrby.com/2021/11/12/17-%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98/</id>
    <published>2021-11-12T07:29:27.000Z</published>
    <updated>2021-11-14T12:23:31.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生产者与消费者问题"><a href="#生产者与消费者问题" class="headerlink" title="生产者与消费者问题"></a>生产者与消费者问题</h1><p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品就放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用（这里的产品可能是某种数据）</p><p>生产者和消费者共享一个初始为空，大小为n的缓冲区</p><ul><li>只有缓冲区没满时，生产者才能将产品放入缓冲区，否则必须等待</li><li>只有缓冲区不空时，消费者才能从缓冲区取出产品，否则必须等待</li><li>缓冲区是临界资源，各进程必须互斥访问</li></ul><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211112154744.png"></p><h2 id="PV操作题目常见方法"><a href="#PV操作题目常见方法" class="headerlink" title="PV操作题目常见方法"></a>PV操作题目常见方法</h2><p>信号量机制可以实现互斥，同步以及对一类资源的申请和释放</p><ul><li>互斥：一般会设置初值为1的互斥信号量</li><li>同步：设置初值为0的同步信号量（实现一前一后）</li><li>资源的释放和申请：设置一个信号量，初始值即为资源数量（本质还是进程同步）</li></ul><h2 id="PV操作题目分析步骤"><a href="#PV操作题目分析步骤" class="headerlink" title="PV操作题目分析步骤"></a>PV操作题目分析步骤</h2><ol><li>关系分析，找出题目中描述的各个进程，分析它们之间的同步互斥关系<ul><li>本题中，涉及以下几种进程同步，互斥关系</li><li>互斥关系：对于临界区的访问，必须互斥进行</li><li>同步关系：缓冲区满，生产者必须开始等待，直到消费者取走产品</li><li>同步关系：缓冲区空，消费者必须开始等待，直到生产者放入产品</li></ul></li><li>整理思路，根据各进程的操作流程确定P，V操作的大致顺序<ul><li>生产者每次要消耗一个空闲缓冲区（P）并生产一个产品（V）</li><li>消费者每次要消耗一个产品（P）并释放一个空闲缓冲区（V）</li><li>往缓冲区收入/取走产品需要互斥</li></ul></li><li>设置信号量，根据上文内容确定所需的信号量，并根据题目条件确定信号量初值<ul><li>互斥信号量一般为1</li><li>同步信号量一般为资源初始值</li></ul></li></ol><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>根据上文所述，我们需要三个信号量来解决本问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex=<span class="number">1</span>; <span class="comment">// 互斥信号量，实现对缓冲区的互斥访问</span></span><br><span class="line">semaphore empty=n; <span class="comment">// 同步信号量，表示空闲缓冲区的数量</span></span><br><span class="line">semaphore full=<span class="number">0</span>; <span class="comment">// 同步信号量，表示产品数量，也即非空闲缓冲区的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line">producer ()&#123;</span><br><span class="line">    <span class="comment">// 执行循环</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        生产一个产品</span><br><span class="line">        P(empty); <span class="comment">// 消耗一个空闲缓冲区</span></span><br><span class="line">        P(mutex); <span class="comment">// 对缓冲区上锁</span></span><br><span class="line">        把产品放入缓冲区;</span><br><span class="line">        V(mutex); <span class="comment">//对缓冲区解锁</span></span><br><span class="line">        V(full); <span class="comment">//增加一个产品数量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line">consumer ()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(full); <span class="comment">//消耗一个产品</span></span><br><span class="line">        P(mutex); <span class="comment">//对缓冲区上锁</span></span><br><span class="line">        从缓冲区取出一个产品;</span><br><span class="line">        V(mutex); <span class="comment">//释放缓冲区</span></span><br><span class="line">        V(empty); <span class="comment">//增加一个空闲缓冲区数量</span></span><br><span class="line">        使用产品;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个过程中相邻的两个P操作不能交换位置，例如，若将生产者中相邻的两个P操作交换位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生产者</span></span><br><span class="line">producer ()&#123;</span><br><span class="line">    <span class="comment">// 执行循环</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        生产一个产品</span><br><span class="line">        P(mutex); <span class="comment">// 对缓冲区上锁</span></span><br><span class="line">        P(empty); <span class="comment">// 消耗一个空闲缓冲区</span></span><br><span class="line">        把产品放入缓冲区;</span><br><span class="line">        V(mutex); <span class="comment">//对缓冲区解锁</span></span><br><span class="line">        V(full); <span class="comment">//增加一个产品数量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设此时empty=0,full=n即缓冲区中没有空闲位置，则生产者进程执行</p><ol><li>使mutex变为0</li><li>由于没有空闲缓冲区，所以生产者被阻塞</li><li>消费者进程执行，由于mutex=0，即生产者还没有释放临界资源的“锁”，所以消费者也被阻塞</li><li>生产者等待消费者释放空闲缓冲区，消费者等待生产者释放临界区资源</li><li>造成死锁</li></ol><p>同理，若调换消费者相邻P操作的位置，在full=0,empty=n时也会造成死锁</p><p><strong>因此，实现互斥的P操作一定要放在实现同步的P操作之后</strong></p><p>V操作不会导致进程阻塞，因此相邻V操作的位置可换</p><h1 id="多生产者多消费者问题-放取水果问题"><a href="#多生产者多消费者问题-放取水果问题" class="headerlink" title="多生产者多消费者问题-放取水果问题"></a>多生产者多消费者问题-放取水果问题</h1><p>桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。用PV操作实现上述过程。</p><ol><li>关系分析，找出题目中各个进程以及它们之间的同步互斥关系<ul><li>可以看到，这个题目中父亲和母亲相当于两个生产者进程，女儿和儿子相当于两个消费者进程</li><li>只不过要注意这里的两个生产者生产物品不同，消费者消费的物品也不同</li></ul></li><li>整理思路，根据各个进程的操作流程确定PV操作大致顺序<ul><li>互斥操作要在在临界区前后分别PV，同步操作要前V后P</li><li>互斥关系：对缓冲区（盘子）的访问要互斥进行</li><li>同步关系：父亲将苹果放入盘子，女儿才可以取苹果</li><li>同步关系：母亲将橘子放入盘子，儿子才可以取橘子</li><li>同步关系：只有盘子为空时，父亲或母亲才能放入水果</li></ul></li><li>设置信号量（互斥信号量一般为1，同步信号量初值取决于资源初始书目）</li></ol><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211114192311.png"></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex=<span class="number">1</span>; <span class="comment">//实现互斥访问临界区（盘子）</span></span><br><span class="line">semaphore apple=<span class="number">0</span>; <span class="comment">//盘子中有几个苹果</span></span><br><span class="line">semaphore orange=<span class="number">0</span>; <span class="comment">//盘子中有几个橘子</span></span><br><span class="line">semaphore plate=<span class="number">1</span>; <span class="comment">//盘子中还可以放几个水果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 父亲进程</span></span><br><span class="line">dad()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        准备一个苹果;</span><br><span class="line">        P(plate);  <span class="comment">//等待一个盘子位置</span></span><br><span class="line">        P(mutex);  <span class="comment">//临界区上锁</span></span><br><span class="line">        把苹果放入盘子;</span><br><span class="line">        V(mutex); <span class="comment">//临界区解锁</span></span><br><span class="line">        V(apple); <span class="comment">//释放苹果资源（苹果数加一，同时唤醒女儿进程执行）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//母亲进程</span></span><br><span class="line">mom()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        准备一个橘子;</span><br><span class="line">        P(plate);  <span class="comment">//等待一个盘子位置</span></span><br><span class="line">        P(mutex);  <span class="comment">//临界区上锁</span></span><br><span class="line">        把橘子放入盘子;</span><br><span class="line">        V(mutex); <span class="comment">//临界区解锁</span></span><br><span class="line">        V(orange); <span class="comment">//释放橘子资源（橘子数加一，同时唤醒儿子进程执行）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//女儿进程</span></span><br><span class="line">daughter()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(apple); <span class="comment">//等待苹果资源</span></span><br><span class="line">        P(mutex); <span class="comment">//临界区上锁</span></span><br><span class="line">        从盘中取出苹果;</span><br><span class="line">        V(mutex); <span class="comment">//临界区解锁</span></span><br><span class="line">        V(plate); <span class="comment">//已经取出了苹果，所以释放盘子资源</span></span><br><span class="line">        吃掉苹果;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//儿子进程</span></span><br><span class="line">son()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(orange); <span class="comment">//等待橘子资源</span></span><br><span class="line">        P(mutex); <span class="comment">//临界区上锁</span></span><br><span class="line">        从盘中取出橘子;</span><br><span class="line">        V(mutex); <span class="comment">//临界区解锁</span></span><br><span class="line">        V(plate); <span class="comment">//已经取出了橘子，所以释放盘子资源</span></span><br><span class="line">        吃掉橘子;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;生产者与消费者问题&quot;&gt;&lt;a href=&quot;#生产者与消费者问题&quot; class=&quot;headerlink&quot; title=&quot;生产者与消费者问题&quot;&gt;&lt;/a&gt;生产者与消费者问题&lt;/h1&gt;&lt;p&gt;系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品就放入缓冲区，消费</summary>
      
    
    
    
    
    <category term="操作系统" scheme="http://ywrby.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>16-用信号量实现进程互斥,同步,前驱关系</title>
    <link href="http://ywrby.com/2021/11/12/16-%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5-%E5%90%8C%E6%AD%A5-%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB/"/>
    <id>http://ywrby.com/2021/11/12/16-%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5-%E5%90%8C%E6%AD%A5-%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB/</id>
    <published>2021-11-12T02:14:33.000Z</published>
    <updated>2021-11-12T02:54:24.465Z</updated>
    
    <content type="html"><![CDATA[<h1 id="信号量机制实现进程互斥"><a href="#信号量机制实现进程互斥" class="headerlink" title="信号量机制实现进程互斥"></a>信号量机制实现进程互斥</h1><h2 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h2><ol><li>分析并发进程的关键活动，划定临界区（例如：对打印机等临界资源的访问就应放在临界区内）</li><li>设置互斥信号量，常命名为mutex，初值为1（因为一般情况下对临界区的访问同一时间只能存在一个进程）</li><li>在临界区之前执行P(mutex)</li><li>在临界区之后执行V(mutex)</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex=<span class="number">1</span>;</span><br><span class="line">P1()&#123;</span><br><span class="line">    ...</span><br><span class="line">    P(mutex)</span><br><span class="line">    临界区代码段...</span><br><span class="line">    V(mutex)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2()&#123;</span><br><span class="line">    ...</span><br><span class="line">    P(mutex)</span><br><span class="line">    临界区代码段...</span><br><span class="line">    V(mutex)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>对不同的临界资源需要设置不同的互斥信号量（mutex1，mutex2）</li><li>P,V操作必须成对出现，缺少P就不能保证临界资源的互斥访问，缺少V就会导致资源永远不被释放，等待进程永远不能唤醒</li></ul><h1 id="信号量机制实现进程同步"><a href="#信号量机制实现进程同步" class="headerlink" title="信号量机制实现进程同步"></a>信号量机制实现进程同步</h1><p>进程同步的目的在于让各个本来异步并发的进程按要求有序推进</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">P1()&#123;</span><br><span class="line">    代码<span class="number">1</span>;</span><br><span class="line">    代码<span class="number">2</span>;</span><br><span class="line">    代码<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2()&#123;</span><br><span class="line">    代码<span class="number">4</span>;</span><br><span class="line">    代码<span class="number">5</span>;</span><br><span class="line">    代码<span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，在上面的P1和P2进程中，由于异步性导致程序执行顺序并不确定，但我们必须保证代码1和代码2在代码4之前执行，此时就需要使用进程同步机制实现</p><h2 id="用信号量实现进程同步的步骤"><a href="#用信号量实现进程同步的步骤" class="headerlink" title="用信号量实现进程同步的步骤"></a>用信号量实现进程同步的步骤</h2><ol><li>分析什么地方需要实现“同步关系”，即保证“一前一后”执行的两个操作</li><li>设置同步信号量：S，初值为0</li><li>在“必须先执行的操作”之后执行V(S)</li><li>在“必须后执行的操作”之前执行P(S)</li></ol><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">semaphore S=<span class="number">0</span>; <span class="comment">//初始化同步信号量，初值为0</span></span><br><span class="line"></span><br><span class="line">P1()&#123;</span><br><span class="line">    代码<span class="number">1</span>;</span><br><span class="line">    代码<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//代码1和代码2是必须先执行的操作</span></span><br><span class="line">    <span class="comment">//所以在它们之后执行V(S)</span></span><br><span class="line">    V(S); </span><br><span class="line">    代码<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2()&#123;</span><br><span class="line">    <span class="comment">//代码4是必须后执行的操作</span></span><br><span class="line">    <span class="comment">//所以在它前面执行P(S)</span></span><br><span class="line">    P(S);</span><br><span class="line">    代码<span class="number">4</span>;</span><br><span class="line">    代码<span class="number">5</span>;</span><br><span class="line">    代码<span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若先执行了P1进程，执行完代码1和代码2后，进行V操作，则信号量S++后S=1，之后执行P2进程时，执行P操作判断S=1&gt;0所以表示有可用资源可以继续执行，S–后S=0，不会执行block原语被阻塞，可以继续往下执行代码4</p><p>若先执行P2进程，由于P操作判断S=0表示没有可用资源，所以执行block原语，主动请求阻塞P2进程，直到P1进程执行完代码1和代码2后到V操作发现S=-1表示等待队列中有进程在等待资源，所以其主动唤醒P2进程，P2进程得以继续执行代码4</p><h1 id="信号量机制实现前驱关系"><a href="#信号量机制实现前驱关系" class="headerlink" title="信号量机制实现前驱关系"></a>信号量机制实现前驱关系</h1><p>一共有六个进程P1,P2…P6，其中进程P1中有代码S1，P2中有代码S2，…P6中有代码S6，这些代码要求按如下前驱图所示的顺序执行<br><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211112104420.png"></p><h2 id="主要步骤-1"><a href="#主要步骤-1" class="headerlink" title="主要步骤"></a>主要步骤</h2><p>其实每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作），所以</p><ol><li>要为每一对前驱关系各设置一个同步变量</li><li>在“必须先执行操作”之后对相应同步变量执行V操作</li><li>在“必须后执行操作”之前对相应同步变量执行P操作</li></ol><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211112105243.png"></p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211112105325.png"></p><p> 不难看出，前驱关系本质上还是更复杂的进程同步问题 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;信号量机制实现进程互斥&quot;&gt;&lt;a href=&quot;#信号量机制实现进程互斥&quot; class=&quot;headerlink&quot; title=&quot;信号量机制实现进程互斥&quot;&gt;&lt;/a&gt;信号量机制实现进程互斥&lt;/h1&gt;&lt;h2 id=&quot;主要步骤&quot;&gt;&lt;a href=&quot;#主要步骤&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="操作系统" scheme="http://ywrby.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>15-信号量机制</title>
    <link href="http://ywrby.com/2021/11/08/15-%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6/"/>
    <id>http://ywrby.com/2021/11/08/15-%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6/</id>
    <published>2021-11-08T12:33:49.000Z</published>
    <updated>2021-11-08T13:38:16.881Z</updated>
    
    <content type="html"><![CDATA[<h1 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h1><p>在我们之前学习的有关进程互斥的硬件软件方法中，都存在着一些不可避免的问题</p><ul><li>例如在双标志检查法中，由于检查和上锁操作不能原子性的完成，导致两个进程可能同时进入临界区</li><li>又比如之前所讲的软硬件方法都无法实现“让权等待”</li></ul><p>基于以上所说的问题，我们最终提出了有效解决进程互斥与进程同步的方法–信号量机制</p><p>用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而方便的实现进程互斥与进程同步</p><p>信号量实质就是一个变量（可以是一个整数，也可以是复杂的记录型变量），可以用一个信号量来表示系统中某种资源的数量（例如：系统有两台打印机，就可以设置一个信号量初始值为2）</p><p>原语是一种特殊程序段，其执行只能一气呵成，不可中断。原语是利用开/关中断指令实现的。软件解决方案的主要问题基本都出在进入区中的各种操作不能原子性的执行，因此如果能把进入区，退出区的操作都利用原语实现，就可以避免问题的产生</p><p>我们所使用的一对原语是：wait(S)原语和signal(S)原语，可以把原语理解为我们自己写的函数，函数名为wait和signal，括号里的S表示信号量S，其实就是函数调用时所传入的一个参数</p><p>wait和signal原语常被称为P,V操作，因此做题时也常将其写作P(S),V(S)</p><h2 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h2><p>用一个整数型变量作为信号量，用来表示系统中某种资源的数量，整数型信号量与我们平常创建的普通整数变量的区别主要是我们对该信号量只能进行三种操作：即初始化或P操作和V操作</p><p>例如：系统中有一台打印机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> S=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> S)</span> </span>&#123; <span class="comment">//wait原语，相当于进入区</span></span><br><span class="line">    <span class="comment">//检查和上锁一气呵成，避免了并发过程中异步导致的问题</span></span><br><span class="line">    <span class="keyword">while</span>(S&lt;=<span class="number">0</span>); <span class="comment">//如果资源不够，则始终循环等待，这一步不满足“让权等待”</span></span><br><span class="line">    S=S-<span class="number">1</span>; <span class="comment">//如果资源足够，则占用一个资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123; <span class="comment">//signal原语，相当于退出区</span></span><br><span class="line">    S=S+<span class="number">1</span>;  <span class="comment">//在使用完资源后，在退出区释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211108205942.png"></p><p>按照上面示例，P0进程在进入区利用wait原语申请资源，然后进入临界区，此时S减一后为0，P1到Pn进程只能在wait原语中循环等待，直到P0进程释放资源。</p><p>此时就不会出现我们之前的两个进程同时进入临界区的情况，因为wait是原语，其执行原子性操作，所以检查和上锁是同时进行的</p><h2 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h2><p>整型信号量存在的缺陷是不满足“让权等待”存在忙等，所以人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*记录型信号量的定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;  <span class="comment">//剩余资源数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span>  <span class="comment">//等待队列</span></span><br><span class="line">&#125;semaphore</span><br><span class="line"></span><br><span class="line"><span class="comment">/*某进程需要使用资源时，通过wait原语申请*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(semaphore S)</span></span>&#123;</span><br><span class="line">    S.value--;  <span class="comment">//将资源数减一</span></span><br><span class="line">    <span class="keyword">if</span>(S.value&lt;<span class="number">0</span>)&#123; <span class="comment">//判断资源数是否小于0</span></span><br><span class="line">        <span class="comment">//小于0表示剩余资源不足</span></span><br><span class="line">        block(S.L);</span><br><span class="line">        <span class="comment">//使用block原语使进程从运行态进入阻塞态，</span></span><br><span class="line">        <span class="comment">//并把该进程挂到信号量S的等待队列（即阻塞队列中）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*进程使用完资源后，使用signal原语释放资源*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">(semaphore S)</span></span>&#123;</span><br><span class="line">    S.value++;  <span class="comment">//将剩余资源数加一</span></span><br><span class="line">    <span class="keyword">if</span>(S.value&lt;=<span class="number">0</span>)&#123; <span class="comment">//判断资源数是否小于等于0</span></span><br><span class="line">        <span class="comment">//资源数小于等于0表示等待队列中还有进程处于阻塞态等待资源释放</span></span><br><span class="line">        wakeup(S.L)</span><br><span class="line">        <span class="comment">//利用wakeup原语唤醒等待队列中的一个进程</span></span><br><span class="line">        <span class="comment">//该进程从阻塞态转变为就绪态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211108212318.png"></p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211108212327.png"></p><p>现在有四个进程按照P0-&gt;P3的顺序申请使用打印机</p><ol><li>初始化打印机信号量：S.value=2</li><li>P0进程申请打印机，调用wait原语S.value-1=1，随后经过判断S.value&gt;=0所以成功申请打印机并且不进入等待队列</li><li>P1进程申请打印机，调用wait原语S.value-1=0，经过判断S.value&gt;=0，有剩余资源所以成功申请打印机并且不进入等待队列</li><li>P2申请打印机，调用wait原语S.value-1=-1，经过判断S.value&lt;0所以没有剩余资源，利用block原语对P2进程进行阻塞，并将其放入等待队列</li><li>P3申请打印机，调用wait原语S.value-1=-2，经过判断S.value&lt;0所以没有剩余资源，利用block原语对P3进程进行阻塞，并将其放入等待队列</li><li>P0进程使用结束，利用signal原语S.value+1=-1，经过判断S.value&lt;=0，所以等待队列中有进程处于等待状态，调用wakeup原语唤醒一个等待进程</li><li>P2进程被唤醒，开始使用打印机，并且快速使用完毕，调用signal原语S.value+1=0，S.value&lt;=0所以等待队列中还有进程在等待，调用wakeup原语唤醒一个进程</li><li>P3进程被唤醒，开始使用打印机</li><li>P1进程使用完毕，调用signal原语S.value+1=1，此时S.value&gt;0所以等待队列中没有进程，所以不需要执行wakeup原语</li><li>P3进程使用完毕，调用signal原语S.value+1=2，此时S.value&gt;0所以等待队列中没有进程，所以不需要执行wakeup原语</li></ol><p>记录型信号量与整型信号量的主要区别在于其内部存储了等待队列，因此在发现资源被全部分配的情况下，进程不需要始终执行循环，造成“忙等”，而是可以利用block原语进行阻塞，主动放弃处理机，并进入该资源信号量的等待队列中，可见，记录型信号量完成的机制遵循了“让权等待”原则，不会出现“忙等”</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;信号量机制&quot;&gt;&lt;a href=&quot;#信号量机制&quot; class=&quot;headerlink&quot; title=&quot;信号量机制&quot;&gt;&lt;/a&gt;信号量机制&lt;/h1&gt;&lt;p&gt;在我们之前学习的有关进程互斥的硬件软件方法中，都存在着一些不可避免的问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如在双标志检查</summary>
      
    
    
    
    
    <category term="操作系统" scheme="http://ywrby.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>1-归并排序-算法复习</title>
    <link href="http://ywrby.com/2021/11/07/1-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/"/>
    <id>http://ywrby.com/2021/11/07/1-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/</id>
    <published>2021-11-07T10:40:55.000Z</published>
    <updated>2021-11-08T06:58:01.571Z</updated>
    
    <content type="html"><![CDATA[<h1 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h1><p>要了解归并排序算法首先要了解归并这一过程，归并过程处理两个可比较数组（两个数组已经各自有序），在归并过程中，不断对两个数组的当前首元素进行比较，将较小的元素放置到新数组的下一位置。</p><h2 id="归并实现：-原地归并的抽象方法"><a href="#归并实现：-原地归并的抽象方法" class="headerlink" title="归并实现：(原地归并的抽象方法)"></a>归并实现：(原地归并的抽象方法)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ywrby.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//原地归并的抽象实现</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 参数a表示已经部分有序的原数组（前一部分，后一部分分别有序）</span></span><br><span class="line"><span class="comment">    * 参数lo表示前一部分数组的首元素（前一部分最小值）</span></span><br><span class="line"><span class="comment">    * 参数mid表示前一部分数组最后一个元素（后一部分数组首元素的前一位，前一部分最大值）</span></span><br><span class="line"><span class="comment">    * 参数hi表示后一部分数组最后一位(后一部分最大值)</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergeTest</span><span class="params">(Comparable[] a,<span class="keyword">int</span> lo,<span class="keyword">int</span> mid,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=lo,j=mid+<span class="number">1</span>;</span><br><span class="line">        Comparable[] aux=<span class="keyword">new</span> Comparable[hi+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//通过遍历复制原数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=lo;k&lt;=hi;k++)&#123;</span><br><span class="line">            aux[k]=a[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对原数组进行归并</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=lo;k&lt;=hi;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;mid) a[k]=aux[j++];  <span class="comment">//若前一部分数组元素用尽，就取后一部分数组元素</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j&gt;hi) a[k]=aux[i++];  <span class="comment">//若后一部分数组元素，就取前一部分数组元素</span></span><br><span class="line">            <span class="comment">// 两个都没有用尽，就比较两数组当前首元素大小，取二者中较小的</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(less(aux[j],aux[i])) a[k]=aux[j++];  </span><br><span class="line">            <span class="keyword">else</span> a[k]=aux[i++];  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="自顶向下的归并排序"><a href="#自顶向下的归并排序" class="headerlink" title="自顶向下的归并排序"></a>自顶向下的归并排序</h1><p>基于原地归并的抽象实现完成的一种递归排序，首先不断对原数组进行分割，直至不能分割（每个数组中仅含一个元素），然后以每两个数组进行归并（因为只有一个元素，所以数组有序），经过一轮归并，数组中元素为2个或1个，继续递归进行归并排序，直至数组全部归并只剩一个</p><p>整个过程利用了分治思想，将一个大问题拆解为若干个简单的小问题加以解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ywrby.sorts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.ywrby.tools.StopWatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//自顶向下的归并排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原地归并的抽象实现</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 参数a表示已经部分有序的原数组（前一部分，后一部分分别有序）</span></span><br><span class="line"><span class="comment">     * 参数lo表示前一部分数组的首元素（前一部分最小值）</span></span><br><span class="line"><span class="comment">     * 参数mid表示前一部分数组最后一个元素（后一部分数组首元素的前一位，前一部分最大值）</span></span><br><span class="line"><span class="comment">     * 参数hi表示后一部分数组最后一位(后一部分最大值)</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">            aux[k] = a[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对原数组进行归并</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; mid) a[k] = aux[j++];  <span class="comment">//若前一部分数组元素用尽，就取后一部分数组元素</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi) a[k] = aux[i++];  <span class="comment">//若后一部分数组元素，就取前一部分数组元素</span></span><br><span class="line">                <span class="comment">// 两个都没有用尽，就比较两数组当前首元素大小，取二者中较小的</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (less(aux[j], aux[i])) a[k] = aux[j++];</span><br><span class="line">            <span class="keyword">else</span> a[k] = aux[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//准备额外空间用于盛放排序后的数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        aux = <span class="keyword">new</span> Comparable[a.length];</span><br><span class="line">        sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*基于原地归并的抽象实现完成的一种递归排序</span></span><br><span class="line"><span class="comment">     *首先不断对原数组进行分割，直至不能分割（每个数组中仅含一个元素）</span></span><br><span class="line"><span class="comment">     *然后以每两个数组进行归并（因为只有一个元素，所以数组有序）</span></span><br><span class="line"><span class="comment">     *经过一轮归并，数组中元素为2个或1个</span></span><br><span class="line"><span class="comment">     *继续递归进行归并排序，直至数组全部归并只剩一个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        sort(a, lo, mid);</span><br><span class="line">        sort(a, mid + <span class="number">1</span>, hi);</span><br><span class="line">        merge(a, lo, mid, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        Comparable temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;After sort : &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!less(a[i], a[i + <span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">1000</span>;</span><br><span class="line">        Comparable&lt;Double&gt;[] test = <span class="keyword">new</span> Comparable[N];</span><br><span class="line">        System.out.print(<span class="string">&quot;before sort : &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">double</span> data = Math.random();</span><br><span class="line">            System.out.print(data + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">            test[i] = data;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        StopWatch watch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">        sort(test);</span><br><span class="line">        <span class="keyword">double</span> time = watch.elapsedTime();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * assert关键字：assert [boolean 表达式]</span></span><br><span class="line"><span class="comment">         * 如果[boolean表达式]为true，则程序继续执行。</span></span><br><span class="line"><span class="comment">         * 如果为false，则程序抛出AssertionError，并终止执行。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(test)</span></span>;</span><br><span class="line">        show(test);</span><br><span class="line">        System.out.println(<span class="string">&quot;time=&quot;</span> + time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>对于长度为N的任意数组，自顶向下的归并排序需要NlgN/2~NlgN次++比较++</p><p>令C(N)表示一个长度为N的数组需要进行比较的次数。易知：C(0)=C(1)=0,且自顶向下排序采用了递归的方法，所以可以写成：<br>$$C(N)&lt;=C_{前}(N/2)+C_{后}(N/2)+N$$</p><p>第一项表示数组前半部分比较次数，第二项则表示后半部分比较次数，最后一项表示将两项归并到一起所需要的最大比较次数</p><p>$$C(N)&gt;=C_{前}(N/2)+C_{后}(N/2)+N/2$$<br>同理最后一项表示归并时最小比较次数</p><p>以$N=2^n$时为例下的++最坏情况++进行分析，可以得到如下结论：</p><p>$$C(2^n)=C_{前}(2^{n-1})+C_{后}(2^{n-1})+2^n=2*C(2^{n-1})+2^n$$<br>将上式两边同时除以2^n得到：</p><p>$$C(2^n)/2^n=C(2^{n-1})/2^{n-1}+1$$<br>利用该式可以替换右边第一项得到：</p><p>$$C(2^n)/2^n=C(2^{n-2})/2^{n-2}+1+1$$<br>重复n次得到<br>$$C(2^n)/2^n=C(0)/2^{0}+n=n$$<br>因此</p><p>$$C(2^n)=n<em>2^n$$<br>进而由N=2^n得到<br>$$C(N)=N</em>lgN$$</p><p>虽然这是对特殊情况的一种讨论，但我们不难理解这对任意N是普遍适用的</p><hr><p>对于长度为N的任意数组，自顶向下的归并排序最多需要++访问数组++6NlgN次</p><p>每次归并最多访问数组6N次（第一个for循环的复制过程2N次，比较过程中最多2N次，将排序好的元素放回2N次），所以由上一个命题易知，最多需要访问数组6NlgN次</p><hr><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>运行时间与NlgN成正比，所以可以处理数百万甚至更大规模数组，这是初级排序算法无法做到的</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>辅助数组所使用的额外空间与N成正比</p><hr><h3 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h3><ol><li>对小规模数组使用插入排序而不是始终递归</li><li>添加方法以测试数组是否已经有序(a[mid]&lt;=a[mid+1])</li><li>不将元素复制到辅助数组</li></ol><hr><h1 id="自底向上的归并排序"><a href="#自底向上的归并排序" class="headerlink" title="自底向上的归并排序"></a>自底向上的归并排序</h1><p>自底向上的归并排序会遍历整个数组，根据子数组大小进行两两排序。子数组的大小sz的初始值为1，每次加倍。最后一个字数组的大小只有在数组大小是sz的偶数倍的时候才会等于sz(否则会比sz小)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ywrby.sorts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.ywrby.tools.StopWatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自底向上的归并排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeBuSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">            aux[k] = a[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对原数组进行归并</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; mid) a[k] = aux[j++];  <span class="comment">//若前一部分数组元素用尽，就取后一部分数组元素</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi) a[k] = aux[i++];  <span class="comment">//若后一部分数组元素，就取前一部分数组元素</span></span><br><span class="line">                <span class="comment">// 两个都没有用尽，就比较两数组当前首元素大小，取二者中较小的</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (less(aux[j], aux[i])) a[k] = aux[j++];</span><br><span class="line">            <span class="keyword">else</span> a[k] = aux[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N=a.length;</span><br><span class="line">        aux=<span class="keyword">new</span> Comparable[a.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> sz=<span class="number">1</span>;sz&lt;N;sz*=<span class="number">2</span>)&#123;  <span class="comment">//sz：子数组大小</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> lo=<span class="number">0</span>;lo&lt;N-sz;lo+=sz*<span class="number">2</span>)&#123;  <span class="comment">//lo：子数组索引</span></span><br><span class="line">                merge(a,lo,lo+sz-<span class="number">1</span>,Math.min(lo+sz*<span class="number">2</span>-<span class="number">1</span>,N-<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        Comparable temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;After sort : &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!less(a[i],a[i+<span class="number">1</span>]))&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N=<span class="number">100</span>;</span><br><span class="line">        Comparable&lt;Double&gt;[] test=<span class="keyword">new</span> Comparable[N];</span><br><span class="line">        System.out.print(<span class="string">&quot;before sort : &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="keyword">double</span> data=Math.random();</span><br><span class="line">            System.out.print(data+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">            test[i]=data;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        StopWatch watch=<span class="keyword">new</span> StopWatch();</span><br><span class="line">        sort(test);</span><br><span class="line">        <span class="keyword">double</span> time=watch.elapsedTime();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * assert关键字：assert [boolean 表达式]</span></span><br><span class="line"><span class="comment">         * 如果[boolean表达式]为true，则程序继续执行。</span></span><br><span class="line"><span class="comment">         * 如果为false，则程序抛出AssertionError，并终止执行。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(test)</span></span>;</span><br><span class="line">        show(test);</span><br><span class="line">        System.out.println(<span class="string">&quot;time=&quot;</span>+time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="归并排序的局限性"><a href="#归并排序的局限性" class="headerlink" title="归并排序的局限性"></a>归并排序的局限性</h1><ol><li>归并排序的空间复杂度不是最优的</li><li>除了比较，算法的其他操作（访问数组）也可能很重要</li><li>不进行比较也能将某些数据排序</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;归并&quot;&gt;&lt;a href=&quot;#归并&quot; class=&quot;headerlink&quot; title=&quot;归并&quot;&gt;&lt;/a&gt;归并&lt;/h1&gt;&lt;p&gt;要了解归并排序算法首先要了解归并这一过程，归并过程处理两个可比较数组（两个数组已经各自有序），在归并过程中，不断对两个数组的当前首元素进行比</summary>
      
    
    
    
    
    <category term="算法" scheme="http://ywrby.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>14-进程同步与进程互斥</title>
    <link href="http://ywrby.com/2021/11/07/14-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5/"/>
    <id>http://ywrby.com/2021/11/07/14-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5/</id>
    <published>2021-11-07T07:31:02.000Z</published>
    <updated>2021-11-08T12:33:31.199Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h1><blockquote><p>回顾:进程具有异步性的特征，即各个并发执行的进程以各自独立的，不可预知的速度向前推进</p></blockquote><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211102103952.png"></p><p>但进程的异步性在有些情况下可能会影响程序的正常运行，以上图的管道通信为例，进程1负责写入数据，进程2负责读取数据，只有进程1将管道数据填满后进程2才能成功取到数据，但两个进程并发执行，无法确定读写数据操作的先后顺序，而实际情况又要求必须先写后读的方式执行，此时就需要通过进程同步解决相关问题</p><p>进程同步亦称直接制约关系，它是指为完成某个任务而建立的两个或多个进程，这些进程由于需要在某些位置上协调工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作</p><h1 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h1><p><a href="https://ywrby.cn/2021/11/01/2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E5%BE%81/">两种资源共享方式</a></p><p>通过之前的知识我们知道，进程的“并发”依赖于“共享”的支持，各个并发执行的进程不可避免的需要共享一些系统资源</p><p>我们把<strong>一个时间段内只允许一个进程使用</strong>的资源称为临界资源，许多物理（摄像头，打印机）都属于临界资源，此外还有许多变量，数据，内存缓冲区都属于临界资源</p><p>对临界资源的访问，必须互斥地进行。</p><p>互斥亦称间接制约关系。进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待，当前访问临界资源的进程结束访问，释放临界资源后，另一个进程才能访问临界资源</p><p>对临界资源的互斥访问，可以在逻辑上分为如下四个部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">//进入区</span></span><br><span class="line">    entry_section() &#123; </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        进入区负责检查是否可以进入临界区</span></span><br><span class="line"><span class="comment">        若可以进入，则应设置“正在访问临界资源的标志”（即上锁）</span></span><br><span class="line"><span class="comment">        以阻止其他进程同时进入临界区</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//临界区</span></span><br><span class="line">    critical_section() &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        临界区就是访问临界资源的那段代码</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//退出区</span></span><br><span class="line">    exit_section() &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        退出区负责接触“正在访问临界资源的标志”（即解锁）</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//剩余区</span></span><br><span class="line">    remainder_section() &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        剩余区负责进行其他处理</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>临界区是进程中访问临界资源的代码段</li><li>进入区和退出区是负责实现互斥的代码段</li><li>临界区有时也称为临界段</li></ul><h2 id="进程互斥需要遵循的原则"><a href="#进程互斥需要遵循的原则" class="headerlink" title="进程互斥需要遵循的原则"></a>进程互斥需要遵循的原则</h2><p>为了实现对临界资源的互斥访问，同时保证系统整体性能，进程互斥需要遵循以下原则</p><ol><li>空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区</li><li>忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待</li><li>有限等待：对请求访问的进程，应保证能在有限时间进入临界区（避免饥饿）</li><li>让权等待：当进程不能进入临界区，应立即释放处理机，防止进程忙等待（处理机被占用，但没有真正运行）</li></ol><h1 id="进程互斥的软件实现方法"><a href="#进程互斥的软件实现方法" class="headerlink" title="进程互斥的软件实现方法"></a>进程互斥的软件实现方法</h1><h2 id="单标志法"><a href="#单标志法" class="headerlink" title="单标志法"></a>单标志法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程，也就是说每个进程进入临界区的权限只能被另一个进程赋予</p><h3 id="算法示例"><a href="#算法示例" class="headerlink" title="算法示例"></a>算法示例</h3><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211107165923.png"></p><p>从上面示例可以看到，turn初值设为0，即刚开始只允许0号进入临界区，若P1进程尝试进入临界区，则会在执行第五行代码时被循环卡在进入区，直到时间片用尽，切换P0进程运行，P0在进入区代码检查通过能够正常访问临界区</p><p>此时，即使发生进程切换导致P1再次执行也会由于进入区的检查导致P1无法进入临界区，只有当P0进程在临界区执行完毕，释放资源，执行第三行代码进入退出区后，P1才能进入临界区</p><p>可以看到，该代码保证了同一时刻最多只允许一个进程访问临界区</p><p>但是，这种算法的据现象在于，如果当前标志位turn所设置的进程一直不执行，则会导致另一个进程始终无法进入临界区，即违背了“空闲让进” 的原则</p><h2 id="双标志先检查法"><a href="#双标志先检查法" class="headerlink" title="双标志先检查法"></a>双标志先检查法</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>设置一个布尔型数组flag[],数组中各个元素用来标记各个进程想进入临界区的意愿，例如“flag[0]=true”表示0号进程P0现在想要进入临界区，每个进程在进入临界区前都会先检查是否有其他进程想要进入临界区，若没有，则将自身标志位设为true，开始访问临界区</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211107171251.png"></p><p>但是，由于进程执行过程中的异步性，代码的执行顺序是不确定的，若按照1，5，2，6，3，7的顺序执行，则会导致两个标志位同时被设置为true，同时进入临界区，违反了“忙则等待”原则</p><p>出现上面问题的核心原因就在于进入区中的“检查”和“上锁”处理不是原子性执行，而是分开执行的，在检查后，上锁前可能发生进程切换</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211107172133.png"></p><h2 id="双标志后检查法"><a href="#双标志后检查法" class="headerlink" title="双标志后检查法"></a>双标志后检查法</h2><h3 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h3><p>考虑到前面的先检查法出现问题是由于先检查后上锁，但是两个操作又无法原子性执行，所以后检查法希望通过先上锁，后检查来解决上面提到的问题</p><h3 id="算法示例-1"><a href="#算法示例-1" class="headerlink" title="算法示例"></a>算法示例</h3><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211107172524.png"></p><p>很明显，这样的算法出现了另一个致命性的问题，加入代码执行按照1，5，2，6的顺序执行，则由于双方都提前进行了上锁，所以两个进程都只能处于循环等待的状态，P0和P1最终都无法进入临界区</p><p>综上，后检查法解决了“忙则等待” 的问题，却违背了“空闲让进”和“有限等待”原则，最终会导致饥饿现象的产生</p><h2 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h2><h3 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h3><p>双标志后检查法出现的问题在于最终可能双方都想进入临界区导致互相争夺都无法进入，而Peterson算法为了改进这种情况，提出了“谦让”的方式，主动让对方先使用临界区</p><h3 id="算法示例-2"><a href="#算法示例-2" class="headerlink" title="算法示例"></a>算法示例</h3><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211107173326.png"></p><p>我们再利用异步性来检验当前算法是否能够保证所有原则，假设代码以1，2，3，6，7，8的顺序执行，由于在第三行代码判断时flag[1]=false，所以P0进程能够顺利进入临界区，P1进程需要在第八行代码处等待，直到P0进程释放资源并修改意愿为flag[0]=false，P1进程才能进入临界区</p><p>假设代码以1，6，2，3的顺序执行</p><ol><li>首先经过1和6行代码，P0和P1都表示了想进入临界区的意愿</li><li>P0进程在第二行代码处将turn设为1表示愿意谦让</li><li>随后到第三行代码发现P1进程想要进入临界区并且自己愿意谦让，所以P0开始循环等待</li><li>直到进程切换到P1</li><li>P1继续执行第七行代码修改turn为0</li><li>然后执行第八行代码发现P0想要执行并且自己愿意谦让，P1开始循环等待</li><li>直到进程切换到P0</li><li>P0继续执行第三行代码，发现P1虽然想要执行，但此时P1谦让（turn!=1）所以P0进入临界区</li><li>P0执行完后，修改执行意愿</li><li>P1进入临界区继续执行</li></ol><p>可以看到，P0进程经过三次进程切换才得到成功执行，但由于谦让机制，最终一定会得到执行</p><h3 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h3><p>Peterson算法用软件方法解决了进程互斥问题，遵循了“空闲让进”，“忙则等待”，“有限等待”三个原则。不过依然没有遵循“让权等待”原则</p><h2 id="进程同步的硬件实现方法"><a href="#进程同步的硬件实现方法" class="headerlink" title="进程同步的硬件实现方法"></a>进程同步的硬件实现方法</h2><h3 id="中断屏蔽方法"><a href="#中断屏蔽方法" class="headerlink" title="中断屏蔽方法"></a>中断屏蔽方法</h3><p>利用“开/关中断指令”实现（与原语的实现思想相同，即在某进程开始访问临界区到结束访问位置都不允许被中断，也就不能发生进程切换，因此也不可能发生两个溶蚀访问临界区的情况）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">关中断; //关中断后即不允许当前进程被中断，也必然不会发生进程切换</span><br><span class="line">临界区;</span><br><span class="line">开中断; //直到当前进程访问完临界区，才执行开中断指令，别的进程才有机会上处理机并访问临界区</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>优点：简洁，高效</li><li>缺点：不适用于多处理机，只适用于操作系统内核进程，不适用于用户进程（因为开/关中断指令都只能运行在内核态，这组指令不能让用户随意使用）</li></ul><h3 id="TestAndSet指令"><a href="#TestAndSet指令" class="headerlink" title="TestAndSet指令"></a>TestAndSet指令</h3><p>简称TS指令，也被称为TestAndSetLock（TSL）指令，TSL指令使用硬件实现的，执行的过程中不允许被中断，只能一气呵成。下面是用C语言描述的TSL指令的实现逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 布尔型的共享变量 lock 表示当前临界区是否被加锁</span></span><br><span class="line"><span class="comment">// true表示已加锁，false表示未加锁</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TestAndSet</span><span class="params">(<span class="keyword">bool</span> *lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> old;</span><br><span class="line">    old = *lock; <span class="comment">//old用来存放lock原来的值</span></span><br><span class="line">    *lock = <span class="literal">true</span>; <span class="comment">//无论当前是否已加锁，都将lock设为true</span></span><br><span class="line">    <span class="keyword">return</span> old; <span class="comment">//返回lock原来的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是使用TSL指令实现的互斥算法的逻辑</span></span><br><span class="line"><span class="keyword">while</span> (TestAndSet (&amp;lock)); <span class="comment">//上锁并检查</span></span><br><span class="line">临界区代码段...</span><br><span class="line">lock = <span class="literal">false</span>;  <span class="comment">// 解锁</span></span><br><span class="line">剩余区代码段...</span><br></pre></td></tr></table></figure><p>若刚开始lock是false，则TSL返回的old值为false，不满足循环条件，能够成功进入临界区（此时已经成功在TSL指令内部进行了上锁）。若刚开始lock是true，则执行TSL指令后old的值为true，所以始终进行while循环，直到当前访问临界区的进程在退出区将lock设为false进行解锁</p><p>相比软件实现方法，TSL指令把上锁和检查操作用硬件的方式变成了只能一步执行到底的原子操作，避免了软件实现方法中的逻辑漏洞</p><ul><li>优点：实现简单，避免了软件实现中的逻辑漏洞，适用于多处理机环境</li><li>缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，导致忙等</li></ul><h3 id="Swap指令"><a href="#Swap指令" class="headerlink" title="Swap指令"></a>Swap指令</h3><p>又叫Exchange指令，或XCHG指令。Swap指令是用硬件实现的，执行的过程中不允许被中断，只能一气呵成。以下是用C语言描述其逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swap指令的作用是交换两个变量的值</span></span><br><span class="line">Swap(<span class="keyword">bool</span> *a,<span class="keyword">bool</span> *b)&#123;</span><br><span class="line">    <span class="keyword">bool</span> temp;</span><br><span class="line">    temp=*a;</span><br><span class="line">    *a=*b;</span><br><span class="line">    *b=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是用Swap指令实现互斥的算法逻辑</span></span><br><span class="line"><span class="comment">//lock表示当前临界区是否被加锁</span></span><br><span class="line"><span class="keyword">bool</span> old=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(old==<span class="literal">true</span>)&#123;</span><br><span class="line">    Swap(&amp;lock, &amp;old);</span><br><span class="line">&#125;</span><br><span class="line">临界区代码段...</span><br><span class="line">lock=<span class="literal">false</span>;</span><br><span class="line">剩余区代码段...</span><br></pre></td></tr></table></figure><p>逻辑上来看Swap和TSL指令没有太大区别，都是先记录此时临界区是否上锁，再将上锁标记lock设为true，最后检查old，如果为false则可进入临界区，否则循环等待</p><ul><li>优点：实现简单，避免了软件实现中的逻辑漏洞，适用于多处理机环境</li><li>缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，导致忙等</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;进程同步&quot;&gt;&lt;a href=&quot;#进程同步&quot; class=&quot;headerlink&quot; title=&quot;进程同步&quot;&gt;&lt;/a&gt;进程同步&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;回顾:进程具有异步性的特征，即各个并发执行的进程以各自独立的，不可预知的速度向前推进&lt;/p&gt;
&lt;/</summary>
      
    
    
    
    
    <category term="操作系统" scheme="http://ywrby.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>13-常见调度算法</title>
    <link href="http://ywrby.com/2021/11/06/13-%E5%B8%B8%E8%A7%81%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    <id>http://ywrby.com/2021/11/06/13-%E5%B8%B8%E8%A7%81%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</id>
    <published>2021-11-06T01:12:12.000Z</published>
    <updated>2021-11-06T10:50:34.938Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见调度算法"><a href="#常见调度算法" class="headerlink" title="常见调度算法"></a>常见调度算法</h1><h2 id="FCFS-先来先服务-First-Come-First-Server"><a href="#FCFS-先来先服务-First-Come-First-Server" class="headerlink" title="FCFS-先来先服务 (First Come First Server)"></a>FCFS-先来先服务 (First Come First Server)</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>主要从“公平”角度考虑，类似我们生活中的排队购物现象，先到先服务</p><h3 id="算法规则"><a href="#算法规则" class="headerlink" title="算法规则"></a>算法规则</h3><p>按照作业/进程到达的先后顺序进行服务</p><h3 id="用于作业-进程调度"><a href="#用于作业-进程调度" class="headerlink" title="用于作业/进程调度"></a>用于作业/进程调度</h3><ul><li>用于<strong>作业</strong>调度时：考虑的是哪个作业先到达<strong>后备队列</strong></li><li>用于<strong>进程</strong>调度时：考虑的是哪个进程先到达<strong>就绪队列</strong></li></ul><h3 id="是否可抢占？"><a href="#是否可抢占？" class="headerlink" title="是否可抢占？"></a>是否可抢占？</h3><p>非抢占式算法</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E4%BE%8B%E9%A2%98.jpg" alt="先来先服务例题"></p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点：公平，算法实现简单</li><li>缺点：排在长作业/长进程后面的短作业需要等待很长时间，其带权周转时间很大，对短作业用户体验不好。</li></ul><p>综上即FCFS算法对长作业有利，对短作业不利（例如上面例题种P3作业的带权周转时间达到了很大的8）</p><h3 id="是否会导致饥饿"><a href="#是否会导致饥饿" class="headerlink" title="是否会导致饥饿"></a>是否会导致饥饿</h3><p>饥饿指某进/作业长时间得不到服务</p><p>FCFS算法不会导致饥饿，只要各个任务依序排队，总会轮到响应作业</p><h2 id="SJF-短作业优先-Shortest-Job-First"><a href="#SJF-短作业优先-Shortest-Job-First" class="headerlink" title="SJF-短作业优先 (Shortest Job First)"></a>SJF-短作业优先 (Shortest Job First)</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>追求最少的平均等待时间，最少的平均周转时间，最少的平均带权周转时间</p><h3 id="算法规则-1"><a href="#算法规则-1" class="headerlink" title="算法规则"></a>算法规则</h3><p>最短的作业/进程有限得到服务（这里的最短指的是要求服务时间最短）</p><h3 id="用于作业-进程调度-1"><a href="#用于作业-进程调度-1" class="headerlink" title="用于作业/进程调度"></a>用于作业/进程调度</h3><p>即可用于作业调度，也可用于进程调度，用于进程调度事被称为“短进程优先算法（SPF，Shortest Process First）”</p><h3 id="是否可抢占"><a href="#是否可抢占" class="headerlink" title="是否可抢占"></a>是否可抢占</h3><p>SJF和SPF是非抢占式算法，但是也存在抢占式的版本：最短剩余时间优先算法（SRTN，Shortest Remaining Time Next）</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>非抢占式版本<br><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211106092559.png"></p><p>抢占式版本<br><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211106092914.png"></p><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点：拥有“最短的”平均等待时间，平均周转时间</li><li>缺点：不公平，对短作业有利，对长作业不利。可能产生饥饿现象，另外，由于作业/进程运行时间是由用户提供，并不一定真实，可能产生为了抢夺资源故意使用短作业的现象发生</li></ul><h3 id="是否会导致饥饿-1"><a href="#是否会导致饥饿-1" class="headerlink" title="是否会导致饥饿"></a>是否会导致饥饿</h3><p>会，如果不断有短作业到来，可能使已到达的长作业长时间得不到服务，产生饥饿现象</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211106094107.png"></p><h2 id="HRRN-高响应比优先-Hignest-Response-Ration-Next"><a href="#HRRN-高响应比优先-Hignest-Response-Ration-Next" class="headerlink" title="HRRN-高响应比优先 (Hignest Response Ration Next)"></a>HRRN-高响应比优先 (Hignest Response Ration Next)</h2><h3 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h3><p>要综合考虑作业/进程的等待时间和要求服务时间</p><h3 id="算法规则-2"><a href="#算法规则-2" class="headerlink" title="算法规则"></a>算法规则</h3><p>在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务</p><p>$$响应比=\frac{等待时间+要求服务时间}{要求服务时间}$$</p><h3 id="用于作业-进程调度-2"><a href="#用于作业-进程调度-2" class="headerlink" title="用于作业/进程调度"></a>用于作业/进程调度</h3><p>即可用于作业调度，也可用于进程调度</p><h3 id="是否可抢占-1"><a href="#是否可抢占-1" class="headerlink" title="是否可抢占"></a>是否可抢占</h3><p>非抢占式算法，只有当前运行的作业主动放弃处理机时，才会进行调度</p><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211106100235.png"></p><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点：<ul><li>综合考虑等待时间和运行时间</li><li>等待时间相同时，要求服务时间短的优先（SJF优点）</li><li>要求服务时间相同时，等待时间长的优先（FCFS优点）</li><li>对于长作业来说，随着等待时间越来越久，其响应比会增大，从而避免长作业饥饿</li></ul></li></ul><h3 id="是否会导致饥饿-2"><a href="#是否会导致饥饿-2" class="headerlink" title="是否会导致饥饿"></a>是否会导致饥饿</h3><p>不会</p><h2 id="RR-时间片轮转-Round-Robin"><a href="#RR-时间片轮转-Round-Robin" class="headerlink" title="RR-时间片轮转 (Round-Robin)"></a>RR-时间片轮转 (Round-Robin)</h2><h3 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h3><p>公平轮流为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</p><h3 id="算法思想-4"><a href="#算法思想-4" class="headerlink" title="算法思想"></a>算法思想</h3><p>按照每个进程到达就绪队列的顺序，轮流让每个进程执行一个时间片（如100ms），若进程未在规定时间片内执行完则剥夺其处理机，重新将进程放入就绪队列的队尾重新排队</p><h3 id="用于作业-进程调度-3"><a href="#用于作业-进程调度-3" class="headerlink" title="用于作业/进程调度"></a>用于作业/进程调度</h3><p>用于进程调度（作业只有在被放入内存建立进程后才可能涉及分配处理机时间片）</p><h3 id="是否可抢占-2"><a href="#是否可抢占-2" class="headerlink" title="是否可抢占"></a>是否可抢占</h3><p>若进程未在时间片内运行完，则会被强行剥夺处理及使用权，因此时间片轮转算法属于抢占式算法，由时钟装置发出时钟中断来通知CPU时间片已到</p><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><p>时间片大小为2<br><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/1QQ%E6%88%AA%E5%9B%BE20211106102617.png"></p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/2QQ%E6%88%AA%E5%9B%BE20211106102718.png"></p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/3QQ%E6%88%AA%E5%9B%BE20211106102736.png"></p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211106102745.png"></p><p>时间片大小为5<br><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211106102951.png"></p><ul><li>从上面的时间片为5的示例的运行队列可以看出，在时间片比较大的情况下，RR算法和FCFS算法的运行队列非常相近。如果时间片太大（上面示例超过6时），使得每个进程都可以在一个时间片内完成，则RR算法会退化为FCFS算法，并且会增大进程响应时间，因此时间片不能太大</li><li>另一方面，进程调度是有时间代价（保存恢复运行环境），因此如果时间片太小，会导致进程切换过于频繁，系统花费大量时间处理进程切换，降低系统运行效率，因此时间片也不能太小</li><li>综上，一般情况下，设计时间片时要让切换进程的开销占比不超过1%</li></ul><h3 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h3><ul><li>优点：公平，响应快，适用于分时操作系统</li><li>缺点：由于高频率的进程切换，因此有一定的开销，不区分任务的紧急程度</li></ul><h3 id="是否会导致饥饿-3"><a href="#是否会导致饥饿-3" class="headerlink" title="是否会导致饥饿"></a>是否会导致饥饿</h3><p>不会</p><h2 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h2><h3 id="算法思想-5"><a href="#算法思想-5" class="headerlink" title="算法思想"></a>算法思想</h3><p>随着计算机发展，特别是实时操作系统出现，越来越多的应用场景需要根据任务的紧急程度决定处理顺序</p><h3 id="算法规则-3"><a href="#算法规则-3" class="headerlink" title="算法规则"></a>算法规则</h3><p>调度时选择优先级最高的作业/进程</p><h3 id="用于作业-进程调度-4"><a href="#用于作业-进程调度-4" class="headerlink" title="用于作业/进程调度"></a>用于作业/进程调度</h3><p>即可用于作业调度，也可用于进程调度，甚至可以用到I/O调度中</p><h3 id="是否可抢占-3"><a href="#是否可抢占-3" class="headerlink" title="是否可抢占"></a>是否可抢占</h3><p>抢占式，非抢占式都可以，区别在于非抢占式只能在进程主动放弃处理机资源时进行调度，抢占式则需要在就绪队列发生变化时进行检查，是否有优先级变化是否需要抢占</p><h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><p>非抢占式<br><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/%E9%9D%9E%E6%8A%A2%E5%8D%A0%E5%BC%8FQQ%E6%88%AA%E5%9B%BE20211106173125.png"></p><p>抢占式<br><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/%E6%8A%A2%E5%8D%A0%E5%BC%8FQQ%E6%88%AA%E5%9B%BE20211106173341.png"></p><h3 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点：用优先级区分紧急程度，适用于实时操作系统，可灵活调整对各种作业/进程的偏好承度</li><li>缺点：若不断有高优先级进程到来，会导致低优先级进程发生饥饿</li></ul><h3 id="是否会发生饥饿"><a href="#是否会发生饥饿" class="headerlink" title="是否会发生饥饿"></a>是否会发生饥饿</h3><p>会</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/%E8%A1%A5%E5%85%85QQ%E6%88%AA%E5%9B%BE20211106174305.png"></p><h2 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h2><h3 id="算法思想-6"><a href="#算法思想-6" class="headerlink" title="算法思想"></a>算法思想</h3><p>对其他调度算法的折中权衡</p><h3 id="算法规则-4"><a href="#算法规则-4" class="headerlink" title="算法规则"></a>算法规则</h3><ol><li>设置多级就绪队列，各级队列的优先级从高到低，时间片从小到大</li><li>新进程到达时优先进入第一级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾，如果此时该进程已经处于最低级队列，则重新放回该队列队尾</li><li>只有第k级队列为空时，第k+1级队列的首个进程才会被分配时间片（优先级高的永远抢占运行）</li></ol><h3 id="用于作业-进程调度-5"><a href="#用于作业-进程调度-5" class="headerlink" title="用于作业/进程调度"></a>用于作业/进程调度</h3><p>用于进程调度</p><h3 id="是否可抢占-4"><a href="#是否可抢占-4" class="headerlink" title="是否可抢占"></a>是否可抢占</h3><p>多级反馈队列调度算法是抢占式算法，在k级队列的进程运行过程中，若更高级的队列（1~k-1）中进入新进程，则由于新进程优先级更高，抢占处理机，原k级进程被放回k级队列队尾</p><h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h3><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211106182353.png"></p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/1QQ%E6%88%AA%E5%9B%BE20211106182526.png"><br>首先P1在0时刻到达，进入最高级队列（1级队列），此时没有进程运行，P1占用CPU运行</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/2QQ%E6%88%AA%E5%9B%BE20211106182603.png"><br><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/2QQ%E6%88%AA%E5%9B%BE20211106182624.png"><br><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/3QQ%E6%88%AA%E5%9B%BE20211106182649.png"><br>一级队列时间片大小只有1，在1时刻，P1在运行完一个时间片后，就需要中断运行进入2级就绪队列等待，此时P2进程恰好进入1级队列，由于优先级更高，所以P2进程占用CPU运行一个时间片，运行结束后同样进入2级就绪队列等待<br><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/4QQ%E6%88%AA%E5%9B%BE20211106182707.png"><br><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/5QQ%E6%88%AA%E5%9B%BE20211106182722.png"><br>在2时刻，此时没有更高级进程进入，所以位于2级队列队首的P1进程继续执行，2级队列拥有两个时间片，P1在4时刻中断运行，由于还没有运行结束，所以继续降级进入3级队列等待，4时刻没有新进程到来，所以P2继续占用CPU运行<br><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/6QQ%E6%88%AA%E5%9B%BE20211106182755.png"><br><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/7QQ%E6%88%AA%E5%9B%BE20211106182808.png"><br>在5时刻，P2只运行了一个时间片，但由于此时有新进程P3进入，P3处于更高优先级，所以P3抢占CPU运行，P2只能重新回到2级队列队尾等待<br><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/8QQ%E6%88%AA%E5%9B%BE20211106182826.png"><br>在6时刻，P3进程运行结束，离开队列，此时P2处于更高优先级，所以继续占用CPU运行两个时间片</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/9QQ%E6%88%AA%E5%9B%BE20211106182903.png"></p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211106182935.png"><br>在8时刻，P2运行结束，离开队列，此时P1才能继续占用CPU运行4个时间片，4个时间片后P1仍未运行技术，此时由于P1位于最底层队列，所以P1只能重新回到3级队列队尾进行等待，直到占用CPU运行结束</p><p>综上所述，进程的运行情况为：P1(1)-&gt;P2(1)-&gt;P1(2)-&gt;P2(1)-&gt;p3(1)-&gt;P2(2)-&gt;p1(4)-&gt;p1(1)</p><h3 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点：对所有进程相对公平（FCFS优点），每个新到达的进程都可以很快得到响应（RR优点），短进程只用较少时间就可以完成（SPF优点），不需要事先考虑进程的运行时间（避免用户造假，避免了SPF的缺点），可以灵活调整对各类进程的偏好程度（CPU密集型，I/O密集型）</li><li>缺点：可能会导致饥饿</li></ul><h3 id="是否会导致饥饿-4"><a href="#是否会导致饥饿-4" class="headerlink" title="是否会导致饥饿"></a>是否会导致饥饿</h3><p>是，若不断有新进程到来，则老进程由于进入低优先级队列无法得到执行，进入饥饿状态</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常见调度算法&quot;&gt;&lt;a href=&quot;#常见调度算法&quot; class=&quot;headerlink&quot; title=&quot;常见调度算法&quot;&gt;&lt;/a&gt;常见调度算法&lt;/h1&gt;&lt;h2 id=&quot;FCFS-先来先服务-First-Come-First-Server&quot;&gt;&lt;a href=&quot;#FCF</summary>
      
    
    
    
    
    <category term="操作系统" scheme="http://ywrby.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>12-调度算法的评价指标</title>
    <link href="http://ywrby.com/2021/11/05/12-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/"/>
    <id>http://ywrby.com/2021/11/05/12-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/</id>
    <published>2021-11-05T13:00:57.000Z</published>
    <updated>2021-11-05T13:21:42.956Z</updated>
    
    <content type="html"><![CDATA[<h1 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h1><h3 id="CPU利用率"><a href="#CPU利用率" class="headerlink" title="CPU利用率"></a>CPU利用率</h3><p>指CPU忙碌时间占总时间的比例</p><p>$$利用率=\frac{忙碌的时间}{总时间}$$</p><p>Eg:某计算机只支持单道程序，某个作业刚开始需要在CPU上运行5秒，再用打印机打印输出5秒，之后再执行5秒，才能结束。在此过程中CPU利用率、打印机利用率分别是多少?</p><p>$$CPU利用率=\frac{5+5}{5+5+5}=66.67%$$</p><p>$$打印机利用率=\frac{5}{5+5+5}=33.33%$$</p><h3 id="系统吞吐量"><a href="#系统吞吐量" class="headerlink" title="系统吞吐量"></a>系统吞吐量</h3><p>单位时间内完成作业的数量，对于计算机而言，肯定更希望用尽可能少的时间处理完尽可能多的作业，即系统吞吐量越大越好</p><p>$$系统吞吐量=\frac{总共完成的作业数目}{总共花费的时间总数}(单位：道/秒)$$</p><h3 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h3><p>指从作业被提交给系统开始，到作业完成为止的这段时间间隔。由四部分组成：</p><ul><li>高级调度时间：作业在外存后被队列上等待的时间(在一个作业处理过程中，只会发生一次)</li><li>低级调度时间(就绪态)：进程在就绪队列上等待进程调度的时间。即进程处于就绪态的情况</li><li>运行态：进程在CPU上执行的时间</li><li>阻塞态：进程等待I/O设备操作完成的时间</li></ul><p>(后三种时间在一个作业的整个处理过程种可能发生多次)</p><p>$$单个作业周转时间=作业完成时间-作业提交时间$$<br>$$平均周转时间=\frac{各作业周转时间之和}{作业数}$$</p><h4 id="带权周转时间"><a href="#带权周转时间" class="headerlink" title="带权周转时间"></a>带权周转时间</h4><p>$$带权周转时间=\frac{作业周转时间}{作业实际运行时间}=\frac{作业完成时间-作业提交时间}{作业实际运行的时间}$$</p><p>由上述公式易知带权周转时间必然大于1，带权周转时间与周转时间都是越小越好 </p><p>对于<strong>周转时间相同</strong>的两个作业，实际运行时间长的作业在相同时间内被服务的时间更多，带权周转时间更小，用户满意度更高。</p><p>对于<strong>实际运行时间相同</strong>的两个作业，周转时间短的带权周转时间更小，用户满意度更高。</p><h3 id="等待时间"><a href="#等待时间" class="headerlink" title="等待时间"></a>等待时间</h3><p>指进程/作业处于等待处理机状态的时间之和，等待时间越长，用户满意度越低</p><p>对于<strong>进程</strong>来说，等待时间就是指进程建立后<strong>等待被服务的时间之和</strong>，在<strong>等待I/0完成的期间其实进程也是在被服务的，所以不计入等待时间</strong>。</p><p>对于<strong>作业</strong>来说，不仅要考虑<strong>建立进程后</strong>的等待时间，还要加上<strong>作业在外存后备队列</strong>中等待的时间。</p><p>一个作业总共需要被CPU服务多久，被I/O设备服务多久一般是确定不变的，因此调度算法影响的一般只是任务/进程的等待时间</p><h3 id="响应事件"><a href="#响应事件" class="headerlink" title="响应事件"></a>响应事件</h3><p>指从用户提交请求到首次产生响应所用的时间</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;调度算法的评价指标&quot;&gt;&lt;a href=&quot;#调度算法的评价指标&quot; class=&quot;headerlink&quot; title=&quot;调度算法的评价指标&quot;&gt;&lt;/a&gt;调度算法的评价指标&lt;/h1&gt;&lt;h3 id=&quot;CPU利用率&quot;&gt;&lt;a href=&quot;#CPU利用率&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="操作系统" scheme="http://ywrby.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
