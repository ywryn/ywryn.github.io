<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ywrby Blog</title>
  
  <subtitle>Less is more</subtitle>
  <link href="http://ywrby.com/atom.xml" rel="self"/>
  
  <link href="http://ywrby.com/"/>
  <updated>2023-08-13T03:06:17.823Z</updated>
  <id>http://ywrby.com/</id>
  
  <author>
    <name>Ywrby</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GREEDY ALGORITHMS II</title>
    <link href="http://ywrby.com/2023/08/07/GREEDY-ALGORITHMS-II/"/>
    <id>http://ywrby.com/2023/08/07/GREEDY-ALGORITHMS-II/</id>
    <published>2023-08-07T05:05:58.000Z</published>
    <updated>2023-08-13T03:06:17.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dijkstra’s-algorithm"><a href="#Dijkstra’s-algorithm" class="headerlink" title="Dijkstra’s algorithm"></a>Dijkstra’s algorithm</h1><p><a href="https://www.bilibili.com/video/BV1zz4y1m7Nq">算法图示：Bilibili《最短路径查找—Dijkstra算法》</a></p><p>Dijkstra’s algorithm（迪杰斯特拉算法）是一种用于求解单源最短路径问题的经典算法。该算法可以计算从单个起始节点到图中所有其他节点的最短路径。Dijkstra’s algorithm适用于没有负权边的有向或无向带权图。</p><p>算法的基本思想是从起始节点开始，不断扩展当前已知的最短路径，直到到达目标节点或处理完所有节点。该算法使用一个辅助数组（通常称为距离数组）来保存从起始节点到每个节点的最短路径长度。算法的步骤如下：</p><ol><li>初始化：将起始节点的距离设置为0，其他节点的距离设置为无穷大（表示尚未计算出最短路径）。</li><li>遍历：从起始节点开始，依次选择当前距离数组中距离最小的节点，记为当前节点。</li><li>更新：对于当前节点的所有邻居节点，计算通过当前节点到达它们的路径长度，并与距离数组中的当前最短路径进行比较，如果计算出的路径更短，则更新距离数组。</li><li>标记：将当前节点标记为已处理，继续遍历未被标记的节点，重复步骤2和步骤3，直到所有节点都被处理。</li><li>完成：当所有节点都被标记后，距离数组中的最短路径就是从起始节点到其他所有节点的最短路径。</li></ol><p>Dijkstra’s algorithm保证在没有负权边的情况下能够找到最短路径。然而，如果图中存在负权边，就不能保证得到正确的最短路径，这时候需要使用其他算法，例如Bellman-Ford算法，来处理含有负权边的情况。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dijkstra</span>(<span class="params">graph, start</span>):</span></span><br><span class="line">    num_nodes = <span class="built_in">len</span>(graph)</span><br><span class="line">    visited = [<span class="literal">False</span>] * num_nodes</span><br><span class="line">    distances = [sys.maxsize] * num_nodes</span><br><span class="line">    distances[start] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_nodes):</span><br><span class="line">        <span class="comment"># 在每次循环中，选择距离数组中最小距离的节点进行扩展</span></span><br><span class="line">        min_distance = sys.maxsize</span><br><span class="line">        min_node = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> <span class="built_in">range</span>(num_nodes):</span><br><span class="line">            <span class="comment"># 遍历所有未被访问过的节点，找到距离最小的节点</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> visited[node] <span class="keyword">and</span> distances[node] &lt; min_distance:</span><br><span class="line">                min_distance = distances[node]</span><br><span class="line">                min_node = node</span><br><span class="line"></span><br><span class="line">        visited[min_node] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> neighbor <span class="keyword">in</span> <span class="built_in">range</span>(num_nodes):</span><br><span class="line">            <span class="comment"># 更新与当前节点相邻的节点的最短路径长度</span></span><br><span class="line">            <span class="keyword">if</span> graph[min_node][neighbor] &gt; <span class="number">0</span>:</span><br><span class="line">                new_distance = distances[min_node] + graph[min_node][neighbor]</span><br><span class="line">                <span class="keyword">if</span> new_distance &lt; distances[neighbor]:</span><br><span class="line">                    distances[neighbor] = new_distance</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> distances</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 示例图的邻接矩阵表示</span></span><br><span class="line">    graph = [</span><br><span class="line">        [<span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">4</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">14</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">14</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>],</span><br><span class="line">        [<span class="number">8</span>, <span class="number">11</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">7</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">0</span>]</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    start_node = <span class="number">0</span></span><br><span class="line">    shortest_distances = dijkstra(graph, start_node)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;从节点&#123;&#125;到其他节点的最短距离：&quot;</span>.<span class="built_in">format</span>(start_node))</span><br><span class="line">    <span class="built_in">print</span>(shortest_distances)</span><br></pre></td></tr></table></figure><h2 id="算法正确性"><a href="#算法正确性" class="headerlink" title="算法正确性"></a>算法正确性</h2><p>这个证明过程是关于Dijkstra’s algorithm（迪杰斯特拉算法）在计算最短路径时的正确性。证明使用了归纳法（induction），来说明在算法的每一步中，维持一个不变量（invariant）：对于集合S中的每个节点u，d(u)表示从起始节点s到u的最短路径长度。</p><ol><li><p>基础情况（Base case）：当集合S中只包含起始节点s时（|S| = 1），因为d(s) = 0，所以该情况是显然成立的。</p></li><li><p>归纳假设（Inductive hypothesis）：假设对于集合S的大小为k（k ≥ 1）时，维持不变量成立，即对于集合S中的每个节点u，d(u)是最短s到u的路径长度。</p></li></ol><p>接下来证明对于集合S的大小为k + 1时，维持不变量仍然成立：</p><ol><li><p>选择下一个节点v加入集合S，并考虑加入S时的最后一条边(u, v)。</p></li><li><p>加入节点v后，最短s到v的路径长度为π(v)，π(v)是在加入v之前S中所有节点与u的最短路径长度加上(u, v)路径长度。</p></li><li><p>接下来，考虑任意一条从s到v的路径P。我们要证明，该路径的长度不会小于π(v)。</p></li><li><p>设(x, y)是路径P中第一个离开集合S的边，即从S中的节点x到非S中的节点y的边。然后，P’是从起始节点s到节点x的子路径。</p></li><li><p>由于节点v是在集合S中添加的最后一个节点，所以在路径P’中，节点x是集合S中最后一个被访问的节点。这意味着在路径P’中，任何从S中的节点到节点x的路径都包含了S中所有节点。</p></li><li><p>当路径P到达节点y时，它已经比π(v)要长了。这是因为从S中的任何节点到节点v的路径都已经包含在路径P’中，而加上(u, v)边后，路径长度已经达到π(v)。</p></li></ol><p>综上所述，无论路径P如何选择，其长度都不会小于π(v)。因此，当集合S的大小为k + 1时，维持不变量依然成立。</p><p>由归纳法的原理，对于任意大小的集合S，都能够保持维持不变量：对于集合S中的每个节点u，d(u)是最短s到u的路径长度。这证明了Dijkstra’s algorithm计算最短路径的正确性。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230807211704.jpg"></p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230807211628.jpg"></p><h1 id="最小生成树（minimum-spanning-trees）"><a href="#最小生成树（minimum-spanning-trees）" class="headerlink" title="最小生成树（minimum spanning trees）"></a>最小生成树（minimum spanning trees）</h1><p>最小生成树算法（Minimum Spanning Tree, MST）是一类用于在加权连通图中找到一棵包含所有节点且边权重之和最小的树的算法。MST算法常用于解决优化问题，如网络设计、电力传输等领域。</p><p>常见的MST算法有两种：Kruskal算法和Prim算法。</p><ul><li><p><strong>Kruskal算法</strong>：Kruskal算法是一种贪心算法，通过不断添加边来构建最小生成树。它的基本思想是将图的所有边按照权重从小到大进行排序，然后依次选择最小权重的边，并将其添加到生成树中，同时要确保生成树不形成环路。直到生成树中包含了所有的节点，算法结束。</p></li><li><p><strong>Prim算法</strong>：Prim算法也是一种贪心算法，它从一个初始节点开始，不断地选择与当前生成树相邻且权重最小的边，并将其加入到生成树中。这样的操作会逐步扩展生成树，直到包含了所有的节点，形成最小生成树。</p></li></ul><p>两种算法的选择依赖于具体的问题和数据结构。Kruskal算法更适用于稀疏图，而Prim算法更适用于稠密图。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>Path：通路</li><li>Cycle：环</li><li>Cut：割，割边。割是将图的所有节点划分成两个非空的子集S和V-S（其中V是图中所有节点的集合，S和V-S是两个非空的互斥子集），简言之就是通过割可以将一副连通图变为一副非连通图（或者说两幅图）</li><li>Cutset：割边集，割集。实现割过程的所有边的集合，在图论中一般是尝试求最小割集</li></ul><p>下图就是切割{4,5,8}子集所形成的割集</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230808094123.jpg"></p><blockquote><p>命题：环和割集相交于偶数条边</p></blockquote><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230808094357.jpg"></p><h2 id="生成树属性"><a href="#生成树属性" class="headerlink" title="生成树属性"></a>生成树属性</h2><p>令 T = (V, F) 为 G = (V, E) 的子图。 TFAE： </p><ul><li>T 是G的生成树</li><li>T 是无环且连通的</li><li>T 是连通的并且有 n – 1 条边</li><li>T 是非循环的并且有 n – 1 条边</li><li>T 是最小连接：移除任何边缘都会将其断开</li><li>T 是最大非循环的：任何边的相加都会创建一个循环</li><li>T 在每对节点之间都有一条唯一的简单路径</li></ul><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230808094653.jpg"></p><h2 id="最小生成树属性"><a href="#最小生成树属性" class="headerlink" title="最小生成树属性"></a>最小生成树属性</h2><p>最小生成树本质还是生成树，最重要的一条属性就是边权重之和最小，是最优情况下的生成树</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230808100439.jpg"></p><h2 id="贪心算法（涂色）"><a href="#贪心算法（涂色）" class="headerlink" title="贪心算法（涂色）"></a>贪心算法（涂色）</h2><ul><li>红色规则：<ul><li>设C是一个没有红边的环</li><li>选择最大权重的 C 的未着色边缘并将其着色为红色</li></ul></li><li>蓝色规则：<ul><li>设 D 为没有蓝边的割集</li><li>在最小重量的 D 中选择一条未着色的边缘并将其着色为蓝色</li></ul></li></ul><h3 id="Greedy-Template"><a href="#Greedy-Template" class="headerlink" title="Greedy Template"></a>Greedy Template</h3><ul><li>不断应用Red rule和Blue rule（非确定性地！）直到所有的边都被着色。</li><li>这意味着我们在图中找到了所有没有形成环路的边，并且选择了最小的割边，将它们标记为蓝色。</li><li>最终，所有形成最小生成树的边都被标记为蓝色。</li><li>注意：在选择蓝色边的过程中，可以在边的数目达到n-1时停止，因为最小生成树总是有n-1条边（其中n是图中节点的数目）。</li></ul><h1 id="Prim’s-algorithm"><a href="#Prim’s-algorithm" class="headerlink" title="Prim’s algorithm"></a>Prim’s algorithm</h1><p><a href="https://www.bilibili.com/video/BV1Eb41177d1">算法图示：Bilibili《最小生成树Kruskal和Prim算法动画演示》</a></p><p>Prim’s algorithm（普里姆算法）是用于解决最小生成树（Minimum Spanning Tree, MST）问题的一种常用贪心算法。它通过逐步添加节点来构建最小生成树，并保证最终生成的树是整个图中权重之和最小的树。</p><p>算法步骤如下：</p><ol><li>初始化：选择一个起始节点作为树的根节点，将其加入到最小生成树中。同时，将所有其他节点标记为未访问状态，并将它们的权重设置为一个较大的值（或者设置为正无穷大）。</li><li>选取节点：从未访问的节点中选择一个<strong>与最小生成树中节点相邻且权重最小</strong>的节点，将其加入最小生成树，并将其标记为已访问。</li><li>更新权重：对于新加入最小生成树的节点，更新其与未访问节点之间的权重值。如果新的权重值比原先的权重值更小，则更新该节点的权重。</li><li>重复步骤2和步骤3，直到所有节点都被加入最小生成树中。</li><li>最小生成树构建完成。</li></ol><p>Prim’s algorithm的关键在于不断地选取权重最小的节点，并更新相关节点的权重。它保证了每次选择的节点都是与最小生成树相邻且权重最小的节点，从而逐步构建出整个图的最小生成树。</p><p>Prim’s algorithm适用于稠密图，即节点之间的边相对较多的情况。在实现上，通常使用优先级队列（最小堆）来维护未访问节点的权重，并通过快速查找和更新节点的权重来加速算法的执行。</p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prim</span>(<span class="params">graph</span>):</span></span><br><span class="line">    num_nodes = <span class="built_in">len</span>(graph)</span><br><span class="line">    visited = [<span class="literal">False</span>] * num_nodes</span><br><span class="line">    min_heap = [(<span class="number">0</span>, <span class="number">0</span>)]  <span class="comment"># 最小堆，用于存储权重和节点的元组</span></span><br><span class="line"></span><br><span class="line">    mst = []  <span class="comment"># 最小生成树的边</span></span><br><span class="line">    total_weight = <span class="number">0</span>  <span class="comment"># 最小生成树的总权重</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> min_heap:</span><br><span class="line">        weight, node = heapq.heappop(min_heap)  <span class="comment"># 从堆中弹出最小权重的节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> visited[node]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        visited[node] = <span class="literal">True</span>  <span class="comment"># 标记节点为已访问</span></span><br><span class="line">        total_weight += weight</span><br><span class="line">        mst.append((weight, node))  <span class="comment"># 将权重和节点添加到最小生成树的边列表中</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> neighbor, weight <span class="keyword">in</span> graph[node]:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> visited[neighbor]:</span><br><span class="line">                heapq.heappush(min_heap, (weight, neighbor))  <span class="comment"># 将与当前节点相邻且未访问的节点添加到堆中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mst, total_weight</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 示例图的邻接表表示</span></span><br><span class="line">    graph = &#123;</span><br><span class="line">        <span class="number">0</span>: [(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">3</span>)],</span><br><span class="line">        <span class="number">1</span>: [(<span class="number">0</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">4</span>)],</span><br><span class="line">        <span class="number">2</span>: [(<span class="number">1</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">5</span>)],</span><br><span class="line">        <span class="number">3</span>: [(<span class="number">0</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>)]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mst, total_weight = prim(graph)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;最小生成树边的列表及其权重：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(mst)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;最小生成树的总权重：&quot;</span>, total_weight)</span><br></pre></td></tr></table></figure><h1 id="Kruskal’s-algorithm"><a href="#Kruskal’s-algorithm" class="headerlink" title="Kruskal’s algorithm"></a>Kruskal’s algorithm</h1><p>Kruskal算法是一种常用的贪婪算法，用于寻找连通无向图的最小生成树（MST）。</p><p>以下是Kruskal算法的工作原理概述：</p><ol><li><p><strong>初始化：</strong> 从一个空的边集合开始，这个集合最终会构成最小生成树。</p></li><li><p><strong>排序：</strong> 将图的所有边按照权重升序排序。</p></li><li><p><strong>迭代：</strong> 逐个遍历排序后的边。对于每一条边：</p><ul><li>如果将该边加入当前选择的边集合（即已构建的树）不会产生环路，就将边添加到树中。</li><li>否则，跳过该边，继续处理下一条边。</li></ul></li><li><p><strong>完成：</strong> 重复步骤3，直到最小生成树中的边数等于顶点数减1（因为一个生成树有V-1条边，其中V为顶点数）。</p></li></ol><p>Kruskal算法确保加入的边不会在生成树中引起循环，这使得它成为一种安全的选择。算法会继续添加权重最小的边，同时避免产生循环，从而形成最小生成树。</p><p>在算法过程中通常会使用并查集数据结构（也称为并查集数据结构）来有效地检测循环。这个数据结构有助于追踪哪些顶点已经属于生成树，哪些顶点尚未连接。</p><p>Kruskal算法高效，其时间复杂度为O(E log E)，其中E为图中的边数。这主要归因于排序步骤，它需要O(E log E)时间，而后续步骤需要额外的线性时间。</p><p>总之，Kruskal算法通过迭代地添加权重最小的边，同时避免产生循环，从而找到连通无向图的最小生成树。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 并查集实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        self.parent = <span class="built_in">list</span>(<span class="built_in">range</span>(n))  <span class="comment"># 初始化每个节点的父节点为自身</span></span><br><span class="line">        self.rank = [<span class="number">0</span>] * n  <span class="comment"># 初始化每个节点的秩为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查找节点x所属的集合的代表节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.parent[x] != x:</span><br><span class="line">            self.parent[x] = self.find(self.parent[x])  <span class="comment"># 通过递归路径压缩来优化查找过程</span></span><br><span class="line">        <span class="keyword">return</span> self.parent[x]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 合并两个集合</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        root_x = self.find(x)</span><br><span class="line">        root_y = self.find(y)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果两个节点在同一个集合中，实际就表示形成了环</span></span><br><span class="line">        <span class="keyword">if</span> root_x == root_y:  <span class="comment"># 如果两个节点已经在同一集合中，不需要合并</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> self.rank[root_x] &lt; self.rank[root_y]:  <span class="comment"># 将秩较小的集合合并到秩较大的集合中</span></span><br><span class="line">            self.parent[root_x] = root_y</span><br><span class="line">        <span class="keyword">elif</span> self.rank[root_x] &gt; self.rank[root_y]:</span><br><span class="line">            self.parent[root_y] = root_x</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.parent[root_y] = root_x</span><br><span class="line">            self.rank[root_x] += <span class="number">1</span>  <span class="comment"># 如果秩相等，合并后秩增加</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Kruskal算法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kruskal</span>(<span class="params">edges, n</span>):</span></span><br><span class="line">    edges.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">2</span>])  <span class="comment"># 将边按照权重升序排序</span></span><br><span class="line">    uf = UnionFind(n)  <span class="comment"># 创建并查集对象</span></span><br><span class="line">    min_spanning_tree = []  <span class="comment"># 用于存储最小生成树的边</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> edge <span class="keyword">in</span> edges:</span><br><span class="line">        u, v, weight = edge</span><br><span class="line">        <span class="keyword">if</span> uf.union(u, v):  <span class="comment"># 如果边的两个节点不在同一集合中，合并集合并将边添加到最小生成树中</span></span><br><span class="line">            min_spanning_tree.append(edge)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> min_spanning_tree</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例数据</span></span><br><span class="line">edges = [</span><br><span class="line">    (<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>),</span><br><span class="line">    (<span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>),</span><br><span class="line">    (<span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>),</span><br><span class="line">    (<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>),</span><br><span class="line">    (<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>),</span><br><span class="line">    (<span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>),</span><br><span class="line">    (<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>),</span><br><span class="line">    (<span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>)  <span class="comment"># 注意这里的有向边形成了环</span></span><br><span class="line">]</span><br><span class="line">num_vertices = <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行Kruskal算法</span></span><br><span class="line">minimum_spanning_tree = kruskal(edges, num_vertices)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Minimum Spanning Tree:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> edge <span class="keyword">in</span> minimum_spanning_tree:</span><br><span class="line">    <span class="built_in">print</span>(edge)</span><br></pre></td></tr></table></figure><p>上述代码通过定义并查集来简化Kruskal算法过程中的添加边过程和检测环路过程（如果两个点本身就在同一个集合内，就表明它们当前已经有一条能够相互连接的通路，此时再加入它们两个顶点的直接连接路径就会构成环路）</p><p><a href="https://www.bilibili.com/video/BV1k14y1E7Uh">并查集图示</a></p><h1 id="Reverse-delete-algorithm"><a href="#Reverse-delete-algorithm" class="headerlink" title="Reverse-delete algorithm"></a>Reverse-delete algorithm</h1><p>Reverse-delete算法是一种用于找到图的最小生成树（MST）的算法，与Kruskal算法相似。与Kruskal从小到大按权重选择边来构建MST不同，Reverse-delete算法从大到小按权重删除边来构建MST。这个算法首先将所有边按权重降序排列，然后依次删除边，每次删除都会检查是否导致图的断开。如果删除边后图仍然是连通的，说明这条边不是构成MST所必需的，可以被删除。</p><p>以下是Reverse-delete算法的步骤：</p><ol><li>对图的所有边按权重从大到小进行排序。</li><li>从最重的边开始，依次删除边，并检查删除后图是否仍然是连通的。</li><li>如果删除边后图仍然是连通的，说明这条边不是MST必需的，将其删除。否则，保留这条边。</li><li>重复步骤3，继续删除边，直到只剩下V-1条边为止，其中V是图的顶点数。此时，得到的边集合构成了图的最小生成树。</li></ol><p>与Kruskal算法不同，Reverse-delete算法不需要检测环路，因为每次删除边后图总是连通的。然而，这个算法需要进行图的连通性检查，以确保删除边后图仍然保持连通。</p><p>需要注意的是，Reverse-delete算法可能对于稠密图（边数较多）的效率不如Kruskal算法，因为删除边的过程可能会涉及到多次图的连通性检查。</p><p>总之，Reverse-delete算法是一种寻找图最小生成树的方法，通过从大到小按权重删除边来逐步构建最小生成树。</p><h1 id="Boruvka’s-algorithm"><a href="#Boruvka’s-algorithm" class="headerlink" title="Borůvka’s algorithm"></a>Borůvka’s algorithm</h1><p>Borůvka’s algorithm（博鲁夫卡算法）是一种用于寻找图的最小生成树（MST）的算法。它是一种并行算法，旨在充分利用多个处理单元或计算机来加速计算。这个算法也被称为Sollin’s algorithm（索林算法）或Sarnowski’s algorithm（萨诺夫斯基算法）。</p><p>Borůvka’s算法适用于无向图的最小生成树问题，其基本思想是通过从每个连通组件中选择一个最小权重的边，然后将连通组件合并，最终构建出整个图的最小生成树。</p><p>以下是Borůvka’s算法的步骤：</p><p>将每个顶点作为一个单独的连通组件。<br>重复以下步骤，直到只剩下一个连通组件（即构建完整的最小生成树）：<br>对于每个连通组件，选择连接该组件的最小权重的边。<br>将这些最小权重边所连接的顶点合并为一个新的连通组件。<br>删除所有不再需要的边。<br>Borůvka’s算法的一个关键特点是它可以并行地处理多个连通组件，因此在具备多个处理单元或计算机的情况下，它可以实现较高的计算效率。</p><p>需要注意的是，Borůvka’s算法可能在稠密图（边数较多）上表现得更好，因为它在每个迭代步骤中可以并行地处理多个连通组件。</p><p>虽然Borůvka’s算法在理论上是一个有效的算法，但在实际应用中，由于现代计算机系统和并行算法的复杂性，它可能不如其他算法（如Kruskal、Prim算法）在实践中运行得快速和高效。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Dijkstra’s-algorithm&quot;&gt;&lt;a href=&quot;#Dijkstra’s-algorithm&quot; class=&quot;headerlink&quot; title=&quot;Dijkstra’s algorithm&quot;&gt;&lt;/a&gt;Dijkstra’s algorithm&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="UOA" scheme="http://ywrby.com/categories/UOA/"/>
    
    <category term="COMPSCI 320" scheme="http://ywrby.com/categories/UOA/COMPSCI-320/"/>
    
    
    <category term="算法" scheme="http://ywrby.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>GREEDY ALGORITHMS</title>
    <link href="http://ywrby.com/2023/08/05/GREEDY-ALGORITHMS/"/>
    <id>http://ywrby.com/2023/08/05/GREEDY-ALGORITHMS/</id>
    <published>2023-08-05T09:30:05.000Z</published>
    <updated>2023-08-07T05:03:04.327Z</updated>
    
    <content type="html"><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><p>贪心算法（Greedy Algorithm）是一种常见的优化算法，用于解决一类最优化问题。在每一步选择中，贪心算法总是选择当前看起来最优的选择，而不考虑该选择会不会影响未来的选择。这种贪心选择的策略通常是局部最优的，但不一定是全局最优的。</p><p>贪心算法适用于一些特定类型的问题，特别是那些具有贪心选择性质和最优子结构性质的问题。贪心选择性质是指每一步的局部最优选择最终能够导致全局最优解。最优子结构性质是指问题的最优解包含子问题的最优解。</p><p>贪心算法的基本思想如下：</p><ol><li>首先定义问题的优化目标，明确要求找到最大值或最小值。</li><li>从问题的所有可选解中，选择一个局部最优解，作为当前的选择。</li><li>接着，检查该局部最优解是否满足问题的约束条件和要求。</li><li>如果满足约束条件和要求，则将该局部最优解加入到最终解集合中。</li><li>否则，舍弃该局部最优解，并回到第2步，继续选择下一个局部最优解。</li><li>最终得到的解集合就是整个问题的全局最优解。</li></ol><p>需要注意的是，贪心算法并不适用于所有类型的问题。在某些问题中，贪心算法可能会得到次优解或者不正确的结果。因此，在应用贪心算法时，必须要确保问题具有贪心选择性质和最优子结构性质，并进行充分的验证和证明。</p><h1 id="硬币兑换问题（Coin-changing）"><a href="#硬币兑换问题（Coin-changing）" class="headerlink" title="硬币兑换问题（Coin changing）"></a>硬币兑换问题（Coin changing）</h1><p>给定货币面额：1、5、10、25、100，设计一种使用最少数量的硬币向客户支付金额的方法</p><h2 id="收银员算法（Cashier’s-algorithm）"><a href="#收银员算法（Cashier’s-algorithm）" class="headerlink" title="收银员算法（Cashier’s algorithm）"></a>收银员算法（Cashier’s algorithm）</h2><p>在每次迭代中，添加最大价值的硬币，这不会让我们超过要支付的金额</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cashier_algorithm</span>(<span class="params">amount, coins</span>):</span></span><br><span class="line">    coins.sort(reverse=<span class="literal">True</span>)  <span class="comment"># 将硬币面额按降序排列</span></span><br><span class="line">    change = []</span><br><span class="line">    remaining_amount = amount</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从硬币最高金额开始遍历</span></span><br><span class="line">    <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">        <span class="comment"># 最多能使用几个当前最大面额硬币支付剩余部分金额</span></span><br><span class="line">        num_of_coins = remaining_amount // coin</span><br><span class="line">        <span class="comment"># 减去支付硬币总金额，获得剩余金额</span></span><br><span class="line">        remaining_amount -= num_of_coins * coin</span><br><span class="line">        <span class="comment"># 向找零列表里添加相应的硬币</span></span><br><span class="line">        change.extend([coin] * num_of_coins)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> change</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试例子</span></span><br><span class="line">amount_to_pay = <span class="number">68</span></span><br><span class="line">currency_coins = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>, <span class="number">100</span>]</span><br><span class="line">result = cashier_algorithm(amount_to_pay, currency_coins)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出结果：[25, 25, 10, 5, 1, 1, 1]</span></span><br></pre></td></tr></table></figure><h2 id="最优解的性质"><a href="#最优解的性质" class="headerlink" title="最优解的性质"></a>最优解的性质</h2><table><thead><tr><th>k</th><th>Ck</th><th>all optimal solutions must satisfy</th><th>max value of coins c1, c2, …, ck–1 in any OPT</th></tr></thead><tbody><tr><td>1</td><td>1/P</td><td>P&lt;=4</td><td>-</td></tr><tr><td>2</td><td>5/N</td><td>N&lt;=1</td><td>4</td></tr><tr><td>3</td><td>10/D</td><td>N+D&lt;=2</td><td>4+5=9</td></tr><tr><td>4</td><td>25/Q</td><td>Q&lt;=3</td><td>20+4=24</td></tr><tr><td>5</td><td>100</td><td>no limit</td><td>75+24=99</td></tr></tbody></table><p>P表示Pennies（1分钱），N表示Nickels（5分钱），最优解的条件就是所找的零钱数已经是最少的，不能有更少情况产生。例如第一行所示情况，超过四个P存在的话就可以利用5个P合成一个N，而第三行N和D不能同时存在两个以上是由于1N+2D-&gt;1Q，2N+D-&gt;2D，都存在更少硬币的解决方案</p><h2 id="收银员算法是最优的么"><a href="#收银员算法是最优的么" class="headerlink" title="收银员算法是最优的么"></a>收银员算法是最优的么</h2><p>不是，对于很多情况，收银员算法都不是最优的</p><h3 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h3><p>美国邮戳: 1, 10, 21, 34, 70, 100, 350, 1225, 1500。现在要考虑找回客人140元</p><ul><li>收银员算法的结果：140 = 100 + 34 + 1 + 1 + 1 + 1 + 1 + 1.</li><li>实际最优结果：140 = 70 +70.</li></ul><h3 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h3><p>甚至某些情况下收银员算法都不能找到有效的解</p><p>硬币种类：7，8，9。现在考虑找回客人15元</p><ul><li>收银员算法的结果：15 = 9 + ???</li><li>实际最优结果：15 = 8 + 7</li></ul><h1 id="间隔调度问题（interval-scheduling）"><a href="#间隔调度问题（interval-scheduling）" class="headerlink" title="间隔调度问题（interval scheduling）"></a>间隔调度问题（interval scheduling）</h1><ul><li>工作$j$在$s_j$时开始，在$f_j$时结束</li><li>我们说两个工作是兼容（compatible）的，如果它们相互之间没有重叠（overlap）</li></ul><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>找到相互兼容的工作的最大子集</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230806170648.png"></p><h2 id="Greedy-template"><a href="#Greedy-template" class="headerlink" title="Greedy template"></a>Greedy template</h2><p>以某种自然顺序考虑工作。接受每份工作，前提是它与已经接受的工作兼容</p><h3 id="最早开始时间（Earliest-start-time）"><a href="#最早开始时间（Earliest-start-time）" class="headerlink" title="最早开始时间（Earliest start time）"></a>最早开始时间（Earliest start time）</h3><p>按照开始时间排序，从最早开始的工作依次考虑</p><h3 id="最早结束时间（Earliest-finish-time）"><a href="#最早结束时间（Earliest-finish-time）" class="headerlink" title="最早结束时间（Earliest finish time）"></a>最早结束时间（Earliest finish time）</h3><p>按照结束时间排序，从最早结束的工作依次考虑</p><h3 id="最短间隔（Shortest-interval）"><a href="#最短间隔（Shortest-interval）" class="headerlink" title="最短间隔（Shortest interval）"></a>最短间隔（Shortest interval）</h3><p>按照间隔时间$f_j-s_j$排序，从间隔最短的工作开始依次考虑</p><h3 id="最少冲突（Fewest-conflicts）"><a href="#最少冲突（Fewest-conflicts）" class="headerlink" title="最少冲突（Fewest conflicts）"></a>最少冲突（Fewest conflicts）</h3><p>对于每项工作，统计与其冲突的工作的数量，并按照冲突数从小到大排序，从冲突最少的工作开始考虑</p><p>最早开始，最短间隔和最少冲突都不是最优的，其反例如下：</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230806171545.png"></p><h2 id="最早结束时间（EFT）算法实现"><a href="#最早结束时间（EFT）算法实现" class="headerlink" title="最早结束时间（EFT）算法实现"></a>最早结束时间（EFT）算法实现</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">earliest_finish_time</span>(<span class="params">schedules</span>):</span></span><br><span class="line">    <span class="comment"># 将活动按结束时间进行排序</span></span><br><span class="line">    sorted_schedules = <span class="built_in">sorted</span>(schedules, key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 选择的活动列表</span></span><br><span class="line">    selected_activities = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当前结束时间</span></span><br><span class="line">    current_end_time = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历排序后的活动</span></span><br><span class="line">    <span class="keyword">for</span> activity <span class="keyword">in</span> sorted_schedules:</span><br><span class="line">        start_time, end_time = activity</span><br><span class="line">        <span class="comment"># 如果活动的开始时间晚于或等于当前结束时间，则选择该活动</span></span><br><span class="line">        <span class="keyword">if</span> start_time &gt;= current_end_time:</span><br><span class="line">            selected_activities.append(activity)</span><br><span class="line">            current_end_time = end_time</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> selected_activities</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例活动列表，每个元组表示一个活动的开始和结束时间</span></span><br><span class="line">activities = [(<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>), (<span class="number">5</span>, <span class="number">7</span>), (<span class="number">4</span>, <span class="number">8</span>), (<span class="number">8</span>, <span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line">selected_activities = earliest_finish_time(activities)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Selected activities:&quot;</span>, selected_activities)</span><br></pre></td></tr></table></figure><h2 id="EFT分析"><a href="#EFT分析" class="headerlink" title="EFT分析"></a>EFT分析</h2><p>假设我们有一组按结束时间排序的活动集合S={1,2,…,n}，其中每个活动i具有开始时间si和结束时间fi，且$f_i&lt;=f_{i+1}$。</p><p>现在我们想要证明选择最早结束时间的活动总是安全的，即它总是包含在某个最大兼容活动集合中。</p><ol><li><p><strong>贪心选择性质</strong>：假设 A 是活动集合 S 的最大兼容活动集合，活动1具有最早的结束时间。我们的目标是证明活动1总是包含在 A 的最优解中。</p></li><li><p><strong>数学归纳</strong>：</p><ul><li><p><strong>基本情况</strong>：如果只有一个活动，则选择它是显而易见的最优解。</p></li><li><p><strong>归纳步骤</strong>：假设对于 k &lt; n 的情况，选择最早结束的活动总是最优的。现在我们考虑有 n 个活动的情况。</p></li></ul></li><li><p><strong>交换论证</strong>：假设活动1不在最优解 A 中，让活动 k 是 A 中结束最早的活动。由于活动1和活动 k 的结束时间不冲突，并且活动1的结束时间早于活动 k ，我们可以将活动1替换为活动 k 并获得另一个兼容活动集合。由于我们并没有减少活动的数量，因此新的解至少与原始解一样好。</p></li><li><p><strong>结论</strong>：通过反证法和归纳基础，我们证明了选择最早结束的活动总是最优的选择，并且总是存在于最大兼容活动集合的最优解中。</p></li></ol><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230806174729.png"></p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230806175223.png"></p><h1 id="间隔划分问题（Interval-partitioning）"><a href="#间隔划分问题（Interval-partitioning）" class="headerlink" title="间隔划分问题（Interval partitioning）"></a>间隔划分问题（Interval partitioning）</h1><p>区间划分问题（Interval Partitioning Problem）是一类组合优化问题，涉及将一组给定的时间区间分配给一组有限的资源，以便满足某些约束条件。这类问题在日程安排、会议室预订、频谱分配等多个领域都有应用。</p><p>基本区间划分问题是指给定一组活动或任务，每个都有开始时间和结束时间。目标是将这些活动分配给尽可能少的资源（例如会议室、机器等），同时确保没有两个在同一资源上分配的活动在时间上重叠。</p><blockquote><p>例如，假设你有一系列会议，并且需要找到最少数量的会议室，以便所有会议都可以在没有时间冲突的情况下进行。这就是区间划分问题的一个典型实例。</p></blockquote><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230806180232.png"></p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230806180313.png"></p><h2 id="Greedy-template-1"><a href="#Greedy-template-1" class="headerlink" title="Greedy template"></a>Greedy template</h2><h3 id="最早开始时间（Earliest-start-time）-1"><a href="#最早开始时间（Earliest-start-time）-1" class="headerlink" title="最早开始时间（Earliest start time）"></a>最早开始时间（Earliest start time）</h3><p>按照开始时间排序，从最早开始的工作依次考虑</p><h3 id="最早结束时间（Earliest-finish-time）-1"><a href="#最早结束时间（Earliest-finish-time）-1" class="headerlink" title="最早结束时间（Earliest finish time）"></a>最早结束时间（Earliest finish time）</h3><p>按照结束时间排序，从最早结束的工作依次考虑</p><h3 id="最短间隔（Shortest-interval）-1"><a href="#最短间隔（Shortest-interval）-1" class="headerlink" title="最短间隔（Shortest interval）"></a>最短间隔（Shortest interval）</h3><p>按照间隔时间$f_j-s_j$排序，从间隔最短的工作开始依次考虑</p><h3 id="最少冲突（Fewest-conflicts）-1"><a href="#最少冲突（Fewest-conflicts）-1" class="headerlink" title="最少冲突（Fewest conflicts）"></a>最少冲突（Fewest conflicts）</h3><p>对于每项工作，统计与其冲突的工作的数量，并按照冲突数从小到大排序，从冲突最少的工作开始考虑</p><p>最早结束，最短间隔和最少冲突都不是最优的，相应的反例如下图所示：</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230806180512.png"></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">earliest_start_time</span>(<span class="params">jobs</span>):</span></span><br><span class="line">    <span class="comment"># 按照开始时间对工作进行排序</span></span><br><span class="line">    sorted_jobs = <span class="built_in">sorted</span>(jobs, key=<span class="keyword">lambda</span> job: job[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化一个列表来存储分组结果</span></span><br><span class="line">    partitions = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> job <span class="keyword">in</span> sorted_jobs:</span><br><span class="line">        added_to_partition = <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 遍历现有分组，找到第一个没有时间冲突的分组，将工作添加进去</span></span><br><span class="line">        <span class="keyword">for</span> partition <span class="keyword">in</span> partitions:</span><br><span class="line">            <span class="keyword">if</span> job[<span class="number">0</span>] &gt;= partition[-<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                partition.append(job)</span><br><span class="line">                added_to_partition = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 如果没有找到可以加入的现有分组，就创建一个新的分组</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> added_to_partition:</span><br><span class="line">            partitions.append([job])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> partitions</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 示例工作列表，每个工作由开始时间和结束时间构成</span></span><br><span class="line">    jobs = [(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">6</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">7</span>, <span class="number">10</span>), (<span class="number">8</span>, <span class="number">11</span>), (<span class="number">9</span>, <span class="number">12</span>), (<span class="number">5</span>, <span class="number">8</span>)]</span><br><span class="line"></span><br><span class="line">    result = earliest_start_time(jobs)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;工作分组结果:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i, partition <span class="keyword">in</span> <span class="built_in">enumerate</span>(result):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;分组 <span class="subst">&#123;i+<span class="number">1</span>&#125;</span>: <span class="subst">&#123;partition&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="EST分析"><a href="#EST分析" class="headerlink" title="EST分析"></a>EST分析</h2><p><strong>定理</strong>: 最早开始时间优先算法是最优的。</p><p><strong>证明</strong>:</p><ul><li><strong>定义</strong>：令 $d$ 等于算法分配的教室数量。</li><li><strong>步骤 1</strong>：教室 $d$ 是开放的，因为我们需要安排一次讲座，比如讲座 $j$，与前 $d - 1$ 个教室中的所有讲座都不兼容。</li><li><strong>步骤 2</strong>：这 $d$ 门讲座都在讲座 $j$ 的开始时间 $s_j$ 之后结束。</li><li><strong>步骤 3</strong>：由于我们按开始时间排序，所以所有这些不兼容性都是由不晚于 $s_j$ 开始的讲座引起的。</li><li><strong>步骤 4</strong>：因此，在时间 $s_j + \varepsilon$（其中 $\varepsilon$ 是一个很小的正数），我们有 $d$ 门讲座重叠。</li><li><strong>关键观察</strong>：所有时间表都使用了 $\geq d$ 个教室。</li></ul><p>这个证明基于一系列逻辑步骤，通过观察在时间 $s_j + \varepsilon$ 有 $d$ 门讲座重叠的事实，得出至少需要 $d$ 个教室的结论。由于EST算法使用了恰好 $d$ 个教室，所以它是最优的。</p><h1 id="最小化迟到问题（Scheduling-to-minimizing-lateness）"><a href="#最小化迟到问题（Scheduling-to-minimizing-lateness）" class="headerlink" title="最小化迟到问题（Scheduling to minimizing lateness）"></a>最小化迟到问题（Scheduling to minimizing lateness）</h1><p>“Minimizing Lateness Problem”（最小化延迟问题）是一种经典的调度问题，要求在一个资源同时处理一个作业的情况下，安排作业的执行顺序，以最小化最大延迟（maximum lateness）。</p><p>在这个问题中，每个作业有三个关键时间参数：</p><ol><li>tᵢ：作业 j 需要 tᵢ 单位的处理时间。</li><li>dᵢ：作业 j 的截止时间（deadline），即作业必须在 dᵢ 时刻之前完成。</li><li>sᵢ：作业 j 的开始时间（start time），即作业从 sᵢ 时刻开始执行。</li></ol><p>如果作业在其截止时间之前完成，其延迟（lateness）为0；如果作业在截止时间之后完成，其延迟为正值，表示作业的延迟时间。每个作业的延迟 ℓᵢ 可以通过以下公式计算：<br>ℓᵢ = max{0, fᵢ - dᵢ}</p><p>其中 fᵢ = sᵢ + tᵢ 表示作业 j 的完成时间。</p><p>目标是找到一个作业的执行顺序，使得所有作业的最大延迟 L = maxᵢ ℓᵢ 最小化。</p><p>这个问题属于NP-hard问题，通常使用贪心算法或动态规划等近似算法来求解。</p><p>总之，最小化延迟问题是一个重要的调度问题，需要通过适当的算法来安排作业的执行顺序，以最小化整体延迟，从而提高任务执行的效率和及时性。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230807112303.png"></p><h2 id="Greedy-template-2"><a href="#Greedy-template-2" class="headerlink" title="Greedy template"></a>Greedy template</h2><h3 id="处理时间最短优先（Shortest-processing-time-first）"><a href="#处理时间最短优先（Shortest-processing-time-first）" class="headerlink" title="处理时间最短优先（Shortest processing time first）"></a>处理时间最短优先（Shortest processing time first）</h3><p>按处理时间tj升序安排作业顺序</p><h3 id="最早截止日期优先（Earliest-deadline-first）"><a href="#最早截止日期优先（Earliest-deadline-first）" class="headerlink" title="最早截止日期优先（Earliest deadline first）"></a>最早截止日期优先（Earliest deadline first）</h3><p>按照截止日期dj从早到晚排序，以此顺序安排作业</p><h3 id="最紧迫优先（Smallest-slack）"><a href="#最紧迫优先（Smallest-slack）" class="headerlink" title="最紧迫优先（Smallest slack）"></a>最紧迫优先（Smallest slack）</h3><p>按照紧迫性dj-tj升序安排作业顺序</p><p>处理时间最短优先和紧迫性优先都不是最优的，以下是相应的一些反例<br><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230807113821.png"></p><h2 id="EDF实现"><a href="#EDF实现" class="headerlink" title="EDF实现"></a>EDF实现</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">earliest_deadline_first</span>(<span class="params">jobs</span>):</span></span><br><span class="line">    <span class="comment"># 按照截止日期从早到晚进行排序</span></span><br><span class="line">    sorted_jobs = <span class="built_in">sorted</span>(jobs, key=<span class="keyword">lambda</span> job: job[<span class="number">2</span>])</span><br><span class="line">    <span class="built_in">print</span>(sorted_jobs)</span><br><span class="line">    <span class="comment"># 初始化当前时间和最大延迟</span></span><br><span class="line">    current_time = <span class="number">0</span></span><br><span class="line">    max_lateness = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建列表存储工作顺序，开始时间和结束时间</span></span><br><span class="line">    res_list=[]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历工作并计算延迟</span></span><br><span class="line">    <span class="keyword">for</span> job <span class="keyword">in</span> sorted_jobs:</span><br><span class="line">        finish_time = current_time + job[<span class="number">1</span>]  <span class="comment"># 计算工作的完成时间</span></span><br><span class="line">        lateness = <span class="built_in">max</span>(<span class="number">0</span>, finish_time - job[<span class="number">2</span>])  <span class="comment"># 计算延迟</span></span><br><span class="line">        max_lateness += lateness  <span class="comment"># 更新最大延迟</span></span><br><span class="line">        res_list.append([job[<span class="number">0</span>], current_time, finish_time])</span><br><span class="line">        current_time += job[<span class="number">1</span>]  <span class="comment"># 更新当前时间</span></span><br><span class="line">    <span class="keyword">return</span> res_list, max_lateness</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 示例工作列表，每个工作由编号,处理时间和截止时间构成</span></span><br><span class="line">    jobs = [(<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>), (<span class="number">2</span>, <span class="number">2</span>, <span class="number">8</span>), (<span class="number">3</span>, <span class="number">1</span>, <span class="number">9</span>), (<span class="number">4</span>, <span class="number">4</span>, <span class="number">9</span>), (<span class="number">5</span>, <span class="number">3</span>, <span class="number">14</span>), (<span class="number">6</span>, <span class="number">2</span>, <span class="number">15</span>)]</span><br><span class="line"></span><br><span class="line">    result = earliest_deadline_first(jobs)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><h2 id="EDF分析"><a href="#EDF分析" class="headerlink" title="EDF分析"></a>EDF分析</h2><p><strong>定理</strong>：最早截止日期优先调度（EDF）是最优的。</p><p><strong>证明</strong>：反证法</p><p>假设存在一个最优调度 S*，它具有最少的逆序对（inversions），让我们看看会发生什么。</p><p>我们可以假设 S* 没有空闲时间，因为任何空闲时间都可以用 S 中的任务填充，而不影响延迟。<br>如果 S* 没有逆序对，则 S = S<em>，因为这两个调度具有相同的任务顺序和延迟。<br>现在，考虑 S</em> 有一个逆序对 i-j，其中 i 被调度在 j 之前，但根据最早截止日期优先的顺序，i 应该在 j 之后被调度。<br>通过交换任务 i 和 j，最大延迟不会增加。这是因为延迟被定义为所有任务中的最大延迟，而交换 i 和 j 只会改变 i 和 j 的完成时间，但最大延迟保持不变。</p><p>然而，通过交换 i 和 j，我们严格减少了调度中逆序对的数量。这是因为 i-j 是一个逆序对，但是在交换后，j-i 就不再是一个逆序对。由于在 S* 中没有比 S* 更少的逆序对，交换 i 和 j 与 S* 的定义相矛盾。</p><p>因此，我们得到了矛盾，即假设存在一个最优调度 S* 具有比 S 更少的逆序对是错误的。因此，最早截止日期优先调度 S 是最优的，没有其他调度能够具有更少的逆序对并实现更小的最大延迟。</p><h1 id="最佳离线缓存问题（Optimal-offline-caching）"><a href="#最佳离线缓存问题（Optimal-offline-caching）" class="headerlink" title="最佳离线缓存问题（Optimal offline caching）"></a>最佳离线缓存问题（Optimal offline caching）</h1><p>“Optimal offline caching”（最优离线缓存）是指在一个离线环境中，根据已知的访问模式和缓存大小，设计一种缓存策略，使得缓存的命中率最高，从而最小化缓存未命中（缺失）带来的代价。</p><ul><li>缓存容量capacity：缓存具有存储 k 个数据项的容量。</li><li>数据请求序列Sequence：用户请求一系列的 m 个数据项，表示为 d1, d2, …, dm。</li><li>缓存命中Cache hit：如果用户请求的数据项已经在缓存中，那么就发生了缓存命中。</li><li>缓存未命中Cache miss：如果用户请求的数据项不在缓存中，那么就发生了缓存未命中。在这种情况下，必须将所请求的数据项带入缓存，并在缓存已满时选择某些现有的数据项进行替换。</li></ul><p><strong>目标</strong>：我们的目标是找到最佳的缓存替换策略，使得在数据请求序列中发生的缓存未命中次数最少，从而尽量减少替换带来的代价。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230807165117.jpg"></p><h2 id="Greedy-template-3"><a href="#Greedy-template-3" class="headerlink" title="Greedy template"></a>Greedy template</h2><h3 id="LIFO-FIFO"><a href="#LIFO-FIFO" class="headerlink" title="LIFO / FIFO"></a>LIFO / FIFO</h3><p>先进先出/后进先出策略，遇到缓存命中而缓存区已满情况时，优先移除先进/后进的数据项</p><h3 id="LRU（Least-Recently-Used）"><a href="#LRU（Least-Recently-Used）" class="headerlink" title="LRU（Least Recently Used）"></a>LRU（Least Recently Used）</h3><p>当缓存已满时，选择最近最少使用的数据项进行替换。也就是说，当有新的数据项需要加入缓存时，LRU策略会将最久未被使用的数据项淘汰，以腾出空间给新的数据项。</p><h3 id="LFU-（Least-Frequently-Used）"><a href="#LFU-（Least-Frequently-Used）" class="headerlink" title="LFU （Least Frequently Used）"></a>LFU （Least Frequently Used）</h3><p>当缓存已满时，选择最不常用的数据项进行替换。也就是说，当有新的数据项需要加入缓存时，LFU策略会将被访问次数最少的数据项淘汰，以腾出空间给新的数据项。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230807170122.jpg"></p><h2 id="FIF算法"><a href="#FIF算法" class="headerlink" title="FIF算法"></a>FIF算法</h2><p>Farthest-in-Future（FIF）算法，也称为预知算法（clairvoyant algorithm），是一种最优的缓存算法，用作与其他缓存策略性能比较的基准。FIF算法假设它完全知晓未来请求序列，并基于这种完美预测来做出缓存决策。</p><p>在FIF算法中，当发生缓存未命中时，它选择未来请求序列中将在最远未来访问的项，并淘汰当前缓存中最远未来不会被使用的项。通过这种方式，FIF算法始终淘汰缓存中最不有价值的项，并确保在拥有完整未来请求信息的前提下，缓存内容始终是最优的。</p><p>由于FIF算法需要对未来请求序列有完美预测，它在实际应用中并不可行。然而，它作为一个理论上的上限，可以用来衡量其他缓存算法（如LRU、LFU和随机替换）在实际场景中的效果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;贪心算法&quot;&gt;&lt;a href=&quot;#贪心算法&quot; class=&quot;headerlink&quot; title=&quot;贪心算法&quot;&gt;&lt;/a&gt;贪心算法&lt;/h1&gt;&lt;p&gt;贪心算法（Greedy Algorithm）是一种常见的优化算法，用于解决一类最优化问题。在每一步选择中，贪心算法总是选择当</summary>
      
    
    
    
    <category term="UOA" scheme="http://ywrby.com/categories/UOA/"/>
    
    <category term="COMPSCI 320" scheme="http://ywrby.com/categories/UOA/COMPSCI-320/"/>
    
    
    <category term="算法" scheme="http://ywrby.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Arithmetic Progression Graphs</title>
    <link href="http://ywrby.com/2023/08/02/Arithmetic-Progression-Graphs/"/>
    <id>http://ywrby.com/2023/08/02/Arithmetic-Progression-Graphs/</id>
    <published>2023-08-02T09:52:10.000Z</published>
    <updated>2023-08-05T09:22:57.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Arithmetic-Progression-Graphs"><a href="#Arithmetic-Progression-Graphs" class="headerlink" title="Arithmetic Progression Graphs"></a>Arithmetic Progression Graphs</h1><p>算术级数图（Arithmetic Progression Graphs, APG），也称为等差数列图，是等差数列的可视化表示。等差数列是一组数字，其中任意两个连续项之间的差值总是相同的。这个常数差值被称为算术级数的公差。</p><p>APG的顶点权重依序成等差数列，与某一顶点相连的所有边的权重之和等于顶点权重，例如下图所示：</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230805211125.jpg"></p><h2 id="APG一些已知特性"><a href="#APG一些已知特性" class="headerlink" title="APG一些已知特性"></a>APG一些已知特性</h2><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230805211357.jpg"></p><h2 id="判断APG"><a href="#判断APG" class="headerlink" title="判断APG"></a>判断APG</h2><p>给定一副图，并确定图的所有顶点值（已知图的顶点值成等差数列），这幅图是否能够称为APG？</p><p>问题的本质主要是确定是否存在满足条件的边的权重序列，确保与顶点相连的边的权重值之和等于顶点权重值</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230805212244.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Arithmetic-Progression-Graphs&quot;&gt;&lt;a href=&quot;#Arithmetic-Progression-Graphs&quot; class=&quot;headerlink&quot; title=&quot;Arithmetic Progression Graphs&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="UOA" scheme="http://ywrby.com/categories/UOA/"/>
    
    <category term="COMPSCI 320" scheme="http://ywrby.com/categories/UOA/COMPSCI-320/"/>
    
    
    <category term="算法" scheme="http://ywrby.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Perrin Numbers</title>
    <link href="http://ywrby.com/2023/07/30/Perrin-Numbers/"/>
    <id>http://ywrby.com/2023/07/30/Perrin-Numbers/</id>
    <published>2023-07-30T03:53:49.000Z</published>
    <updated>2023-08-01T12:09:27.416Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Perrin-numbers"><a href="#Perrin-numbers" class="headerlink" title="Perrin numbers"></a>Perrin numbers</h1><p>佩林数（Perrin numbers）是一个整数数列，以P(n)表示，其中 n 为非负整数。佩林数列的定义如下：</p><p>P(0) = 3<br>P(1) = 0<br>P(2) = 2</p><p>对于 n ≥ 3 的情况，佩林数列的每一项都由以下递推公式获得：</p><p>P(n) = P(n-2) + P(n-3)，其中 n ≥ 3</p><p>因此，佩林数列开始为：3、0、2、3、2、5、5、7、10、12、17、…</p><p>佩林数由法国数学家Alfred J. Perrin于1899年引入的，以他的名字命名。这个数列在组合数学和计算机科学中有一些应用。</p><p>佩林数列的前几项为：3、0、2、3、2、5、5、7、10、12、17、…，以此类推。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n    = <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>,  <span class="number">9</span>,  <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span></span><br><span class="line">P(n) = <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">22</span>, <span class="number">29</span>, <span class="number">39</span>, <span class="number">51</span></span><br><span class="line">div? = n, n, y, y, n, y, n, y, n,  n,  n,  y,  n,  y,  n</span><br></pre></td></tr></table></figure><p>佩林数具有很多特殊的性质，观察上面这三行列表，第一行是数列n，第二行则是按照数列n对应的佩林数数列，第三行是P(n)能否整除n，我们观察发现2, 3, 5, 7, 11, 13对应的佩林数和n数列能够正好整除，而这恰好就是0-14范围内的素数列表</p><p>经过继续计算不能看出， P(n) 可被 n 整除的n值似乎都是素数，因此，我们可以提出猜想：</p><blockquote><p>令 S 为所有数字 n 的集合，使得 P(n) 可被 n 整除。 S 是所有素数的集合吗？</p></blockquote><p>结果表明</p><ul><li>对于所有素数 n，P(n) 都能被 n 整除。</li><li>对于P(n) 可被n 整除的任何数字n，我们将其称为“佩林伪素数”（Perrin pseudo-prime）。</li><li>所有素数都是佩林伪素数，但所有佩林伪素数是否都是素数呢</li></ul><p>为了找到这个猜想的反例，我们想要编写一个程序，输出从 1 到 10 亿的所有 佩林伪素数</p><p>如果直接去计算这个范围内的佩林数，很快就会超过计算机可以计算的证书范围，所以我们要考虑如何简化计算过程。</p><p>在这个计算过程中，我们真正关心的不是佩林数大小，而是佩林数能否被n整除，换言之，我们关心 (P(n) mod n) 是否等于 0。</p><p>因此，我们使用 $P(n,m)$ 来表示 (P(n) mod m) ，我们可以使用以下公式来计算 $P(n, m)$</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P(<span class="number">0</span>, m) = <span class="number">3</span> mod m</span><br><span class="line">P(<span class="number">1</span>, m) = <span class="number">0</span></span><br><span class="line">P(<span class="number">2</span>, m) = <span class="number">2</span> mod m</span><br><span class="line">P(n, m) = (P(n − <span class="number">2</span>, m) + P(n − <span class="number">3</span>, m)) mod m</span><br></pre></td></tr></table></figure><p>现在我们可以只计算 $P(n, n)$ 。请注意，当且仅当 $P(n, n) = 0$ 时，P(n) 才能被 n 整除</p><h1 id="暴力破解（Brute-force）"><a href="#暴力破解（Brute-force）" class="headerlink" title="暴力破解（Brute-force）"></a>暴力破解（Brute-force）</h1><p>第一个想法是采用上面的公式，并直接使用递归算法来实现它们。实现这个方法很简单，用它来检查 n 的小值。 P(n) mod n 的值可以总结在一个表中，该表表明，对于较小的 n 值，没有合数 n 能整除 P(n)。问题是当 n 开始变大时，这个（第一个）程序需要很长时间才能运行。为什么？</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">PerrinNumber&lt;-<span class="keyword">function</span>(n)&#123;</span><br><span class="line">  p0=<span class="number">3</span></span><br><span class="line">  p1=<span class="number">0</span></span><br><span class="line">  p2=<span class="number">2</span></span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">return</span>(p0)</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (n==<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">return</span>(p1)</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="built_in">return</span>(p2)</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">return</span>(PerrinNumber(n-<span class="number">2</span>)+PerrinNumber(n-<span class="number">3</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BruteForce&lt;-<span class="keyword">function</span>(n)&#123;</span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">0</span>||n==<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">return</span>(<span class="literal">FALSE</span>)</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">return</span>(PerrinNumber(n)%%n ==<span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="built_in">c</span>(<span class="number">0</span>:<span class="number">14</span>))&#123;</span><br><span class="line">  print(paste(<span class="string">&quot;n=&quot;</span>,<span class="built_in">as.character</span>(i),<span class="string">&quot; p(n)=&quot;</span>,<span class="built_in">as.character</span>(PerrinNumber(i)),<span class="string">&quot; res=&quot;</span>,BruteForce(i)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用system.time()函数计算函数执行时间</span></span><br><span class="line">execution_time &lt;- system.time(BruteForce(<span class="number">10</span>))</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 使用system.time()函数计算函数执行时间</span></span><br><span class="line">&gt; system.time(BruteForce(<span class="number">10</span>))</span><br><span class="line">用户 系统 流逝 </span><br><span class="line">   <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> </span><br><span class="line">&gt; <span class="comment"># 使用system.time()函数计算函数执行时间</span></span><br><span class="line">&gt; system.time(BruteForce(<span class="number">20</span>))</span><br><span class="line">用户 系统 流逝 </span><br><span class="line">   <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> </span><br><span class="line">&gt; <span class="comment"># 使用system.time()函数计算函数执行时间</span></span><br><span class="line">&gt; system.time(BruteForce(<span class="number">30</span>))</span><br><span class="line">用户 系统 流逝 </span><br><span class="line"><span class="number">0.02</span> <span class="number">0.00</span> <span class="number">0.02</span> </span><br><span class="line">&gt; <span class="comment"># 使用system.time()函数计算函数执行时间</span></span><br><span class="line">&gt; system.time(BruteForce(<span class="number">40</span>))</span><br><span class="line">用户 系统 流逝 </span><br><span class="line"><span class="number">0.07</span> <span class="number">0.00</span> <span class="number">0.06</span> </span><br><span class="line">&gt; <span class="comment"># 使用system.time()函数计算函数执行时间</span></span><br><span class="line">&gt; system.time(BruteForce(<span class="number">50</span>))</span><br><span class="line">用户 系统 流逝 </span><br><span class="line"><span class="number">1.06</span> <span class="number">0.00</span> <span class="number">1.06</span> </span><br><span class="line">&gt; <span class="comment"># 使用system.time()函数计算函数执行时间</span></span><br><span class="line">&gt; system.time(BruteForce(<span class="number">55</span>))</span><br><span class="line">用户 系统 流逝 </span><br><span class="line"><span class="number">4.51</span> <span class="number">0.00</span> <span class="number">4.51</span> </span><br><span class="line">&gt; <span class="comment"># 使用system.time()函数计算函数执行时间</span></span><br><span class="line">&gt; system.time(BruteForce(<span class="number">60</span>))</span><br><span class="line"> 用户  系统  流逝 </span><br><span class="line"><span class="number">17.96</span>  <span class="number">0.00</span> <span class="number">17.97</span></span><br></pre></td></tr></table></figure><p>上文是通过R语言实现的暴力破解佩林数方法，可以看到算法的时间成本增长非常快，我们想通过这种算法计算较大的佩林数是不现实的。实际上，我们可以验证暴力破解方法的运行时间是以指数形式增长的（通过归纳假设法）</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前三项由于都是固定值，只需要常数时间就可以返回结果</span></span><br><span class="line"><span class="built_in">T</span> (k) = <span class="number">1</span>, <span class="keyword">for</span> k &lt; <span class="number">3</span></span><br><span class="line"><span class="comment"># n项需要递归调用前n-2和n-3项</span></span><br><span class="line"><span class="built_in">T</span> (n) = <span class="built_in">T</span> (n − <span class="number">2</span>) + <span class="built_in">T</span> (n − <span class="number">3</span>) + <span class="built_in">c</span>, <span class="keyword">for</span> n &gt; <span class="number">2</span></span><br></pre></td></tr></table></figure><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230801230310.jpg"></p><h1 id="动态规划（Dynamic-Programming）"><a href="#动态规划（Dynamic-Programming）" class="headerlink" title="动态规划（Dynamic Programming）"></a>动态规划（Dynamic Programming）</h1><p>为什么暴力破解最后的执行速度这么慢？在了解其运算过程后我们意识到该算法一遍又一遍地重复其工作。特别是，为了计算 P(n)，算法递归计算 P(n − 2) 和 P(n − 3)，这两个递归调用进一步递归调用来计算 P(n − 4)、P(n − 5) 、P(n − 5) 和 P(n − 6)。不难发现P(n − 5) 计算了两次。对于这个特定问题，我们唯一需要知道值 P(k) 的时候是在计算 P(k + 2) 和 P(k + 3) 时。因此，如果我们按升序计算值，记住序列中的最后 3 个值，我们可以轻松计算佩林数</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">PerrinNumber&lt;-<span class="keyword">function</span>(n)&#123;</span><br><span class="line">  p0=<span class="number">3</span></span><br><span class="line">  p1=<span class="number">0</span></span><br><span class="line">  p2=<span class="number">2</span></span><br><span class="line">  res=<span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">return</span>(p0)</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (n==<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">return</span>(p1)</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="built_in">return</span>(p2)</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    top=<span class="built_in">c</span>(<span class="number">3</span>,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span>(i <span class="keyword">in</span> <span class="built_in">c</span>(<span class="number">3</span>:n))&#123;</span><br><span class="line">      res=top[<span class="number">2</span>]+top[<span class="number">1</span>]</span><br><span class="line">      top=<span class="built_in">c</span>(top[<span class="number">2</span>],top[<span class="number">3</span>],res)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span>(res)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DynamicProgramming&lt;-<span class="keyword">function</span>(n)&#123;</span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">0</span>||n==<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">return</span>(<span class="literal">FALSE</span>)</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">return</span>(PerrinNumber(n)%%n ==<span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="built_in">c</span>(<span class="number">0</span>:<span class="number">14</span>))&#123;</span><br><span class="line">  print(paste(<span class="string">&quot;n=&quot;</span>,<span class="built_in">as.character</span>(i),<span class="string">&quot; p(n)=&quot;</span>,<span class="built_in">as.character</span>(PerrinNumber(i)),<span class="string">&quot; res=&quot;</span>,DynamicProgramming(i)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用system.time()函数计算函数执行时间</span></span><br><span class="line">system.time(BruteForce(<span class="number">1000000</span>))</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 使用system.time()函数计算函数执行时间</span></span><br><span class="line">&gt; system.time(BruteForce(<span class="number">10000</span>))</span><br><span class="line">用户 系统 流逝 </span><br><span class="line">   <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> </span><br><span class="line">&gt; <span class="comment"># 使用system.time()函数计算函数执行时间</span></span><br><span class="line">&gt; system.time(BruteForce(<span class="number">100000</span>))</span><br><span class="line">用户 系统 流逝 </span><br><span class="line"><span class="number">0.05</span> <span class="number">0.00</span> <span class="number">0.04</span> </span><br><span class="line">&gt; <span class="comment"># 使用system.time()函数计算函数执行时间</span></span><br><span class="line">&gt; system.time(BruteForce(<span class="number">1000000</span>))</span><br><span class="line">用户 系统 流逝 </span><br><span class="line"><span class="number">0.51</span> <span class="number">0.00</span> <span class="number">0.51</span> </span><br></pre></td></tr></table></figure><p>可以看到算法的运行时间降低的非常快，算法已经从指数级降低为了线性时间算法！</p><h1 id="快速求幂算法（Fast-Exponentiation-Algorithm）"><a href="#快速求幂算法（Fast-Exponentiation-Algorithm）" class="headerlink" title="快速求幂算法（Fast Exponentiation Algorithm）"></a>快速求幂算法（Fast Exponentiation Algorithm）</h1><p>线性时间复杂度是否就是目前的极限呢，看起来要计算第n项我们必须要知道第n-2项，以此类推还需要知道第n-4项等等，线性时间看起来已经是最优的了，但实际上我们可以在O(logn)时间内实现计算过程，这需要采用分而治之的思想</p><p>回想如何将矩阵乘以向量，我们看到对于任何值 n ≥ 3，我们可以写出以下线性代数方程，它表示最后一个算法的一次迭代</p><p>$$<br>\begin{pmatrix}<br>0 &amp; 1 &amp; 1 \<br>1 &amp; 0 &amp; 0 \<br>0 &amp; 1 &amp; 0 \<br>\end{pmatrix}<br>*<br>\begin{pmatrix}<br>P(n-1) \<br>P(n-2) \<br>P(n-3) \<br>\end{pmatrix}<br>=<br>\begin{pmatrix}<br>P(n) \<br>P(n-1) \<br>P(n-2) \<br>\end{pmatrix}<br>$$</p><p>回想一下，对于 n ≥ 3，我们定义 P(n) = P(n − 2) + P(n − 3)</p><p>整个表达式可以乘以同一个矩阵，以获得包含 P(n + 1)、P(n) 和 P(n − 1) 的向量。扩展这个论点，如果 M 代表上面表达式中的矩阵，V 代表初始值的向量： (2, 0, 3)T ，那么我们将矩阵 M 的 (n − 2) 次方与初始值相乘得到：</p><p>$$<br>M^{n-2}*V=<br>\begin{pmatrix}<br>P(n) \<br>P(n-1) \<br>P(n-2) \<br>\end{pmatrix}<br>$$</p><p>所以现在，为了计算第 n 个 Perrin 数，我们只需要将 3 × 3 矩阵求幂</p><p>而在求幂的计算过程中，我们也可以进行简化，例如我们要求偶数次幂$M^{16}$，其本质上就是求$(((M^2)^2)^2)^2$，这样我们就把需要进行n次的计算过程简化为了logn，对于奇数次幂，其处理也非常简单，我们只需要利用递归的方式对其进行归纳</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230801234145.jpg"></p><p>很容易证明 FastExp(a,n) 最多执行 $2\log_2 n$ 次递归调用。假设指数整数 n ≥ 0。因此需要 O(log n) 次乘法来计算</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">FastExp&lt;-<span class="keyword">function</span>(a,n)&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>)&#123;<span class="built_in">return</span>(<span class="number">1</span>)&#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>)&#123;<span class="built_in">return</span>(a)&#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (n %% <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">    t &lt;- FastExp(a,n/<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">return</span>(t %*% t)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">return</span>(a %*% FastExp(a,(n - <span class="number">1</span>)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n=<span class="number">14</span></span><br><span class="line">(FastExp(a,n-<span class="number">2</span>) %*% v)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PerrinNumber&lt;-<span class="keyword">function</span>(n)&#123;</span><br><span class="line">  p0=<span class="number">3</span></span><br><span class="line">  p1=<span class="number">0</span></span><br><span class="line">  p2=<span class="number">2</span></span><br><span class="line">  res=<span class="number">0</span></span><br><span class="line">  a &lt;- matrix(<span class="built_in">c</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), nrow = <span class="number">3</span>, ncol = <span class="number">3</span>)</span><br><span class="line">  v= matrix(<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>), nrow = <span class="number">3</span>, ncol = <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">return</span>(p0)</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (n==<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">return</span>(p1)</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="built_in">return</span>(p2)</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">return</span>((FastExp(a,n-<span class="number">2</span>) %*% v)[<span class="number">1</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThirdTry&lt;-<span class="keyword">function</span>(n)&#123;</span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">0</span>||n==<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">return</span>(<span class="literal">FALSE</span>)</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">return</span>(PerrinNumber(n)%%n ==<span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="built_in">c</span>(<span class="number">0</span>:<span class="number">14</span>))&#123;</span><br><span class="line">  print(paste(<span class="string">&quot;n=&quot;</span>,<span class="built_in">as.character</span>(i),<span class="string">&quot; p(n)=&quot;</span>,<span class="built_in">as.character</span>(PerrinNumber(i)),<span class="string">&quot; res=&quot;</span>,ThirdTry(i)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用system.time()函数计算函数执行时间</span></span><br><span class="line">system.time(ThirdTry(<span class="number">100000000000000000000</span>))</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 使用system.time()函数计算函数执行时间</span></span><br><span class="line">&gt; system.time(ThirdTry(<span class="number">1000000000000000000</span>))</span><br><span class="line">用户 系统 流逝 </span><br><span class="line">   <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> </span><br><span class="line">&gt; <span class="comment"># 使用system.time()函数计算函数执行时间</span></span><br><span class="line">&gt; system.time(ThirdTry(<span class="number">100000000000000000000</span>))</span><br><span class="line">用户 系统 流逝 </span><br><span class="line">   <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span> </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Perrin-numbers&quot;&gt;&lt;a href=&quot;#Perrin-numbers&quot; class=&quot;headerlink&quot; title=&quot;Perrin numbers&quot;&gt;&lt;/a&gt;Perrin numbers&lt;/h1&gt;&lt;p&gt;佩林数（Perrin numbers）是一个</summary>
      
    
    
    
    <category term="UOA" scheme="http://ywrby.com/categories/UOA/"/>
    
    <category term="COMPSCI 320" scheme="http://ywrby.com/categories/UOA/COMPSCI-320/"/>
    
    
    <category term="算法" scheme="http://ywrby.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Access Control</title>
    <link href="http://ywrby.com/2023/07/29/Access-Control/"/>
    <id>http://ywrby.com/2023/07/29/Access-Control/</id>
    <published>2023-07-29T08:44:56.000Z</published>
    <updated>2023-07-30T02:20:12.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FOCUS-OF-THIS-LECTURE"><a href="#FOCUS-OF-THIS-LECTURE" class="headerlink" title="FOCUS OF THIS LECTURE"></a>FOCUS OF THIS LECTURE</h1><ul><li>Identify access control requirements</li><li>Know access control elements</li><li>Understand access control systems</li></ul><h1 id="授权（AUTHORISATION）"><a href="#授权（AUTHORISATION）" class="headerlink" title="授权（AUTHORISATION）"></a>授权（AUTHORISATION）</h1><p>向系统实体授予权利或权限以提供对特定资源的访问的过程，也称访问控制（Access Control）</p><h2 id="访问控制要求（ACCESS-CONTROL-REQUIREMENTS）"><a href="#访问控制要求（ACCESS-CONTROL-REQUIREMENTS）" class="headerlink" title="访问控制要求（ACCESS CONTROL REQUIREMENTS）"></a>访问控制要求（ACCESS CONTROL REQUIREMENTS）</h2><ul><li>可靠的输入（Reliable inputs）<ul><li>经过身份认证的实体，例如使用UPI或密码登录</li><li>真实的资料，例如学生或教职工成员</li></ul></li><li>最小特权（Least privilege）<ul><li> 最小特权原则表示授予完成某项工作的最低访问权限集，例如，访问单个课程与所有课程</li></ul></li><li>管理职责（Administrative duties）<ul><li>只有特殊实体才能管理访问权限，例如，管理员授予、撤销或更新访问权限</li></ul></li></ul><h2 id="访问控制组件（AC-ELEMENTS）"><a href="#访问控制组件（AC-ELEMENTS）" class="headerlink" title="访问控制组件（AC ELEMENTS）"></a>访问控制组件（AC ELEMENTS）</h2><ul><li>主体（Subject）<ul><li>可以访问对象的实体，它可以是用户也可以是用户授权的进程</li></ul></li><li>对象（Object）<ul><li>需要被保护的实体，例如文件、目录或其他资源</li></ul></li><li>访问权限（Access right）<ul><li>一个访问权限r ∈ R 描述了一个主体s ∈ S 如何访问对象o ∈ O </li><li>例如：读、写、执行、删除、创建、搜索等</li></ul></li></ul><h2 id="访问控制系统（AC-SYSTEM）"><a href="#访问控制系统（AC-SYSTEM）" class="headerlink" title="访问控制系统（AC SYSTEM）"></a>访问控制系统（AC SYSTEM）</h2><ul><li>访问控制方法（AC Function）f(s, o, r)<ul><li>它查找（s, o）组合的访问权限 r </li><li>如果匹配成功，则允许访问，否则不允许访问</li></ul></li><li>安全管理员（Security administrator）<ul><li>管理访问权限的实体</li></ul></li><li>审计员（Auditor）<ul><li>检查整个授权系统的实体</li></ul></li></ul><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230730135723.jpg"></p><h2 id="访问控制模型（AC-MODELS）"><a href="#访问控制模型（AC-MODELS）" class="headerlink" title="访问控制模型（AC MODELS）"></a>访问控制模型（AC MODELS）</h2><h3 id="自主访问控制-Discretionary-Access-Control-DAC"><a href="#自主访问控制-Discretionary-Access-Control-DAC" class="headerlink" title="自主访问控制 Discretionary Access Control (DAC)"></a>自主访问控制 Discretionary Access Control (DAC)</h3><p>用户可以自主保护自己拥有的内容</p><ul><li>所有者可以授予主体访问权限</li><li>根据请求者的身份授予访问权限</li><li>这些机制足以满足诚实用户的要求</li><li>容易受到特洛伊木马的攻击</li><li>DAC 用于操作系统<ul><li>例如，Linux 文件权限: rwxr-x–x</li></ul></li></ul><p>访问控制矩阵</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230730140543.jpg"></p><h3 id="基于角色的访问控制-ROLE-BASED-ACCESS-CONTROL-RBAC"><a href="#基于角色的访问控制-ROLE-BASED-ACCESS-CONTROL-RBAC" class="headerlink" title="基于角色的访问控制 ROLE-BASED ACCESS CONTROL (RBAC)"></a>基于角色的访问控制 ROLE-BASED ACCESS CONTROL (RBAC)</h3><p>RBAC 将角色映射到访问权限</p><ul><li>支持复杂的访问控制</li><li>减少管理错误</li><li>易于管理<ul><li>将用户移入和移出角色</li><li>将权限移入和移出角色</li><li>非常灵活</li></ul></li><li>最小特权<ul><li>根据需要限制访问</li><li>通过约束进行职责分离</li></ul></li></ul><p>RBAC模型构成</p><ul><li>用户User<ul><li>通常是人类</li><li>用户被分配角色：用户分配（UA）</li></ul></li><li>权限Permissions<ul><li>批准访问某些对象的模式</li><li>权限代表可以对对象执行哪些操作</li></ul></li><li>角色Roles<ul><li>职务</li><li>角色分配权限：权限分配（PA）</li></ul></li><li>分配Assignments<ul><li>用户角色和角色权限</li></ul></li><li>会话Session<ul><li>用户到角色的映射</li><li>会话是用户和已分配角色的激活子集之间的映射</li></ul></li><li>约束Constraints<ul><li>会话、分配和角色</li></ul></li></ul><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230730142000.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;FOCUS-OF-THIS-LECTURE&quot;&gt;&lt;a href=&quot;#FOCUS-OF-THIS-LECTURE&quot; class=&quot;headerlink&quot; title=&quot;FOCUS OF THIS LECTURE&quot;&gt;&lt;/a&gt;FOCUS OF THIS LECTURE&lt;/</summary>
      
    
    
    
    <category term="UOA" scheme="http://ywrby.com/categories/UOA/"/>
    
    <category term="COMPSCI 316" scheme="http://ywrby.com/categories/UOA/COMPSCI-316/"/>
    
    
    <category term="网络安全" scheme="http://ywrby.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="计算机安全" scheme="http://ywrby.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Password</title>
    <link href="http://ywrby.com/2023/07/25/Password/"/>
    <id>http://ywrby.com/2023/07/25/Password/</id>
    <published>2023-07-25T05:02:00.000Z</published>
    <updated>2023-07-25T09:26:23.396Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FOCUS-OF-THIS-LECTURE"><a href="#FOCUS-OF-THIS-LECTURE" class="headerlink" title="FOCUS OF THIS LECTURE"></a>FOCUS OF THIS LECTURE</h1><ul><li>Understand identification and authentication</li><li> Learn how passwords are protected</li></ul><h1 id="身份识别和认证"><a href="#身份识别和认证" class="headerlink" title="身份识别和认证"></a>身份识别和认证</h1><h2 id="身份识别（IDENTIFICATION）"><a href="#身份识别（IDENTIFICATION）" class="headerlink" title="身份识别（IDENTIFICATION）"></a>身份识别（IDENTIFICATION）</h2><p>系统实体提供其声明的身份的过程，例如UPI（统一支付接口）</p><h2 id="认证（Authentication）"><a href="#认证（Authentication）" class="headerlink" title="认证（Authentication）"></a>认证（Authentication）</h2><p><strong>验证</strong>系统实体声明的身份的过程，例如PIN码或秘密</p><h1 id="密码漏洞（PASSWORD-VULNERABILITIES）"><a href="#密码漏洞（PASSWORD-VULNERABILITIES）" class="headerlink" title="密码漏洞（PASSWORD VULNERABILITIES）"></a>密码漏洞（PASSWORD VULNERABILITIES）</h1><h2 id="Offline-dictionary-attack-离线字典攻击"><a href="#Offline-dictionary-attack-离线字典攻击" class="headerlink" title="Offline dictionary attack 离线字典攻击"></a>Offline dictionary attack 离线字典攻击</h2><p>离线字典攻击就是攻击者获取到口令文件（字典），有了离线字典文件后,针对口令文件攻击者直接查表，一旦哈希值匹配成功了，那么就可以得到口令明文。</p><p>应对策略：</p><ul><li>防止未经授权访问密码文件</li><li>识别入侵的入侵检测措施</li><li>快速重新发布密码</li></ul><h2 id="Specific-account-attack-特定账户攻击"><a href="#Specific-account-attack-特定账户攻击" class="headerlink" title="Specific account attack 特定账户攻击"></a>Specific account attack 特定账户攻击</h2><p>攻击者针对某些特定账户进行攻击，不断猜测并提交密码直到成功</p><p>应对策略：</p><ul><li>尝试失败一定次数后锁定机制</li><li>另一种方法是逐渐延迟每次后续尝试</li></ul><h2 id="Popular-password-attack-流行密码攻击"><a href="#Popular-password-attack-流行密码攻击" class="headerlink" title="Popular password attack 流行密码攻击"></a>Popular password attack 流行密码攻击</h2><p>用户倾向于选择容易记住的密码（例如：“123456”），这使得密码很容易被猜出，攻击者可以针对各种用户 ID 尝试常用密码</p><p>应对策略：</p><ul><li>实施复杂的密码策略</li><li>扫描 IP 地址和客户端 cookie 以获取提交模式</li><li>入侵检测</li></ul><h2 id="Password-guessing-against-single-user-针对单个用户的密码猜测"><a href="#Password-guessing-against-single-user-针对单个用户的密码猜测" class="headerlink" title="Password guessing against single user 针对单个用户的密码猜测"></a>Password guessing against single user 针对单个用户的密码猜测</h2><p>了解单个用户的相关信息，了解系统密码策略，使用两者来猜测密码</p><p>应对策略：</p><ul><li>教育用户</li><li>执行复杂的密码策略</li></ul><h2 id="Workstation-hijacking-工作站劫持"><a href="#Workstation-hijacking-工作站劫持" class="headerlink" title="Workstation hijacking 工作站劫持"></a>Workstation hijacking 工作站劫持</h2><p>攻击者等待，直到登录的工作站无人值守</p><p>应对策略：</p><ul><li>一段时间不活动后注销</li><li>入侵检测方案可用于检测用户行为的变化</li></ul><h2 id="Exploiting-user-mistakes-利用用户错误"><a href="#Exploiting-user-mistakes-利用用户错误" class="headerlink" title="Exploiting user mistakes 利用用户错误"></a>Exploiting user mistakes 利用用户错误</h2><p>用户可能会使用系统分配的密码，根本问题是这些密码可能很难记住，攻击者可以使用社会工程技巧来诱骗用户泄露密码，其次，许多系统附带了管理员的默认密码</p><p>应对策略：</p><ul><li>更改默认密码</li><li>教育用户</li></ul><h2 id="Exploiting-same-password-use-利用相同的密码复用"><a href="#Exploiting-same-password-use-利用相同的密码复用" class="headerlink" title="Exploiting same password use 利用相同的密码复用"></a>Exploiting same password use 利用相同的密码复用</h2><p>用户可能在不同的服务选择使用相同的密码，攻击者可以从一个来源获知密码，他们可以尝试在用户可能使用的其他服务中使用相同的密码进行攻击</p><p>应对策略：</p><ul><li>选择不同的密码</li><li>教育用户</li></ul><h2 id="Electronic-monitoring-电子监控"><a href="#Electronic-monitoring-电子监控" class="headerlink" title="Electronic monitoring 电子监控"></a>Electronic monitoring 电子监控</h2><p>以明文形式传递密码，攻击者很容易窃听并获取密码</p><p>应对策略：</p><ul><li>切勿以明文形式发送密码</li><li>密码安全传输的技术解决方案</li></ul><h1 id="加盐的密码加载过程（LOADING-PASSWORD-SALT-WITH-HASH）"><a href="#加盐的密码加载过程（LOADING-PASSWORD-SALT-WITH-HASH）" class="headerlink" title="加盐的密码加载过程（LOADING PASSWORD: SALT WITH HASH）"></a>加盐的密码加载过程（LOADING PASSWORD: SALT WITH HASH）</h1><p>为了缓解某些密码漏洞，可以使用盐，盐可以是随机数，盐会增加攻击者的工作量</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230725211849.jpg"></p><p>注册时，服务器可以存储 </p><ul><li>UserID </li><li>Salt</li><li>加盐密码的哈希值</li></ul><h1 id="加盐的密码验证过程（VERIFYING-PASSWORD-SALT-WITH-HASH）"><a href="#加盐的密码验证过程（VERIFYING-PASSWORD-SALT-WITH-HASH）" class="headerlink" title="加盐的密码验证过程（VERIFYING PASSWORD: SALT WITH HASH）"></a>加盐的密码验证过程（VERIFYING PASSWORD: SALT WITH HASH）</h1><p>用户提供用户 ID 和密码，查找相应的盐和哈希，根据检索到的盐和输入的密码重新计算哈希，如果结果匹配，则接受密码</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230725212215.jpg"></p><h1 id="随机盐的好处"><a href="#随机盐的好处" class="headerlink" title="随机盐的好处"></a>随机盐的好处</h1><ul><li>很难猜测一个用户是否为多个服务选择相同的密码</li><li>很难猜测多个用户是否为单个服务（或多个）选择相同的密码</li><li>使离线字典攻击变得困难</li></ul><p>攻击者可以使用彩虹表来预先计算带有加盐哈希值的字典</p><ul><li>解决方案是使用大盐</li></ul><h1 id="多重身份验证-MULTI-FACTOR-AUTHENTICATION"><a href="#多重身份验证-MULTI-FACTOR-AUTHENTICATION" class="headerlink" title="多重身份验证 MULTI-FACTOR AUTHENTICATION"></a>多重身份验证 MULTI-FACTOR AUTHENTICATION</h1><p>不同的身份验证因素或方式 </p><p>Different factors or means of authentication</p><ul><li>Something you know<ul><li>E.g., PIN or password</li></ul></li><li>Something you have (token)<ul><li>E.g., smartcard</li></ul></li><li>Something you are (static biometrics)<ul><li>E.g., fingerprint</li></ul></li><li>Something you do (dynamic biometrics)<ul><li>E.g., voice pattern or behaviour analysis</li></ul></li></ul><p>使用两个或多个因素来启用双因素或多因素身份验证</p><h1 id="对策（COUNTERMEASURES）总结"><a href="#对策（COUNTERMEASURES）总结" class="headerlink" title="对策（COUNTERMEASURES）总结"></a>对策（COUNTERMEASURES）总结</h1><ul><li>Educate users</li><li>Use multi-factor authentication</li><li>Better notifications to users for password reset</li><li>Phone call and reply by voice in case of</li><li>password reset</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;FOCUS-OF-THIS-LECTURE&quot;&gt;&lt;a href=&quot;#FOCUS-OF-THIS-LECTURE&quot; class=&quot;headerlink&quot; title=&quot;FOCUS OF THIS LECTURE&quot;&gt;&lt;/a&gt;FOCUS OF THIS LECTURE&lt;/</summary>
      
    
    
    
    <category term="UOA" scheme="http://ywrby.com/categories/UOA/"/>
    
    <category term="COMPSCI 316" scheme="http://ywrby.com/categories/UOA/COMPSCI-316/"/>
    
    
    <category term="网络安全" scheme="http://ywrby.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="计算机安全" scheme="http://ywrby.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>GDPR</title>
    <link href="http://ywrby.com/2023/07/22/GDPR/"/>
    <id>http://ywrby.com/2023/07/22/GDPR/</id>
    <published>2023-07-22T06:02:06.000Z</published>
    <updated>2023-07-24T06:23:00.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DPD"><a href="#DPD" class="headerlink" title="DPD"></a>DPD</h1><p>“Data Protection Directive”，欧盟隐私和人权法的组成部分，DPD 负责个人数据的保护和处理，它<strong>不保护</strong>欧盟以外的欧盟公民的个人数据</p><h1 id="GDPR"><a href="#GDPR" class="headerlink" title="GDPR"></a>GDPR</h1><p>GDPR (General Data Protection Regulation) 是欧盟关于数据保护的法规，它协调了整个欧盟的数据隐私法，保护并增强了欧盟公民的数据隐私，重塑了欧盟处理数据隐私的方式。</p><h2 id="为什么选择GDPR"><a href="#为什么选择GDPR" class="headerlink" title="为什么选择GDPR"></a>为什么选择GDPR</h2><ul><li>GDPR 取代了 DPD</li><li>GDPR 依法保护欧盟境外欧盟公民的个人数据</li><li>GDPR 扩展了个人数据的定义<ul><li>照片、音频、视频、金融交易、社交媒体帖子等。</li><li>设备标识符（IP 地址、IMEI 号码）</li><li>浏览记录</li><li>遗传信息</li></ul></li></ul><h2 id="数据Data"><a href="#数据Data" class="headerlink" title="数据Data"></a>数据Data</h2><ul><li>Personal data：与已识别或可识别人员相关的任何信息，例如电子邮件ID</li><li>De-identified data：去识别化数据，没有任何个人标识的个人数据（Personal data），例如匿名帖子</li><li>Anonymised data：匿名数据，没有任何个人标识的个人数据，无法进行重新识别，例如首次购房者的平均年龄</li></ul><h2 id="常用术语"><a href="#常用术语" class="headerlink" title="常用术语"></a>常用术语</h2><h3 id="Data-subject-数据主体"><a href="#Data-subject-数据主体" class="headerlink" title="Data subject 数据主体"></a>Data subject 数据主体</h3><p>数据主体是指其个人数据被收集、持有或处理的任何人，例如学生或教职工</p><h3 id="Data-controller-数据控制者"><a href="#Data-controller-数据控制者" class="headerlink" title="Data controller 数据控制者"></a>Data controller 数据控制者</h3><p>确定个人数据处理的目的和方式的实体，例如大学或企业</p><h3 id="Data-processor-数据处理器"><a href="#Data-processor-数据处理器" class="headerlink" title="Data processor 数据处理器"></a>Data processor 数据处理器</h3><p>代表数据控制者处理个人数据的实体，例如Google(gmail)</p><h2 id="GDPR原则"><a href="#GDPR原则" class="headerlink" title="GDPR原则"></a>GDPR原则</h2><ul><li>合法、公平、透明<ul><li>规定所收集的数据必须合法、公正、透明地处理</li></ul></li><li>目的限制<ul><li>规定不得以客户未知的方式使用客户数据</li></ul></li><li>数据最小化<ul><li>规定仅必须为特定功能收集该功能严格要求的数据</li></ul></li><li>准确性<ul><li>规定从客户收集的数据必须正确存储并定期更新</li></ul></li><li>保密性和完整性<ul><li>保密性规定，只有获得必要授权的人才能检索客户的数据。</li><li>完整性规定检索到的客户数据只能由被授权进行此类更改的人员更改</li></ul></li><li>问责机制<ul><li>一项附加原则，问责制原则要求您对您处理个人数据的行为以及如何遵守其他原则负责。</li></ul></li></ul><h2 id="GDPR主要变化"><a href="#GDPR主要变化" class="headerlink" title="GDPR主要变化"></a>GDPR主要变化</h2><ul><li>扩大领土范围<ul><li>Also known as <strong>extraterritorial applicability</strong>，也被称为域外适用</li><li>GDPR 适用于所有处理欧盟数据主体个人数据的公司</li><li>GDPR 适用于数据控制者和数据处理者</li></ul></li><li>处罚机制（Penalties）<ul><li>违反 GDPR 的组织可能会被罚款</li></ul></li><li>授权许可机制（Consent）<ul><li>同意请求必须以易于理解且易于获取的形式提出</li><li>必须使用清晰易懂的语言获得同意</li><li>撤回同意必须很容易</li></ul></li><li>数据主体权利<ul><li>违规通知</li><li>访问权</li><li>被遗忘权</li><li>数据可移植</li><li>隐私设计</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;DPD&quot;&gt;&lt;a href=&quot;#DPD&quot; class=&quot;headerlink&quot; title=&quot;DPD&quot;&gt;&lt;/a&gt;DPD&lt;/h1&gt;&lt;p&gt;“Data Protection Directive”，欧盟隐私和人权法的组成部分，DPD 负责个人数据的保护和处理，它&lt;stron</summary>
      
    
    
    
    <category term="UOA" scheme="http://ywrby.com/categories/UOA/"/>
    
    <category term="COMPSCI 316" scheme="http://ywrby.com/categories/UOA/COMPSCI-316/"/>
    
    
    <category term="网络安全" scheme="http://ywrby.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="计算机安全" scheme="http://ywrby.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>稳定匹配问题</title>
    <link href="http://ywrby.com/2023/07/21/%E7%A8%B3%E5%AE%9A%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/"/>
    <id>http://ywrby.com/2023/07/21/%E7%A8%B3%E5%AE%9A%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/</id>
    <published>2023-07-20T17:25:28.000Z</published>
    <updated>2023-07-22T06:00:31.525Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/225925804">参考：经典算法问题——稳定匹配（Stable Matching）</a></p><h1 id="Gale-Shapley-Algorithms"><a href="#Gale-Shapley-Algorithms" class="headerlink" title="Gale-Shapley Algorithms"></a>Gale-Shapley Algorithms</h1><p>简称“GS 算法”，也称为延迟接受算法。是 Gale 和 Shapley 为了寻找一个稳定匹配而设计出的市场机制。运行时间在算法输入的大小上是线性的。根据其使用方式，它可以找到对匹配一侧的参与者或另一侧的参与者最佳的解决方案。</p><p>问题描述<br>给出一个 $n$ 个男性的集合 $M$，和 $n$ 个女性的集合 $W$，其中：</p><ul><li>每位男性根据对所有女性的心仪程度从高至低进行排名；</li><li>每位女性根据对所有男性的心仪程度从高至低进行排名。</li></ul><p>根据以上条件，我们需要找到一个“稳定匹配”。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="匹配-Matching"><a href="#匹配-Matching" class="headerlink" title="匹配 Matching"></a>匹配 Matching</h3><p>匹配 $S$ 是一个包含有序数对 $m-w$ 的集合，其中 $m \in M$ 且$w \in W$，其中：</p><ul><li>每个男性最多出现在一个数对中；</li><li>每个女性最多出现在一个数对中。</li></ul><h3 id="完美匹配-Perfect-matching"><a href="#完美匹配-Perfect-matching" class="headerlink" title="完美匹配 Perfect matching"></a>完美匹配 Perfect matching</h3><p>如果 $\left| S \right|=\left| M \right|=\left| W \right|=n$ 则匹配$S$是完美匹配，也就是说，<strong>男女数量相等</strong>且都有<strong>唯一匹配</strong>的对象。</p><h3 id="不稳定因素-Unstable-pair"><a href="#不稳定因素-Unstable-pair" class="headerlink" title="不稳定因素 Unstable pair"></a>不稳定因素 Unstable pair</h3><p>给出一个完美匹配 $S$，如果其中存在一个男性$m$和一个女性$w$同时满足下列条件：</p><ul><li>不在匹配$S$中；</li><li>$m$比起他当前配偶，更喜欢$w$;</li><li>$w$比起她当前配偶，更喜欢$m$。</li></ul><p>则称男性$m$和女性$w$是不稳定的，也就是说，$(m,w)$是不稳定因素。</p><h3 id="稳定匹配-Stable-matching"><a href="#稳定匹配-Stable-matching" class="headerlink" title="稳定匹配 Stable matching"></a>稳定匹配 Stable matching</h3><p>一个不存在<strong>不稳定因素</strong>的完美匹配。</p><h1 id="Gale-Shapley-算法"><a href="#Gale-Shapley-算法" class="headerlink" title="Gale-Shapley 算法"></a>Gale-Shapley 算法</h1><p>一个直观的，确保能找到一个稳定匹配的算法</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/v2-0875a5c538f6363cb38d3b4407b39a5e_r.jpg"></p><h2 id="算法策略"><a href="#算法策略" class="headerlink" title="算法策略"></a>算法策略</h2><ul><li>男性策略：单身的男性会主动出击，根据喜好降序向所有女性求婚，直到有配偶为止；</li><li>女性策略：被动等待男性求婚，如果女性仍处于单身，则直接接受；有配偶的情况下被更心仪的男性求婚，则会抛弃原来的，接受更好的。</li></ul><h2 id="算法特征"><a href="#算法特征" class="headerlink" title="算法特征"></a>算法特征</h2><p>G-S算法具有：有穷性、完美性、稳定性、男性最佳分配、女性最劣分配等特征</p><ul><li>有穷性：算法最多在$n^2$次 while 迭代后一定会结束。</li><li>完美性：算法中所有男性和女性都匹配完毕。</li><li>稳定性：算法产生的匹配中，不会有不稳定因素</li><li>男性最佳分配 Man-optimal Assignment：GS 算法中每个男性都能分配到最佳的正当配偶，所以 GS 算法得到的分配一定是男性最佳分配。<ul><li>正当配偶 Valid Partner：如果存在一个稳定匹配中男性和女性匹配在一起，则称女性是男性的正当配偶。</li></ul></li><li>女性最劣分配：GS 算法中女性一定分配到的是最差的正当配偶。</li></ul><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Gender.Man;</span><br><span class="line"><span class="keyword">import</span> Gender.Woman;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.In;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdOut;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 盖尔沙普利算法的实现</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GaleShapley</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Man[] ManGroup;</span><br><span class="line">    <span class="keyword">public</span> Woman[] WomanGroup;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GaleShapley</span><span class="params">(In in1,In in2)</span></span>&#123;</span><br><span class="line">        CreateManGroup(in1);</span><br><span class="line">        CreateWomanGroup(in2);</span><br><span class="line">        InsertManFavor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreateManGroup</span><span class="params">(In in)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numMan=in.readInt();</span><br><span class="line">        <span class="keyword">int</span> numWoman=in.readInt();</span><br><span class="line">        ManGroup=<span class="keyword">new</span> Man[numMan];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numMan;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> manName=in.readInt();</span><br><span class="line">            Man man=<span class="keyword">new</span> Man((<span class="keyword">char</span>) manName,numWoman);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;numWoman;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> Num=in.readInt()-<span class="number">1</span>;</span><br><span class="line">                man.favorNum[j]=Num;</span><br><span class="line">            &#125;</span><br><span class="line">            ManGroup[i]=man;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreateWomanGroup</span><span class="params">(In in)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numMan=in.readInt();</span><br><span class="line">        <span class="keyword">int</span> numWoman=in.readInt();</span><br><span class="line">        WomanGroup=<span class="keyword">new</span> Woman[numWoman];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numWoman;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> womanName=in.readInt();</span><br><span class="line">            Man[] men=<span class="keyword">new</span> Man[numMan];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;numMan;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> favorNum=in.readInt()-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (favorNum&lt;<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                Man favorMan=ManGroup[favorNum];</span><br><span class="line">                men[j]=favorMan;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            WomanGroup[i]=<span class="keyword">new</span> Woman((<span class="keyword">char</span>)womanName,men);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertManFavor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Man man:ManGroup)&#123;</span><br><span class="line">            man.EntryQueue(WomanGroup);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        GaleShapley GS=<span class="keyword">new</span> GaleShapley(<span class="keyword">new</span> In(args[<span class="number">0</span>]),<span class="keyword">new</span> In(args[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化num=1</span></span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//开始循环进行邀请</span></span><br><span class="line">        <span class="keyword">while</span>(num!=<span class="number">0</span>)&#123;</span><br><span class="line">            StdOut.printf(<span class="string">&quot;-------------------------------------------&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;\n开始一轮邀请&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;\n-------------------------------------------\n&quot;</span>);</span><br><span class="line">            num=<span class="number">0</span>;  <span class="comment">//将num设为0</span></span><br><span class="line">            <span class="comment">//男方进行一轮邀请</span></span><br><span class="line">            <span class="keyword">for</span>(Man man:GS.ManGroup)&#123;</span><br><span class="line">                num+=man.Invitation();  <span class="comment">//不断将返回值加入num</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//num仍然等于0说明一整轮都没有成功“发出”邀请</span></span><br><span class="line">            <span class="comment">//注意是发出邀请，只要女方成功接收到邀请就返回1（不需要女方一定同意邀请），否则返回0.</span></span><br><span class="line">            <span class="comment">//说明所有男性要么已经有暂时配对成功的对象，要么已经出局</span></span><br><span class="line">            <span class="comment">//这种情况就可以结束循环，打印结果了</span></span><br><span class="line">        &#125;</span><br><span class="line">        StdOut.println(<span class="string">&quot;\n最终结果\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(Man man:GS.ManGroup)&#123;</span><br><span class="line">            StdOut.printf(<span class="string">&quot;man:%c --&gt; woman:%c\n&quot;</span>,man.name(),man.GirlName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/225925804&quot;&gt;参考：经典算法问题——稳定匹配（Stable Matching）&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Gale-Shapley-Algorithms&quot;&gt;&lt;a href=&quot;#Gale</summary>
      
    
    
    
    <category term="UOA" scheme="http://ywrby.com/categories/UOA/"/>
    
    <category term="COMPSCI 320" scheme="http://ywrby.com/categories/UOA/COMPSCI-320/"/>
    
    
    <category term="算法" scheme="http://ywrby.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>COMPSCI 316: Lectrue 3</title>
    <link href="http://ywrby.com/2023/07/18/COMPSCI316-Lectrue3/"/>
    <id>http://ywrby.com/2023/07/18/COMPSCI316-Lectrue3/</id>
    <published>2023-07-18T06:18:22.000Z</published>
    <updated>2023-07-20T17:27:34.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lectrue-3"><a href="#Lectrue-3" class="headerlink" title="Lectrue 3"></a>Lectrue 3</h1><ul><li>Understand computer security</li><li>Understand human aspect of security</li><li>Understand network security</li><li>Next, we can build on these three to understand cyber security</li></ul><h1 id="OSI-安全架构"><a href="#OSI-安全架构" class="headerlink" title="OSI 安全架构"></a>OSI 安全架构</h1><p>OSI 安全架构分为三大类，即安全攻击、安全机制和安全服务。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230720025356.jpg"></p><h2 id="安全攻击（Security-attack）"><a href="#安全攻击（Security-attack）" class="headerlink" title="安全攻击（Security attack）"></a>安全攻击（Security attack）</h2><p>安全攻击是指个人或实体企图获得未经授权的访问以破坏或损害系统、网络或设备的安全性。</p><ul><li>被动攻击（Passive attack）：试图从系统中学习或利用信息，但不影响系统资源。<ul><li>窃听（Release of message content / disclosure）：攻击者在两方不知情的情况下拦截和收听他们之间的通信。</li><li>流量分析（Traffic analysis）：攻击者分析网络流量模式和元数据以收集有关系统、网络或设备的信息。入侵者无法读取消息，只能了解加密的模式和长度。可以使用多种技术执行流量分析，例如网络流量分析或协议分析。</li></ul></li><li>主动攻击（Active attack）：试图改变系统资源或影响其运行。<ul><li>伪装（Masquerade）：攻击者伪装成真实的发件人以获得对系统的未授权访问。这种类型的攻击可能涉及攻击者使用窃取或伪造的凭据，或者以其他方式操纵身份验证或授权控制。</li><li>重放（Replay）：攻击者通过被动通道拦截传输的消息，然后恶意或欺诈地重放或延迟它。</li><li>消息修改（Message modification）：攻击者修改传输的消息并使接收方收到的最终消息看起来不安全或无意义。</li><li>拒绝服务攻击（Denial of Service, DoS）：攻击者向系统、网络或设备发送大量流量，以试图使其不堪重负并使其对合法用户不可用。</li></ul></li></ul><h2 id="安全服务（Security-service）"><a href="#安全服务（Security-service）" class="headerlink" title="安全服务（Security service）"></a>安全服务（Security service）</h2><p>安全服务是指可用于维护组织安全的不同服务。它们有助于防止任何潜在的安全风险。安全服务分为6类：</p><ul><li>身份验证（Authentication）：验证用户或设备身份以授予或拒绝对系统或设备的访问权限的过程。</li><li>访问控制（Access control）或授权（authorisation）：使用策略和过程来确定允许谁访问系统内的特定资源。</li><li>机密性（Confidentiality）：保护信息不被访问或泄露给未授权方。</li><li>数据完整性（Data integrity）：使用技术来确保数据在传输或存储期间未被篡改或以任何方式更改。</li><li>不可否认性（Non-repudiation）：使用技术来创建消息来源和传输的可验证记录，防止发件人否认他们发送了消息。</li><li>可行性（Availability）：保证系统可以按需使用和访问</li></ul><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230720031629.jpg"></p><h2 id="安全机制（Security-mechanisms）"><a href="#安全机制（Security-mechanisms）" class="headerlink" title="安全机制（Security mechanisms）"></a>安全机制（Security mechanisms）</h2><p>为识别任何安全漏洞或对组织的攻击而构建的机制称为安全机制。</p><ul><li>加密（Encryption）：使用算法将数据转换为只能由具有适当解密密钥的人读取的形式。</li><li>数字签名（Digital signature）：使用密码技术为数字文档或消息创建唯一的、可验证的标识符，可用于确保文档或消息的真实性和完整性。</li><li>访问控制机制（Access control mechanism）：用于保证访问权的技术</li><li>公证（Notarisation）：使用可信任的一方来确保数据交换的安全</li><li>密码（Password）：授权方已知的秘密短语或单词</li></ul><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230720033351.jpg"></p><h1 id="Network-Security-amp-Cyber-Security"><a href="#Network-Security-amp-Cyber-Security" class="headerlink" title="Network Security &amp; Cyber Security"></a>Network Security &amp; Cyber Security</h1><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/resize,w_670.png"></p><h2 id="Network-Security"><a href="#Network-Security" class="headerlink" title="Network Security"></a>Network Security</h2><blockquote><p>Network Security is the process of taking physical and software preventative measures to protect the underlying networking infrastructure from unauthorized access, misuse, malfunction, modification, destruction, or improper disclosure, thereby creating a secure platform for computers, users and programs to perform their permitted critical functions within a secure environment</p></blockquote><h2 id="Cyber-Security"><a href="#Cyber-Security" class="headerlink" title="Cyber Security"></a>Cyber Security</h2><blockquote><p>Cyber security is the collection of tools, policies, security concepts, security safeguards, guidelines, risk management approaches, actions, training, best practices, assurance and technologies that can be used to protect the cyber environment and organization and user’s assets</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Lectrue-3&quot;&gt;&lt;a href=&quot;#Lectrue-3&quot; class=&quot;headerlink&quot; title=&quot;Lectrue 3&quot;&gt;&lt;/a&gt;Lectrue 3&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Understand computer security&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    <category term="UOA" scheme="http://ywrby.com/categories/UOA/"/>
    
    <category term="COMPSCI 316" scheme="http://ywrby.com/categories/UOA/COMPSCI-316/"/>
    
    
    <category term="网络安全" scheme="http://ywrby.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="计算机安全" scheme="http://ywrby.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>1-计算机安全概述</title>
    <link href="http://ywrby.com/2023/06/03/1-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0/"/>
    <id>http://ywrby.com/2023/06/03/1-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0/</id>
    <published>2023-06-02T18:52:47.000Z</published>
    <updated>2023-07-20T17:27:30.623Z</updated>
    
    <content type="html"><![CDATA[<p>参考书目：Computer Security: Principles and Practice, Fourth Edition, by William Stallings and Lawrie Brown. Pearson Higher Ed USA. ISBN 1292220635.</p><h1 id="计算机安全的概念"><a href="#计算机安全的概念" class="headerlink" title="计算机安全的概念"></a>计算机安全的概念</h1><h2 id="计算机安全（computer-security）的定义"><a href="#计算机安全（computer-security）的定义" class="headerlink" title="计算机安全（computer security）的定义"></a>计算机安全（computer security）的定义</h2><p>保证信息系统资产的<strong>机密性、完整性以及可用性</strong>的措施和控制方法，其中资产包括硬件、软件、固件、以及要处理、存储和通信的信息</p><p>机密性、完整性和可用性一起被并称为 CIA 三元组</p><h3 id="机密性（confidentiality）"><a href="#机密性（confidentiality）" class="headerlink" title="机密性（confidentiality）"></a>机密性（confidentiality）</h3><p>保持对信息访问和披露的限制，包括对个人隐私和专有信息保护的措施。机密性缺失是指非授权的信息披露</p><p>换言之机密性是指个人对资产的访问与披露具有控制能力，在未经许可或授权的情况下，他人无法访问相关数据。在现实中的实例就包括高校学生的教务系统，学生可以在登陆后查阅到个人的考试成绩等隐私信息，而他人在未经许可的情况下无法访问或知晓相关数据。</p><p>机密性包含两个相关概念：</p><ul><li>数据机密性：确保隐私或机密信息不被非授权的个人利用，或被泄露给非授权的个人</li><li>隐私性：确保个人能够控制或影响与自身相关的信息的收集和存储，也能够控制这些信息可以由谁披露或向谁披露</li></ul><h3 id="完整性（integrity）"><a href="#完整性（integrity）" class="headerlink" title="完整性（integrity）"></a>完整性（integrity）</h3><p>防范不正当的信息修改和破坏，包括保证信息的抵抗赖性和真实性。完整性缺失是指非授权的信息修改或破坏。</p><p>和机密性不同，完整性主要强调个人对资产的修改具有控制能力，他人在未经许可的情况下，无法修改或破坏相关数据。在现实中的实例就包括医院的过敏史信息数据库，医生可以在系统中增加修改或删除病人的相关病史，而他人不可以在未经授权的情况下修改或破坏病史，否则会造成严重的后果。</p><p>完整性包含两个相关概念：</p><ul><li>数据完整性：确保信息和程序只能在指定的和得到授权的情况下才能够改变</li><li>系统完整性：确保系统在未受损的方式下执行预期的功能，避免对系统进行有意或无意的非授权操作</li></ul><h3 id="可用性（availability）"><a href="#可用性（availability）" class="headerlink" title="可用性（availability）"></a>可用性（availability）</h3><p>确保系统能够及时响应，并且不能拒绝<strong>授权用户</strong>的服务请求。可用性缺失是指对信息或信息系统的访问和使用的破坏。</p><p>简言之，可用性就是指<strong>授权用户</strong>在任何情况下都应该能够访问系统并且获得服务。在现实中的实例就包括在线交易系统，如果交易系统可用性被破坏，授权用户无法通过系统进行资金交易，则会影响用户的交易热情，造成严重后果。</p><h1 id="威胁、攻击和资产"><a href="#威胁、攻击和资产" class="headerlink" title="威胁、攻击和资产"></a>威胁、攻击和资产</h1><p>在这里首先说明几个重要术语的概念：</p><ul><li>威胁（threat）：任何可能通过<strong>未经授权</strong>的访问、销毁、披露、修改信息以及拒绝服务而对组织运营、组织资产、个人、其他组织或国家产生不利影响的情况或事件</li><li>攻击（attack）：任何类型的恶意活动，试图收集、破坏、拒绝、降级或者破坏信息系统资源或信息本身</li><li>资产（Asset）：也叫系统资源（system resource），主要包括硬件、软件、数据、通信设施和网络</li><li>脆弱性（Vulnerability）：可能被威胁源利用或触发的信息系统、系统安全程序、内部控制或实现中的弱点</li></ul><p>与系统资源的各种安全脆弱性相对应的是利用这些安全脆弱性产生的<strong>威胁</strong>。威胁表示对资产的潜在安全危害。<strong>攻击</strong>是被实施的威胁如果成功，将会导致不期望的安全侵害或威胁的后果。执行攻击的主体被称为攻击者或者<strong>威胁主体</strong>。</p><p>可以将攻击划分为两类：</p><ul><li>主动攻击（Active attack）：试图改变系统资源或影响其运行。<ul><li>主动攻击包含对数据流进行篡改或伪造数据流，其可以划分为四类：重放、冒充、篡改和拒绝服务</li></ul></li><li>被动攻击（Passive attack）：试图从系统中学习或利用信息，但不影响系统资源。<ul><li>被动攻击的本质是是窃听或监视数据传输。攻击者的目标是获取传输的数据信息。被动狗估计的两种形式是消息内容泄露和流量分析</li></ul></li></ul><p>按照攻击的发起位置也可以将攻击分为以下两类：</p><ul><li>内部攻击（Inside attack）：由安全边界内部的实体（“内部人”）发起的攻击。在内部人是指已被授权访问系统资源，但以未经授权方许可的方式使用资源的内部实体。</li><li>外部攻击（Outside attack）：由系统安全边界外部的非授权用户或非法使用者（“外部人”）发起的攻击。</li></ul><h2 id="威胁与攻击"><a href="#威胁与攻击" class="headerlink" title="威胁与攻击"></a>威胁与攻击</h2><table><thead><tr><th>威胁后果（威胁）</th><th>威胁动作（攻击）</th></tr></thead><tbody><tr><td><strong>非授权泄露</strong><br/>实体未经授权而获得对数据访问的情况或事件</td><td>暴露：敏感数据被直接泄露给非授权实体<br/>截获：非授权实体直接访问在授权的源和目的地之间传输的敏感数据<br/>推理：非授权实体通过基于特征的推理或通信产品间接访问敏感数据<br/>入侵：非授权实体通过躲避系统安全保护措施来获得对敏感数据的访问</td></tr><tr><td><strong>欺骗</strong><br/>导致授权实体接收虚假数据并相信其正确性的情况或事件</td><td>冒充：非授权实体通过佯装成授权实体来访问系统或执行恶意行为<br/>伪造：以虚假数据欺骗授权实体<br/>抵赖：一个实体通过虚伪地否认对行为的责任而欺骗另一个实体</td></tr><tr><td><strong>破坏</strong><br/>中断或阻止系统服务和功能正确运行的情况或事件</td><td>失能：通过禁用系统组件来阻止或中断系统运行<br/>损坏：通过对系统功能或数据的不利修改来对系统运行进行非期望的改变<br/>阻碍：通过阻止系统运行来中断系统服务交付的威胁活动</td></tr><tr><td><strong>篡夺</strong><br/>导致系统服务或功能被非授权实体控制的情况或事件</td><td>盗用：实体对系统资源采取非授权的逻辑或物理控制<br/>误用：导致系统组件执行对系统有害的功能或服务</td></tr></tbody></table><h2 id="威胁与资产"><a href="#威胁与资产" class="headerlink" title="威胁与资产"></a>威胁与资产</h2><table><thead><tr><th>-</th><th>可用性</th><th>机密性</th><th>完整性</th></tr></thead><tbody><tr><td>硬件</td><td>设备被盗用或禁用，因而拒绝提供服务</td><td>未加密的 USB 设备被盗</td><td></td></tr><tr><td>软件</td><td>程序被删除，拒绝用户访问</td><td>软件的非授权拷贝</td><td>正在运行的程序被修改，使其在执行过程中失败或执行非预期任务</td></tr><tr><td>数据</td><td>文件被删除，拒绝用户访问</td><td>非授权读取数据</td><td>修改已有文件或伪造新文件</td></tr><tr><td>通信线路和网络</td><td>消息被破坏或删除。通信线路或网络不可用</td><td>消息被读取。消息被读取。消息的流量模式被观察到</td><td>消息被修改、延迟、重新排序或复制。伪造虚假消息</td></tr></tbody></table><h1 id="基本安全设计原则"><a href="#基本安全设计原则" class="headerlink" title="基本安全设计原则"></a>基本安全设计原则</h1><ul><li>经济机制（economy of mechanism）原则：安全机制的设计应当尽可能简单、短小</li><li>安全缺省设置（fail-safe default）原则：指访问控制应当基于许可而不是排除。简言之就是只有许可的操作被允许，任何不被许可或未提及的操作都视为不被允许</li><li>绝对中介（complete mediation）原则：指每一次访问都应当依据访问控制机制进行检查</li><li>开放式设计（open design）原则：指安全机制的设计应当开放而非保密</li><li>特权分离（separation of privilege）原则：细分特权，分配给多个主体，确保个体无法单独控制关键职能或系统</li><li>最小特权（least privilege）原则：每个进程和系统用户都应当使用完成某项任务必需的最少特权集进行操作</li><li>最小公用机制（least common mechanism）原则：指在设计时应当最小化不同用户共享的功能，以提高彼此的安全性。</li><li>心理可接受性（psychological acceptability）原则：指安全机制不应该过度干涉用户的工作，并且要满足用户授权访问的要求</li></ul><h1 id="攻击面和攻击树"><a href="#攻击面和攻击树" class="headerlink" title="攻击面和攻击树"></a>攻击面和攻击树</h1><p>攻击面和攻击树主要用来对威胁进行评估和分类</p><h2 id="攻击面"><a href="#攻击面" class="headerlink" title="攻击面"></a>攻击面</h2><p>攻击面由系统中可到达的和可被利用的脆弱点构成，主要分为以下三种：</p><ul><li>网络攻击面：企业网、广域网或者因特网中的脆弱点，包括网络协议中的脆弱点<ul><li>例如利用这些脆弱点进行拒绝服务攻击、通信线路破坏和各种不同形式的入侵攻击</li></ul></li><li>软件攻击面：在应用程序、实用程序或操作系统代码中的漏洞，尤其是指 Web 服务器软件的漏洞</li><li>人为攻击面：指员工或者外部人员引起的脆弱点（社会工程学）</li></ul><p>攻击面分析是评估系统威胁的规模和严重性的有用技术。对这些脆弱点及逆行系统的分析可使开发者知道哪些安全机制是必需的。一旦定义了攻击面，设计人员就可能找到减少攻击面的方法，从而使敌手入侵更加困难。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/d6348556d3274eb9a1d167293b7c4e57.png"></p><h2 id="攻击树"><a href="#攻击树" class="headerlink" title="攻击树"></a>攻击树</h2><p>攻击树是一个分支型、层次化的<strong>数据结构</strong>,表示了一系列潜在技术，这些技术可以利用安全漏洞进行攻击。</p><p>作为攻击目标的安全事件是这棵树的根节点，攻击者可以迭代、递增达到目标的途径就是这棵树的分支和子节点，每一个子节点都定义了一个子目标，每一个子目标都可能有一系列进一步的子目标。从根节点沿着路径向外延伸的最终的节点，即叶子节点，代表了发起一个攻击的不同方式。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/IMG_2079(20230716-090631).JPG"></p><h1 id="计算机安全策略"><a href="#计算机安全策略" class="headerlink" title="计算机安全策略"></a>计算机安全策略</h1><ul><li>对策：对付攻击所采取的手段<ul><li>能够成功防止特定类型的攻击</li><li>防止不可能时，检测攻击，并从攻击造成的后果中恢复</li></ul></li><li>风险：执行对策后，可能存在参与的脆弱性，被威胁代理利用<ul><li>资产所有者通过制定其他约束来实现风险最小化</li></ul></li></ul><p>计算机安全技术措施</p><ul><li>访问控制：设置权限</li><li>识别与认证：认证协议</li><li>系统和通信保护：加密</li><li>系统和信息完整性：密码工具</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考书目：Computer Security: Principles and Practice, Fourth Edition, by William Stallings and Lawrie Brown. Pearson Higher Ed USA. ISBN 12922</summary>
      
    
    
    
    <category term="UOA" scheme="http://ywrby.com/categories/UOA/"/>
    
    <category term="COMPSCI 316" scheme="http://ywrby.com/categories/UOA/COMPSCI-316/"/>
    
    
    <category term="网络安全" scheme="http://ywrby.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="计算机安全" scheme="http://ywrby.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>集乐-统一多媒体文件资源管理器</title>
    <link href="http://ywrby.com/2023/05/27/%E9%9B%86%E4%B9%90-%E7%BB%9F%E4%B8%80%E5%A4%9A%E5%AA%92%E4%BD%93%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8/"/>
    <id>http://ywrby.com/2023/05/27/%E9%9B%86%E4%B9%90-%E7%BB%9F%E4%B8%80%E5%A4%9A%E5%AA%92%E4%BD%93%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8/</id>
    <published>2023-05-26T22:24:05.000Z</published>
    <updated>2023-06-15T06:46:23.141Z</updated>
    
    <content type="html"><![CDATA[<p>项目地址：<a href="https://github.com/Ywrby/JiLe">https://github.com/Ywrby/JiLe</a></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>随着互联网的发展与短视频等流媒体展示分享方式的普及，如何同时进行多种多媒体文件资源的管理与分类逐渐成为困扰人们进行文件管理的主要问题。本项目为解决上述问题，设计了一款多媒体集成管理器，采用前后端分离的方式，使用 Electron 和 Vue.js 作为前端框架，Springboot 作为后端框架。项目主要模块分为电子书管理模块，图片管理模块以及影视资源管理模块。项目基本功能主要有：文件元数据编辑，文件标签操作，文件夹同步，高级文件搜索，本地文件操作，瀑布流展示，文件分享，应用内预览，页面自动截图，拟物播放器等。最后对系统进行了综合测试与结果分析，结果表明：项目交互性良好，兼容性高，实现了目标功能。具有实际应用意义。</p><h1 id="系统详细设计"><a href="#系统详细设计" class="headerlink" title="系统详细设计"></a>系统详细设计</h1><p>通过对项目整体进行可行性分析与需求分析，项目设计的基本方向和功能内容相对明确，项目以普通用户为设计视角，详细介绍对应功能与界面的设计和实现。</p><h2 id="系统总体架构设计"><a href="#系统总体架构设计" class="headerlink" title="系统总体架构设计"></a>系统总体架构设计</h2><p>项目总体架构设计采用前后端分离的设计模式，前端使用 Electron 和 Vue.js 作为前端开发框架，同时使用 Node.js 中的 Axios 作为网络通信库与后端通过 Http 请求进行数据通信和功能通信。后端使用 Spring boot 作为开发框架，利用 MyBatis 与 MySQL 数据库进行数据传输。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230526223546.png"></p><h2 id="系统数据库设计"><a href="#系统数据库设计" class="headerlink" title="系统数据库设计"></a>系统数据库设计</h2><p>项目内共使用 14 张数据表，表间关系通过外键相连接，下图为项目 E-R 图</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230526223732.png"></p><h3 id="数据库表设计"><a href="#数据库表设计" class="headerlink" title="数据库表设计"></a>数据库表设计</h3><p>数据表主要分为三大类，与影视资源相关数据表（vc_info,video_info,video_tag 等）与电子书资源相关数据表（ec_info,ebook_info,ebook_tag,ebook_author 等），与图片资源相关数据表（ic_info,image_info,image_tag 等）。下面以相对全面的影视资源数据表为例介绍项目建表原则。</p><center><p>表 4.1 影视合集数据表</p></center><table><thead><tr><th>字段</th><th>数据类型</th><th>说明</th></tr></thead><tbody><tr><td>ID(主键)</td><td>INT</td><td>影视合集数据表主键，唯一标识符，自增</td></tr><tr><td>VC_NAME</td><td>VARCHAR</td><td>影视合集名称</td></tr><tr><td>VC_PATH</td><td>VARCHAR</td><td>影视合集所在文件夹路径</td></tr><tr><td>VC_DESC</td><td>VARCHAR</td><td>影视合集简介</td></tr><tr><td>VC_COVER</td><td>VARCHAR</td><td>影视合集封面（缓存）</td></tr></tbody></table><center><p>表4.2 视频资源数据表</p></center><table><thead><tr><th>字段</th><th>数据类型</th><th>说明</th></tr></thead><tbody><tr><td>VC_ID</td><td>INT</td><td>视频资源所属影视合集 ID，外键</td></tr><tr><td>videoID</td><td>INT</td><td>视频资源主键，视频资源唯一标识符，自增</td></tr><tr><td>videoName</td><td>VARCHAR</td><td>视频资源名称，即用于辨识也用于标识路径</td></tr><tr><td>videoCover</td><td>VARCHAR</td><td>视频资源封面（缓存）</td></tr><tr><td>videoScore</td><td>TINYINT</td><td>0-5 数字，用于表示用户对视频的评分</td></tr><tr><td>Followed</td><td>TINYINT</td><td>0 或 1 数字，用于表示用户是否关注该视频</td></tr><tr><td>Intro</td><td>VARCHAR</td><td>视频资源简介</td></tr><tr><td>releaseDate</td><td>DATETIME</td><td>视频资源发布日期</td></tr><tr><td>url</td><td>VARCHAR</td><td>视频资源相关网址链接</td></tr></tbody></table><h2 id="项目前端界面功能设计"><a href="#项目前端界面功能设计" class="headerlink" title="项目前端界面功能设计"></a>项目前端界面功能设计</h2><p>整个项目中，界面展示部分作为用户最直接接触以及感知的部分，对用户的第一使用体验以及软件综合感受起着决定性作用。在界面设计过程中应严格以用户使用体验为第一要义，同时保证软件使用过程中的功能完善以及呈现效果等方面。</p><h3 id="综合展示模块界面设计"><a href="#综合展示模块界面设计" class="headerlink" title="综合展示模块界面设计"></a>综合展示模块界面设计</h3><p>综合展示模块负责统计并展示不同类型资源合集相关情况以及进行随机的相关资源推荐，主要分为书库综合展示，图集综合展示以及影集综合展示部分。该模块是用户在进入软件后首先要体验到的部分，也是最高层面上管理整个多媒体资源集成管理器系统内文件的模块。</p><p>该部分流程主要为用户进入系统后点击进入指定类型文件综合管理模块内部，展示界面分别对随机推荐的相关类型文件进行展示，同时对该类型下所有合集内容进行展示，展示内容包括合集名称，合集封面以及合集基本简介等。</p><p>用户右键点击指定合集卡片，弹出扩展操作选项，主要分为打开书库详情界面，编辑书库元数据，删除指定书库，在文件夹内按路径打开指定书库。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230526224421.png"></p><p>在该过程中文件夹默认打开指定合集路径涉及到对系统进行直接操作，其主要操作流程见下图。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230526224452.png"></p><h3 id="书库展示界面设计"><a href="#书库展示界面设计" class="headerlink" title="书库展示界面设计"></a>书库展示界面设计</h3><p>在设计书库展示界面时，应考虑到用户的实际体验，一方面要兼顾图书信息的全面展示，另一方面应尽可能简化用户操作降低用户学习成本。综上，主要应综合保证以下内容：</p><ol><li>界面布局：应该采用简洁明了的布局方式，使得用户可以快速浏览和选择电子书，可以使用网格布局、列表布局等方式来展示电子书。</li><li>电子书信息：应该展示电子书的基本信息，如书名、作者、出版社、出版时间、简介等，方便用户了解电子书的基本情况。</li><li>封面展示：应该展示电子书的封面图片，以吸引用户的眼球，同时方便用户快速识别电子书。</li><li>排序和筛选：应该提供排序和筛选功能，方便用户按照自己的需求进行电子书的选择和浏览。</li><li>评分和评论：应该提供用户评分和评论的功能，方便用户了解其他用户的评价和意见，同时也可以为其他用户提供参考。</li><li>搜索功能：应该提供搜索功能，方便用户快速查找自己需要的电子书，提高用户的使用效率。</li><li>标签功能，每个资源身上可以打上一系列“标签”, 以表明这个资源的属性, 对其进行分类。“标签”具有层次性, 是资源类别的一个体现[5]。<br>总的来说，一个好的电子书合集界面应该简洁明了、易于使用、能够满足用户的需求，并且提供优秀的用户体验。</li></ol><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230526224553.png"></p><p>在进行高级搜索过程中，主要流程是在搜索界面首先进行搜索类型的类型选择，确定是按照书名，作者，出版商还是其他内容进行搜索。确定好搜索类型后，进行搜索内容的输入，前端在接收到搜索内容后对搜索内容进行切分，随后将相关数据传输到后端进行模糊查询，前端向后端发送请求过程中需要调用 Node.js 下的 Axios 库进行网络通信，Axios 是一款易用、简洁且高效的 http 库，是一个可以用在浏览器和 Node.js 中的异步通信框架，其主要作用就是实现 Ajax 异步通信，由于 Vue 只关注视图层内容，使用 Axios 更为便捷。使用 Axios 控制网络通信过程具有以下特点：（1）从浏览器中创建 XMLHttpRequests，（2）从 node.js 创建 http 请求，（3）支持 Promise API（在 JS 中进行链式编程），（4）拦截请求和相应，（5）转换请求数据和响应数据，（6）取消请求，（7）自动转换 JSON 数据，（8）客户端支持防御 XSRF。整个高级搜索流程如下图所示</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230526224615.png"></p><h3 id="图集展示界面"><a href="#图集展示界面" class="headerlink" title="图集展示界面"></a>图集展示界面</h3><p>图集展示界面需要同时对用户的大量图片进行展示，以瀑布流形式进行整个内容的展示相对更加合理，在该过程中需要注意到：</p><ol><li>图片尺寸和比例：瀑布流展示图片的界面中，图片的尺寸和比例是非常重要的。应该确保每一张图片都能够清晰地展示，同时不影响用户体验。</li><li>瀑布流布局：瀑布流布局的设计应该考虑到用户的浏览习惯，让用户能够轻松浏览大量图片，同时不会感到拥挤或混乱。布局应该简洁明了，突出重点。</li><li>加载速度和响应速度：瀑布流展示图片需要大量的图片数据，因此加载速度和响应速度非常重要。应该采用高效的代码和缓存机制，确保界面能够快速加载和响应用户的操作。</li><li>用户交互：瀑布流展示图片的界面中，用户交互是非常重要的。应该设计简单、直观的交互方式，让用户能够快速地浏览、筛选和返回上一页/页码等操作。</li><li>颜色和字体：颜色和字体的设计应该考虑到整个界面的协调性和可读性。应该采用明亮、清晰的颜色和字体，确保用户能够轻松识别信息和进行操作。</li><li>可访问性：瀑布流展示图片的界面应该考虑到可访问性，确保所有功能和信息都能够方便地访问和使用。应该采用易于理解和使用的导航和搜索功能，同时考虑到视力和听力有障碍的用户使用。</li></ol><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230526224721.png"></p><p>在实现瀑布流的过程中，步骤主要分为：</p><ol><li>初始化数据：首先需要从后端或缓存中获取瀑布流所需的图片数据，并将其存储在本地或缓存中。</li><li>设置瀑布流容器：创建瀑布流容器，通常使用 HTML 元素，例如<code>&lt;div&gt;</code>或<code>&lt;canvas&gt;</code>。</li><li>设置瀑布流布局：根据所需的瀑布流布局，例如流式布局或分块布局，使用 CSS 设置瀑布流容器的样式。</li><li>加载图片：使用 JavaScript 异步加载图片，并将其添加到瀑布流容器中。可以使用 HTML5 的<code>&lt;img&gt;</code>标签或 Canvas 元素加载图片。</li><li>设置瀑布流事件：设置事件监听器，例如点击事件或滚动事件，以便用户可以与瀑布流交互，对瀑布流布局大小进行调整。</li><li>更新瀑布流：当图片数据更新或用户交互时，需要更新瀑布流的布局和样式。</li><li>缓存图片：由于需要同时加载大量图片，提前对图片进行缓存可以大大减少系统加载实践，提高用户使用体验。</li><li>优化性能：为了提高瀑布流的性能和用户体验，可以使用图片懒加载等设计，避免过多图片同时加载造成系统崩溃。</li></ol><p>在进行主色调分析过程中，需要从后端进行图片的加载以及主色调分析，具体流程如下图所示。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230526224839.png"></p><h3 id="影集展示界面"><a href="#影集展示界面" class="headerlink" title="影集展示界面"></a>影集展示界面</h3><p>在设计影视资源展示界面的过程中，首先应该注意的是如何设计一个用户友好的交互界面，让用户可以轻松地浏览、搜索、播放视频。在交互设计中，需要考虑用户的使用习惯、心理需求等因素，以提高用户体验。综合用户日常使用视频网站的行为习惯与可能性，将影视资源的展示界面向主流视频媒体网站设计是一个相对正确可行的方向。</p><p>一方面，以封面图作为每个视频资源展示的核心内容，占据展示界面的主要位置，另一方面，完善的功能栏在下方作为辅助工具，帮助用户在使用过程中可以便捷的对指定视频资源进行高效的控制编辑等操作。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230526224913.png"></p><p>封面作为视频资源的重要展示因素，可以很大程度上说明视频的主要内容，部分视频网站采用用户上传封面的形式进行封面展示，这种方式能够准确的由用户控制封面展示内容但相对繁琐，本地系统一般会随机生成视频封面，十分便捷却容易出现封面混乱等问题，项目设计过程中支持用户自行上传或是随机生成封面，最大程度上满足用户核心需求，而随机生成封面的过程中涉及到对视频核心数据的获取与随机帧数的生成，大致流程如图所示。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230526224937.png"></p><p>除此以外，对于影视资源而言最重要的就是如何在应用内进行信息和流媒体内容的展示和播放，普通形式的播放器无论从使用便利性角度还是趣味性角度而言都相对薄弱，所以在设计播放器形式过程中项目引入拟物设计的形式，拟物设计可以让用户更好地理解和使用网页。它模拟了现实世界中的物品和操作方式，让用户更容易上手，从而提高用户满意度。同时拟物设计可以让网页看起来更加真实，用户可以更自然地操作和感知网页的内容和功能。这种设计方式能够提高用户的体验和忠诚度吗。另外拟物设计可以让用户感觉更受信任，因为它模拟了现实世界中的操作方式。这种设计方式可以增加用户的信任感。</p><p>综上所述，项目对播放器进行了拟物设计。以 Nintendo Switch（任天堂公司生产的掌上游戏机）为原型，进行视频播放器的设计。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230526225011.png"></p><h2 id="项目后端功能设计"><a href="#项目后端功能设计" class="headerlink" title="项目后端功能设计"></a>项目后端功能设计</h2><p>项目后端使用 SpringBoot 作为后端开发框架，使用 MyBatis 作为持久层开发框架，严格遵守 MVC 三层结构的设计过程。控制器层作为应用程序中用于处理用户输入和控制应用程序流程的部分，负责接收用户输入，调用模型层进行数据处理，并将处理结果传递给视图层进行显示。视图层作为应用程序中用于呈现用户界面的部分，负责将模型层中的数据呈现给用户。模型层则是应用程序中用于处理业务逻辑和数据处理的部分，负责处理数据的存储、检索、更新等操作。<br>在开发过程中，后端主要处理业务逻辑以及实际功能实现，并对外提供接口供前端调用。</p><p>这个过程中就包括，设计数据库结构和建立数据表，根据业务需求，设计并建立相应的数据表，用于存储多媒体资源的相关信息，例如视频、图片、电子书的名称、路径、大小、上传时间等。实现数据访问层，利用 Mybatis 框架实现数据访问层以进行对数据库的相关操作，包括定义数据访问接口和实现数据访问接口，用于对数据库进行增删改查等操作。实现业务逻辑层，在控制器层和数据访问层之间实现业务逻辑层，用于处理业务逻辑，例如主色调分析、分页处理等。实现控制器层，使用 Springboot 框架实现控制器层，处理前端的请求，调用业务逻辑层和数据访问层，返回处理结果给前端。编写测试用例：编写测试用例，对后端代码进行单元测试和集成测试，确保代码的正确性和可靠性。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230527060848.png"></p><h1 id="系统具体实现"><a href="#系统具体实现" class="headerlink" title="系统具体实现"></a>系统具体实现</h1><h2 id="全部书库展示界面"><a href="#全部书库展示界面" class="headerlink" title="全部书库展示界面"></a>全部书库展示界面</h2><p>在设计全部书库的展示界面时，一方面要重视界面的美观与简洁，另一方面也要保证用户的功能体验充足且高效，所以全部书库界面设计从第一视角分为两个主要部分。</p><p>界面上方为随机推荐部分，会从数据库随机读取指定数目的电子书数据，以其封面生成走马灯，用户可以通过点击走马灯上的图片使用默认方式打开电子书文件。</p><p>界面下部分为各个书库展示界面，每个展示卡片左半部分为书库封面，右半部分则为书库的名称与简介，单击书库卡片则会跳转对应书库界面，右键则会弹出响应补充功能按钮：打开书库，编辑书库，删除书库，以及打开书库所在文件夹。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230527060944.png"></p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230527060956.png"></p><h2 id="书库展示界面"><a href="#书库展示界面" class="headerlink" title="书库展示界面"></a>书库展示界面</h2><p>界面最上方展示功能栏，功能栏第一项为上传书籍按钮，点击后调用系统文件管理器进行电子书文件选择并上传，第二项为刷新与同步按钮，点击后对本地电子书库进行数据同步，并刷新数据库，第三项为多功能搜索栏，用户可以根据指定搜索条件进行书籍的搜索。</p><p>功能栏下方为电子书展示与选择界面，用户可以查看所有电子书基本信息（书名，作者，出版商，评分，语言，出版日期，书号，页数，类型，标签等），并且可以根据指定栏目进行数据的排序展示。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230527061023.png"></p><p>界面右部分为电子书详细信息展示界面，最上方展示电子书封面，右键电子书封面部分，弹出补充功能栏，主要有默认方式打开，书籍元数据编辑，移除书籍，文件夹打开以及豆瓣搜索指定书籍。封面下方展示书籍详细信息，最下方为对应功能按钮：编辑元数据信息，默认方式打开电子书以及移除电子书。</p><p>拖拽上传是一种非常简单的文件上传方式，不需要进行复杂的选择或点击操作，只需要在文件管理器中拖拽文件或文件夹到上传窗口即可。这种方式能够节省用户的时间，提高上传效率。支持多文件上传，用户可以将多个文件或文件夹拖拽到上传窗口中，然后一次性上传它们。这种方式能够帮助用户快速上传大量文件，节省时间和精力。项目重新实现了全局拖拽上传方式，具体核心代码见附录 1-核心代码 1：拖拽上传图书（前端）。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230527061053.png"></p><h2 id="书籍元数据编辑界面"><a href="#书籍元数据编辑界面" class="headerlink" title="书籍元数据编辑界面"></a>书籍元数据编辑界面</h2><p>编辑书籍元数据界面，在用户点击功能键后弹出，界面左半部分以展示封面图为主，最上方展示封面图，图片下方是切换封面图按钮，点击后调出系统文件选择器进行图片选择并缓存后设置为封面，最下方是切换收藏状态按钮。界面右部分是编辑书籍元数据表单，按照书籍内数据特性分配表单选项情况。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230527061118.png"></p><h2 id="全部图集界面"><a href="#全部图集界面" class="headerlink" title="全部图集界面"></a>全部图集界面</h2><p>全部图集界面基本与全部书库界面保持一致，上方从数据库随机选择进行随机图片资源推荐，下方以栅栏式进行书库卡片的设计，自适应界面大小变化，其余功能键也与全部书库界面基本保持一致。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230527061147.png"></p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230527061156.png"></p><h2 id="图集展示界面-1"><a href="#图集展示界面-1" class="headerlink" title="图集展示界面"></a>图集展示界面</h2><p>图集展示界面采用瀑布流式布局进行展示，一方面瀑布流布局可以使页面看起来更加美观，具有视觉冲击力。图片、文字、视频等元素可以根据不同的尺寸、比例进行排列，使得整个页面呈现出错落有致的感觉，给人以美感。另一方面瀑布流布局可以让用户轻松地快速浏览大量内容，不需要像传统布局方式一样翻页或者滚动到底部查看更多内容，用户可以浏览更多的内容，提高了用户的使用体验。同时，瀑布流布局可以节约页面空间，因为它可以让网页上的元素紧凑地排列，使得页面可以呈现更多内容，同时使得页面不显得过于拥挤。最重要的是瀑布流布局可以适应不同屏幕尺寸，因为它可以根据屏幕宽度自动调整元素的排列方式，从而使得页面可以在不同的设备上呈现出最佳的布局效果。</p><p>项目中重写了整个瀑布流的实现逻辑，保证了完整实现后的瀑布流更加适应桌面化应用开发与使用，同时为瀑布流增加了除自适应宽度外的手动调节栅栏宽度大小功能，用户可以通过功能键或者快捷键（CTRL+鼠标滚轮上滑/下滑）进行页面中瀑布流栅栏宽度的自定义。</p><p>界面上方为图集展示界面分页部分与功能区，主要包括返回按钮与瀑布流宽度调节按钮以及同步功能键和文件上传功能键。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230527061241.png"></p><h2 id="图集元数据编辑界面"><a href="#图集元数据编辑界面" class="headerlink" title="图集元数据编辑界面"></a>图集元数据编辑界面</h2><p>在图集展示界面单击图片会展开图片资源展示与编辑界面栏，界面最上方是图片资源预览缓存图，图片下方展示图片的五个主色调色块，单击或右键可以选择复制色块的 RGB 值或 16 进制值。随后的是收藏状态切换栏，之后是图片信息编辑栏，支持用户编辑图片的相关网址链接，图片基本信息或简介，以及图片的标签内容。最下方是图片基本信息内容，会调用系统指令分析图片的分辨率，类型以及创建日期等基本信息。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230527061307.png"></p><h2 id="图片详情界面"><a href="#图片详情界面" class="headerlink" title="图片详情界面"></a>图片详情界面</h2><p>点击图片下方链接或者右键进入详情，即可进入图片详情界面，页面分为左右两个卡片界面，左半部分卡片主要进行图片内容的展示，点击缓存图片可以唤起预览窗口，在应用内预览图片情况，下方进行图片主色调分析，将图片的五个主色调以色块的形式进行展示。最下方对应两个主要功能键，页面截图和文件夹内打开。</p><p>页面右半部分则是功能键与基本信息展示卡片，最上方三个按钮分别支持用户将图片分享至 QQ 空间与微信或是复制文件路径，下方展示了图片的评分，相关链接，图片信息备注，标签，创建日期以及分辨率和图片类型等基本信息。最后一部分则是默认方式打开图片以及收藏状态切换按钮。</p><p>为了方便用户在使用过程中将软件内图片或使用情况分享给其他用户，项目重写了页面截图功能方法</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230527061346.png"></p><h2 id="全部影集界面"><a href="#全部影集界面" class="headerlink" title="全部影集界面"></a>全部影集界面</h2><p>全部影集界面设计方案与前面两部分（全部书库，全部图集）异曲同工，上半部分进行影视的随机推荐，点击后唤起默认视频播放器进行播放。页面下半部分以栅栏式进行书库卡片的设计，自适应界面大小变化，其余功能键也与全部书库界面基本保持一致。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230527061418.png"></p><h2 id="影集展示界面-1"><a href="#影集展示界面-1" class="headerlink" title="影集展示界面"></a>影集展示界面</h2><p>影集展示界面主要参考主流视频网站设计方式，以分立格式对视频资源进行管理，上方提供视频上传功能按钮以及本地文件同步功能。</p><p>下方逐个展示视频资源，展示栏大小同样使用栅栏式设计，随页面大小变化进行动态变化，每个视频展示栏上方展示封面，封面支持自动生成或主动上传，下方展示视频评分，名称以及功能键栏，用户可以通过功能栏，修改视频基本信息，默认方式打开，文件夹内打开或是删除指定视频。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230527061449.png"></p><h2 id="视频元数据编辑界面"><a href="#视频元数据编辑界面" class="headerlink" title="视频元数据编辑界面"></a>视频元数据编辑界面</h2><p>编辑视频基本信息界面，左半部分为视频封面以及收藏状态修改按钮，用户可以通过在此处修改视频封面，右半部分为视频基本信息编辑表单，按照每个栏目相关属性对表单进行优化，方便用户快捷修改，提高用户使用体验。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230527061527.png"></p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230527061537.png"></p><h2 id="视频详情展示界面"><a href="#视频详情展示界面" class="headerlink" title="视频详情展示界面"></a>视频详情展示界面</h2><p>影视详情界面，最上方展示视频名称，下方以标签形式展示视频相关 tag，随后是视频基本信息卡片，分栏形式展示视频的简介，导演，编剧，演员等相关人员，上映日期，相应链接，以及帧长，时长，声道等细节信息，最下方是默认播放按钮以及收藏状态切换栏。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230527061606.png"></p><p>最下方重写了原生视频播放器，对视频播放器进行拟物设计，并实现相应功能键。实现了对视频的播放/暂停切换，音量调节，进度调节，页面截图，视频搜做，静音，重置播放器，全屏切换，返回等功能。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/20230527061624.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/Ywrby/JiLe&quot;&gt;https://github.com/Ywrby/JiLe&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要</summary>
      
    
    
    
    <category term="项目开发" scheme="http://ywrby.com/categories/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Electron" scheme="http://ywrby.com/tags/Electron/"/>
    
    <category term="Java" scheme="http://ywrby.com/tags/Java/"/>
    
    <category term="JavaWeb" scheme="http://ywrby.com/tags/JavaWeb/"/>
    
    <category term="Vue" scheme="http://ywrby.com/tags/Vue/"/>
    
    <category term="集乐" scheme="http://ywrby.com/tags/%E9%9B%86%E4%B9%90/"/>
    
    <category term="开发记录" scheme="http://ywrby.com/tags/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>集乐-统一多媒体文件资源管理器-开发记录</title>
    <link href="http://ywrby.com/2022/10/04/%E9%9B%86%E4%B9%90-%E7%BB%9F%E4%B8%80%E5%A4%9A%E5%AA%92%E4%BD%93%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8-%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
    <id>http://ywrby.com/2022/10/04/%E9%9B%86%E4%B9%90-%E7%BB%9F%E4%B8%80%E5%A4%9A%E5%AA%92%E4%BD%93%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8-%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/</id>
    <published>2022-10-03T14:18:40.000Z</published>
    <updated>2023-06-15T06:46:15.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开发初衷"><a href="#开发初衷" class="headerlink" title="开发初衷"></a>开发初衷</h1><p>市面上常见的多媒体资源管理器并不少见，比如很有名的本地电子书管理工具-Calibre，图片管理工具-Eagle，以及音频爱好者喜爱的foobar2000。它们在各自的领域内都完美解决了诸多痛点，但人的需求是在不断变化的，互联网的环境也是在不断发生改变的。</p><p>作为一名仓鼠党，很多时候面对资源的收集与整理都会手足无措，起初多媒体文件数量相对较少的情况下，可以采用较为随意的管理方式对文件进行管理，但随着文件资源数量的增加，如果没有或缺乏一个合理的文件管理方式就会导致文件之间关系混乱，渐渐地，自己也会疲于维护与管理。而避免这种问题的方式就是通过文件管理工具对我们收集的资源或文件进行统一管理。</p><p>理想的情况是我们在软件使用初期定义我们的行为习惯，后续我们只需要将所有文件统一化的保存，工具就会帮我们进行统一的管理。这种管理方式在Calibre中就有所体现，我们在初次使用过程中定义电子书的保存地址，同时定义我们的元数据链接，后续我们在保存电子书的过程中就可以自动帮我们利用元数据链接（豆瓣，亚马逊等）获取电子书基本信息，从而进行统一管理。</p><p>而现有的多媒体文件资源管理器应用虽然数量众多，但有些在功能性上有所欠缺，有些在兼容性上出现问题，无法真正确保对大部分资源的统一管理。所以才有了开发针对于个人的统一多媒体文件资源管理器的想法。</p><h1 id="功能分析"><a href="#功能分析" class="headerlink" title="功能分析"></a>功能分析</h1><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%99%BD%E6%9D%BFdhuahdshahdsa22.jpg" alt="暂定合集类型"></p><h1 id="开发过程记录"><a href="#开发过程记录" class="headerlink" title="开发过程记录"></a>开发过程记录</h1><h2 id="图片的瀑布流展示实现"><a href="#图片的瀑布流展示实现" class="headerlink" title="图片的瀑布流展示实现"></a>图片的瀑布流展示实现</h2><p>瀑布流实现的主要思路是：</p><ol><li>确定所有图片的固定宽度</li><li>实时监听-获取窗口当前宽度</li><li>根据图片固定宽度和窗口宽度确定每行排列的图片数量</li><li>依次获取图片信息，准备开始进行瀑布流渲染</li><li>根据图片原尺寸信息以及固定宽度进行图片的缩放并保存缩放后的图片长度</li><li>第一行图片只需要按照顺序依次渲染图片</li><li>从第二行开始，根据之前保存的缩放图片长度确定当前最短列，在该位置渲染图片，直到整个渲染过程结束</li></ol><p>瀑布流扩展功能：</p><ol><li>通过功能键（CTRL+鼠标滚轮滑动）实现图片的放大缩小（主要在于调整图片的固定宽度计算图片新长度以及重新实现渲染图片过程）</li><li>懒加载，在滑动到图片位置前不加载图片以节省系统开销</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">el-scrollbar</span> <span class="attr">v-if</span>=<span class="string">&quot;targetVal == contentArr.length&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;enlargeImage&quot;</span>&gt;</span>enlargeImage<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;decreaseImage&quot;</span>&gt;</span>decreaseImage<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;getContentArr&quot;</span>&gt;</span>getContentArr<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;position: relative&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(column, index) in columns&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span> <span class="attr">class</span>=<span class="string">&quot;column&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, i) in column.columnArr&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;i&quot;</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; width: itemWidth + &#x27;px&#x27; &#125;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">el-image</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">              <span class="attr">:src</span>=<span class="string">&quot;item.src&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">              <span class="attr">fit</span>=<span class="string">&quot;cover&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">              <span class="attr">:style</span>=<span class="string">&quot;&#123; height: item.height + &#x27;px&#x27;, width: itemWidth + &#x27;px&#x27; &#125;&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">              <span class="attr">class</span>=<span class="string">&quot;image&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">              <span class="attr">lazy</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            /&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">el-scrollbar</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">props</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//从父组件获取图集信息</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">contentArr</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">type</span>: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">required</span>: <span class="literal">true</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">itemWidth</span>: <span class="number">220</span>, <span class="comment">//默认图片框宽度</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">targetVal</span>: <span class="number">0</span>, <span class="comment">//标志值，用来记录已读取图片信息数目，待全部读取完成后显示瀑布流</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">columns</span>: [],</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">arrIndex</span>: []</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">// pageSize: 25,</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">// startPage: 1,</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">// pageNum: 1</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">watch</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//监听标志值变化，直到所有图片长度成功获取</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">targetVal</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="function"><span class="title">handler</span>(<span class="params">newValue, oldValue</span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">if</span> (newValue == <span class="built_in">this</span>.contentArr.length) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="built_in">this</span>.initPage()</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">immediate</span>: <span class="literal">true</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="built_in">this</span>.getImgHeight()</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">// this.initPage()</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//监听键盘与鼠标（CTRL+鼠标滚轮）实现瀑布流图片缩放</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="built_in">this</span>.keyDownAndScroll()</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//初始化页面</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">initPage</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">//调用初始化方法</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">this</span>.init()</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">//在页面大小出现变化时重新加载瀑布流</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">window</span>.onresize = <span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">this</span>.init()</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//获取当前列下最短长度位置（用来确定下一张图片插入位置）</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">getMinHeight</span>(<span class="params">arr</span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">let</span> a = []</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        a.push(<span class="built_in">parseInt</span>(arr[i].height) + <span class="built_in">parseInt</span>(arr[i].top))</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">return</span> <span class="built_in">Math</span>.min.apply(<span class="literal">null</span>, a)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//获取指定长度位置后，进一步获取该位置索引值以确定图片插入位置</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">getMinIndex</span>(<span class="params">val</span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.columns.length; i++) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">let</span> height = <span class="built_in">this</span>.columns[i].columnArr[<span class="built_in">this</span>.columns[i].columnArr.length - <span class="number">1</span>].height</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">let</span> top = <span class="built_in">this</span>.columns[i].columnArr[<span class="built_in">this</span>.columns[i].columnArr.length - <span class="number">1</span>].top</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">if</span> (<span class="built_in">parseInt</span>(height) + <span class="built_in">parseInt</span>(top) == val) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="built_in">this</span>.arrIndex.push(i)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//异步获取图像宽高等基本信息</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">async</span> <span class="function"><span class="title">getImgHeight</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">//在异步方法下的this与JS全局中的this意义不同，</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">//所以在方法开始时重新定义全局this变量用来获得全局数据</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">let</span> sel = <span class="built_in">this</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">//遍历contentArr（从父组件获取并传递过来）</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.contentArr.length; i++) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">console</span>.log(i)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">let</span> img = <span class="keyword">new</span> Image() <span class="comment">//初始化图像对象</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">//获取指定图像（在请求路径后加入随机数保证强制刷新请求）</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        img.src = <span class="built_in">this</span>.contentArr[i].src + <span class="string">&#x27;?&#x27;</span> + <span class="built_in">Date</span>.parse(<span class="keyword">new</span> <span class="built_in">Date</span>())</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">//利用promise异步构造获取图像宽高等基本信息</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">reslove</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="keyword">let</span> scale = sel.itemWidth / img.width <span class="comment">//通过固定宽度计算长度缩放比例</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="keyword">let</span> width = img.width</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="keyword">var</span> height = <span class="built_in">Math</span>.floor(scale * img.height) <span class="comment">//对原长度进行缩放（height是真实展示在页面上的长度）</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="keyword">let</span> trueHeight = img.height <span class="comment">//同时保存图片的实际长度（文件真实长度，用来方便后续在同步方法中刷新展示长度）</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="comment">//将展示长度与真实长度作为返回值传递出去</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="keyword">let</span> data = &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">              <span class="attr">height</span>: height,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">              <span class="attr">trueHeight</span>: trueHeight,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">              <span class="attr">width</span>: width</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            reslove(data)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">await</span> promise</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">//等待异步方法执行完成后，对图片列表数据进行刷新</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="built_in">console</span>.log(data)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          sel.contentArr[i].height = data.height</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          sel.contentArr[i].trueHeight = data.trueHeight</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          sel.contentArr[i].width = data.width</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          sel.targetVal++</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//测试方法，打印contentArr</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">getContentArr</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.contentArr)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//刷新图片高度</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">refreshImageHeight</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">//刷新图片高度（用于在页面中通过CTRL+鼠标滚轮或滑动条动态调整图片宽度后进行图片高度的刷新）</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">//由于在页面初始化中执行的getImgHeight方法已经获取到了图片的真实高度，</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">//所以在此处就只需要重新计算宽度修改过之后的长度缩放比例以及新的高度（避免了在刷新页面过程中使用异步方法）</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.contentArr.length; i++) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">//计算缩放比例</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">let</span> scale = <span class="built_in">this</span>.itemWidth / <span class="built_in">this</span>.contentArr[i].width</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">let</span> trueHeight = <span class="built_in">this</span>.contentArr[i].trueHeight</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">let</span> height = <span class="built_in">Math</span>.floor(scale * trueHeight) <span class="comment">//对原长度进行缩放（height是真实展示在页面上的长度）</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">//更新刷新后的新高度</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">this</span>.contentArr[i].height = height</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">// console.log(this.contentArr[i])</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//初始化（重载）页面瀑布流</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">this</span>.columns = []</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">let</span> contentLen = <span class="built_in">this</span>.contentArr.length</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">// let contentLen = this.pageSize</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">// 根据可视区域的宽度判断需要几列</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">let</span> cWidth = <span class="built_in">document</span>.documentElement.clientWidth || <span class="built_in">document</span>.body.clientWidth</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">// 假设图片宽度为240px</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">let</span> cLen = <span class="built_in">Math</span>.floor(cWidth / (<span class="built_in">this</span>.itemWidth + <span class="number">20</span>) - <span class="number">1</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">console</span>.log(cLen)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">// 初始化每一列的第一行元素</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cLen; i++) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">this</span>.contentArr[i].top = <span class="number">0</span> <span class="comment">//预设距离顶部值为0</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">this</span>.columns.push(&#123; <span class="attr">columnArr</span>: [<span class="built_in">this</span>.contentArr[i]] &#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">// 对剩余元素的判断，应该放到哪一列</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">for</span> (<span class="keyword">var</span> index = cLen; index &lt; contentLen; index++) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">this</span>.arrIndex = []</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">let</span> arr = [] <span class="comment">//找到高度最小的一列，可能有多个</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">let</span> minHeight = <span class="number">0</span> <span class="comment">//高度最小的一列的高度</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">let</span> pushIndex = <span class="number">0</span> <span class="comment">//高度最小的一列所在位置的索引</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.columns.length; i++) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          arr.push(&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="attr">height</span>: <span class="built_in">this</span>.columns[i].columnArr[<span class="built_in">this</span>.columns[i].columnArr.length - <span class="number">1</span>].height,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="attr">top</span>: <span class="built_in">this</span>.columns[i].columnArr[<span class="built_in">this</span>.columns[i].columnArr.length - <span class="number">1</span>].top</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          &#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        minHeight = <span class="built_in">this</span>.getMinHeight(arr)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">this</span>.getMinIndex(minHeight)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">if</span> (<span class="built_in">this</span>.arrIndex.length &gt; <span class="number">0</span>) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          pushIndex = <span class="built_in">Math</span>.min.apply(<span class="literal">null</span>, <span class="built_in">this</span>.arrIndex) <span class="comment">//出现高度一样的，去索引最小的</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">this</span>.contentArr[index].top = minHeight + <span class="number">20</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">this</span>.columns[pushIndex].columnArr.push(<span class="built_in">this</span>.contentArr[index])</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//图像放大（宽度加10）</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">enlargeImage</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">this</span>.itemWidth += <span class="number">10</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">this</span>.refreshImageHeight()</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">this</span>.init()</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//图片缩小（宽度减10）</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">decreaseImage</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">this</span>.itemWidth -= <span class="number">10</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">this</span>.refreshImageHeight()</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">this</span>.init()</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">// 监听键盘和鼠标滚轮组合</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">keyDownAndScroll</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">let</span> ctrlDown = <span class="literal">false</span> <span class="comment">//ctrl按键按压情况</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      ;(<span class="built_in">document</span>.onkeydown = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">//事件对象兼容</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">let</span> e1 = e || event || <span class="built_in">window</span>.event || <span class="built_in">arguments</span>.callee.caller.arguments[<span class="number">0</span>]</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">//按下CTRL键下后记录当前情况</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">if</span> (e1.keyCode === <span class="number">17</span>) ctrlDown = <span class="literal">true</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;),</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        (<span class="built_in">document</span>.onkeyup = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="keyword">let</span> e1 = e || event || <span class="built_in">window</span>.event || <span class="built_in">arguments</span>.callee.caller.arguments[<span class="number">0</span>]</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="comment">//松开后修改CTRL键按压情况</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="keyword">if</span> (e1.keyCode === <span class="number">17</span>) ctrlDown = <span class="literal">false</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;),</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">//监听鼠标滚轮情况</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">document</span>.addEventListener(</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="string">&#x27;mousewheel&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="comment">// e.preventDefault()</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="keyword">let</span> e1 = e || event || <span class="built_in">window</span>.event || <span class="built_in">arguments</span>.callee.caller.arguments[<span class="number">0</span>]</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="comment">//判断CTRL键是否被按下</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="keyword">if</span> (ctrlDown) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">              <span class="keyword">if</span> (e1.wheelDeltaY &gt; <span class="number">0</span>) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="comment">// 放大</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="built_in">console</span>.log(<span class="string">&#x27;放大&#x27;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="built_in">this</span>.enlargeImage()</span></span></span><br><span class="line"><span class="javascript"><span class="xml">              &#125; <span class="keyword">else</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="comment">// 缩小</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="built_in">console</span>.log(<span class="string">&#x27;缩小&#x27;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="built_in">this</span>.decreaseImage()</span></span></span><br><span class="line"><span class="javascript"><span class="xml">              &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="literal">false</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        )</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h1 id="开发进度"><a href="#开发进度" class="headerlink" title="开发进度"></a>开发进度</h1><table><thead><tr><th>日期</th><th>完成内容</th><th>待处理</th></tr></thead><tbody><tr><td>2022/1/26</td><td>框架搭建，文件夹选择器，IndexedDB测试用例</td><td>文件夹内文件预览，打开</td></tr><tr><td>2022/1/27</td><td>文件内文件预览，文件打开以及所在文件夹打开</td><td>文件信息编辑（加tag，改名，移除等）</td></tr><tr><td>2022/1/27-2</td><td>窗体最小宽度调整，图片预览部分功能按键设置</td><td></td></tr><tr><td>2022/1/28</td><td>在card下打开所在文件夹，删除该文件，编辑文件名等功能，以及打分模块示例</td><td></td></tr><tr><td>2022/1/30</td><td>视频封面选择测试，图片压缩功能测试</td><td></td></tr><tr><td>2022/2/3</td><td>右键菜单，视频封面图选择与删除</td><td>压缩文件第一张图片预览</td></tr><tr><td>2022/2/4</td><td>压缩文件读取与选择性解压，设置压缩文件封面</td><td>高级选择表单</td></tr><tr><td>2022/2/4-2</td><td>本地文件分页</td><td></td></tr><tr><td>2022/4/6</td><td>本地重新部署</td><td>调用python执行功能性文件，页面设计</td></tr><tr><td>2022/7/7</td><td>全局变量文件Global.vue测试</td><td></td></tr><tr><td>2022/7/8</td><td>引入NaiveUI</td><td></td></tr><tr><td>2022/7/9</td><td>完成全局路径基本配置,配置electron builder进行前端打包，解决打包后iconfont显示问题，后端基本部署完成，H2数据库引入完成，测试基本使用功能正常，由后端监听启动前端部分测试成功</td><td>资源管理方式定义，资源信息存储方式，后端打包方式，H2数据库可视化部分测试</td></tr><tr><td>2022/7/10</td><td>添加图集功能测试，前后端连接，H2数据库构建，图集录入功能实现</td><td>图集展示功能</td></tr><tr><td>2022/7/23</td><td>图集选择栏</td><td>图集展示功能</td></tr><tr><td>2022/7/25</td><td>瀑布流图片展示功能demo完成</td><td>进一步优化瀑布流展示</td></tr><tr><td>2022/7/26</td><td>瀑布流优化，还有进一步优化空间</td><td>creted,mounted选择</td></tr><tr><td>2022/7/27</td><td>瀑布流功能暂定版（修正数据加载跳闪，数据多次重加载）</td><td>图像信息表单主动填入，图像多种展示方式</td></tr><tr><td>2022/7/28</td><td>瀑布流下拉无线刷新初版</td><td></td></tr><tr><td>2022/8/26</td><td>瀑布流图片放大缩小功能实现，同时监听鼠标滚轮和CTRL按键后进行放大缩小实现</td><td>功能继续测试与整合</td></tr><tr><td>2022/8/28</td><td>实现后端自动获取视频缩略图功能，实现前端获取后端生成的视频缩略图功能</td><td>缩略图保存位置以及数据统一</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;开发初衷&quot;&gt;&lt;a href=&quot;#开发初衷&quot; class=&quot;headerlink&quot; title=&quot;开发初衷&quot;&gt;&lt;/a&gt;开发初衷&lt;/h1&gt;&lt;p&gt;市面上常见的多媒体资源管理器并不少见，比如很有名的本地电子书管理工具-Calibre，图片管理工具-Eagle，以及音频爱好</summary>
      
    
    
    
    <category term="项目开发" scheme="http://ywrby.com/categories/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Electron" scheme="http://ywrby.com/tags/Electron/"/>
    
    <category term="Java" scheme="http://ywrby.com/tags/Java/"/>
    
    <category term="JavaWeb" scheme="http://ywrby.com/tags/JavaWeb/"/>
    
    <category term="Vue" scheme="http://ywrby.com/tags/Vue/"/>
    
    <category term="集乐" scheme="http://ywrby.com/tags/%E9%9B%86%E4%B9%90/"/>
    
    <category term="开发记录" scheme="http://ywrby.com/tags/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>IndexedDB浏览器数据库基本概念</title>
    <link href="http://ywrby.com/2022/01/24/IndexedDB%E6%B5%8F%E8%A7%88%E5%99%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://ywrby.com/2022/01/24/IndexedDB%E6%B5%8F%E8%A7%88%E5%99%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2022-01-24T09:15:29.000Z</published>
    <updated>2023-06-15T06:46:45.981Z</updated>
    
    <content type="html"><![CDATA[<p>参考文档：<a href="https://www.cnblogs.com/chenjun1/p/11644866.html">https://www.cnblogs.com/chenjun1/p/11644866.html</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;scroll-y&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mb-2&quot;</span>&gt;</span>IndexDbDemo.vue<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addData()&quot;</span>&gt;</span>增加数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;updateData()&quot;</span>&gt;</span>编辑数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;deleteData()&quot;</span>&gt;</span>删除数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;findData()&quot;</span>&gt;</span>查找数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mt-2&quot;</span>&gt;</span>显示的数据<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; personData &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">//参考文档：https://www.cnblogs.com/chenjun1/p/11644866.html</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; reactive, toRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// 创建数据库</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// 第一个参数为数据库名称，第二个数据库为版本号，返回一个IDBOpenDBRequest对象用于操作数据库。</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// 对于open()的第一个参数数据库名，open()会先去查找本地是否已有这个数据库，如果有则直接将这个数据库返回，如果没有，则先创建这个数据库，再返回。对于第二个参数版本号，则是一个可选参数，如果不传，默认为1，但是如果传入必须是一个整数</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> request = indexedDB.open(<span class="string">&#x27;myDatabase&#x27;</span>)</span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> db</span></span><br><span class="line"><span class="javascript">request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  db = request.result</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">&#x27;数据库打开成功&#x27;</span>)</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">request.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">&#x27;数据库打开报错&#x27;</span>)</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="comment">//数据库升级事件</span></span></span><br><span class="line"><span class="javascript">request.onupgradeneeded = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  db = event.target.result</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> objectStore</span></span><br><span class="line"><span class="javascript">  <span class="comment">//新增一张叫做person的表格，主键是id,是否存在，如果不存在再新建</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">if</span> (!db.objectStoreNames.contains(<span class="string">&#x27;person&#x27;</span>)) &#123;</span></span><br><span class="line"><span class="javascript">    objectStore = db.createObjectStore(<span class="string">&#x27;person&#x27;</span>, &#123; <span class="attr">keyPath</span>: <span class="string">&#x27;id&#x27;</span> &#125;)</span></span><br><span class="line"><span class="javascript">    objectStore.createIndex(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, &#123; <span class="attr">unique</span>: <span class="literal">false</span> &#125;)</span></span><br><span class="line"><span class="javascript">    objectStore.createIndex(<span class="string">&#x27;email&#x27;</span>, <span class="string">&#x27;email&#x27;</span>, &#123; <span class="attr">unique</span>: <span class="literal">true</span> &#125;)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> addData = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> request = db</span></span><br><span class="line"><span class="javascript">    .transaction([<span class="string">&#x27;person&#x27;</span>], <span class="string">&#x27;readwrite&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    .objectStore(<span class="string">&#x27;person&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    .add(&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">age</span>: <span class="number">24</span>, <span class="attr">email</span>: <span class="string">&#x27;zhangsan@example.com&#x27;</span> &#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&#x27;数据写入成功&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  request.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&#x27;数据写入失败&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> state = reactive(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">personData</span>: &#123;&#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> &#123; personData &#125; = toRefs(state)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> findData = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> transaction = db.transaction([<span class="string">&#x27;person&#x27;</span>])</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> objectStore = transaction.objectStore(<span class="string">&#x27;person&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> request = objectStore.get(<span class="number">1</span>)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  request.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&#x27;事务失败&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (request.result) &#123;</span></span><br><span class="line"><span class="javascript">      state.personData = request.result</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;Name: &#x27;</span> + request.result.name)</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;Age: &#x27;</span> + request.result.age)</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;Email: &#x27;</span> + request.result.email)</span></span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;未获得数据记录&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> updateData = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> request = db</span></span><br><span class="line"><span class="javascript">    .transaction([<span class="string">&#x27;person&#x27;</span>], <span class="string">&#x27;readwrite&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    .objectStore(<span class="string">&#x27;person&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    .put(&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;李四&#x27;</span>, <span class="attr">age</span>: <span class="number">35</span>, <span class="attr">email</span>: <span class="string">&#x27;lisi@example.com&#x27;</span> &#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&#x27;数据更新成功&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  request.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&#x27;数据更新失败&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> deleteData = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> request = db.transaction([<span class="string">&#x27;person&#x27;</span>], <span class="string">&#x27;readwrite&#x27;</span>).objectStore(<span class="string">&#x27;person&#x27;</span>).delete(<span class="number">1</span>)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&#x27;数据删除成功&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span> <span class="attr">lang</span>=<span class="string">&quot;scss&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我的博客即将同步至腾讯云开发者社区，邀请大家一同入驻：<a href="https://cloud.tencent.com/developer/support-plan?invite_code=tnjsrr6rwrrk">https://cloud.tencent.com/developer/support-plan?invite_code=tnjsrr6rwrrk</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考文档：&lt;a href=&quot;https://www.cnblogs.com/chenjun1/p/11644866.html&quot;&gt;https://www.cnblogs.com/chenjun1/p/11644866.html&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;h</summary>
      
    
    
    
    <category term="前端" scheme="http://ywrby.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="前端框架" scheme="http://ywrby.com/categories/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="IndexedDB" scheme="http://ywrby.com/tags/IndexedDB/"/>
    
  </entry>
  
  <entry>
    <title>25-两级页表</title>
    <link href="http://ywrby.com/2021/12/29/25-%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8/"/>
    <id>http://ywrby.com/2021/12/29/25-%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8/</id>
    <published>2021-12-29T10:16:26.000Z</published>
    <updated>2023-06-15T06:45:19.941Z</updated>
    
    <content type="html"><![CDATA[<h1 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h1><h2 id="单级页表的问题"><a href="#单级页表的问题" class="headerlink" title="单级页表的问题"></a>单级页表的问题</h2><p>某计算机系统按字节寻址，支持32位的逻辑地址，采用分页存储管理，页面大小为4KB，页表项长度为4B。</p><p>4KB = $2^{12}B$，因此页内地址要用12位表示，剩余20位表示页号。<br>因此，该系统中用户进程最多有220页。相应的，一个进程的页表中，最多会有220 = 1M = 1,048,576个页表项，所以一个页表最大需要220*4B=$2^{22}B$，共需要$2^{22}/2^{12}=2^{10}$个页框存储该页表。</p><p>根据页号查询页表的方法：K号页对应的页表项存放位置=页表始址＋K*4要在所有的页表项都连续存放的基础上才能用这种方法找到页表项</p><p>需要专门给进程分配$2^{10}=1024$个连续的页框来存放它的页表</p><p>同时根据局部性原理可知，很多时候，进程在一段时间内只需要访问某几个页面就可以正常运行了。因此没有必要让整个页表都常驻内存。</p><h3 id="问题一-页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。"><a href="#问题一-页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。" class="headerlink" title="问题一:页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。"></a>问题一:页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。</h3><p>解决方法：我们在解决“进程在内存中必须连续存储问题”时将进程地址空间分页，并为其建立一张页表，记录各页面的存放位置。同样的思路也可用于解决“页表必须连续存放”的问题，把必须连续存放的页表再分页</p><p>可将长长的页表进行分组，使每个内存块刚好可以放入一个分组（比如上个例子中，页面大小4KB,每个页表项4B，每个页面可存放1K个页表项，因此每1K个连续的页表项为一组，每组刚好占一个内存块，再讲各组离散地放到各个内存块中）</p><p>另外，要为离散分配的页表再建立一张页表，称为页目录表，或称外层页表，或称顶层页表</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211229185116.png"></p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211229185307.png"></p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211229185457.png"></p><h3 id="问题二-没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。"><a href="#问题二-没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。" class="headerlink" title="问题二:没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。"></a>问题二:没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。</h3><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211229185602.png"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211229185810.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;两级页表&quot;&gt;&lt;a href=&quot;#两级页表&quot; class=&quot;headerlink&quot; title=&quot;两级页表&quot;&gt;&lt;/a&gt;两级页表&lt;/h1&gt;&lt;h2 id=&quot;单级页表的问题&quot;&gt;&lt;a href=&quot;#单级页表的问题&quot; class=&quot;headerlink&quot; title=&quot;单级页</summary>
      
    
    
    
    <category term="计算机基础" scheme="http://ywrby.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="操作系统" scheme="http://ywrby.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://ywrby.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>24-基本分页存储管理</title>
    <link href="http://ywrby.com/2021/12/28/24-%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/"/>
    <id>http://ywrby.com/2021/12/28/24-%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/</id>
    <published>2021-12-27T12:13:32.000Z</published>
    <updated>2023-06-15T06:45:09.154Z</updated>
    
    <content type="html"><![CDATA[<h1 id="非连续分配管理方式-基本分页存储管理"><a href="#非连续分配管理方式-基本分页存储管理" class="headerlink" title="非连续分配管理方式-基本分页存储管理"></a>非连续分配管理方式-基本分页存储管理</h1><p>从之前文章介绍的两种连续分配管理方式中我们可以看到：</p><ul><li>固定分区分配：缺乏灵活性，会产生大量的内部碎片，内存利用率很低</li><li>动态分区分配：会产生大量外部碎片，虽然可以用紧凑技术处理，但时间成本会增加</li></ul><p>考虑到连续分配方式的缺陷，人们考虑到如果可以将一个进程分散然后分别装入到不相邻分区中就可以更加高效利用内存，基于这一思想，产生了“非连续分配方式”也成为离散分配方式</p><h2 id="把“固定分区分配”改造为“非连续分配”"><a href="#把“固定分区分配”改造为“非连续分配”" class="headerlink" title="把“固定分区分配”改造为“非连续分配”"></a>把“固定分区分配”改造为“非连续分配”</h2><p>假设进程A大小为23MB，但是每个分区大小只有10MB，如果进程只能占用一个分区，那显然放不下。</p><blockquote><p>解决思路:如果允许进程占用多个分区，那么可以把进程拆分成10MB+10MB+3MB三个部分，再把这三个部分分别放到三个分区中(这些分区不要求连续）…</p></blockquote><p>进程A的最后一个部分是3MB，放入分区后会产生7MB的内部碎片。<br>如果每个分区大小为2MB，那么进程A可以拆分成11*2MB +1MB共12个部分，只有最后一部分1MB占不满分区，会产生1MB的内部碎片。<br>显然，如果把分区大小设置的更小一些，内部碎片会更小，内存利用率会更高。</p><p>上面这种思想就是“基本分页存储管理”的思想――把内存分为一个个相等的小分区,再按照分区大小把进程拆分成一个个小部分</p><h2 id="分页存储管理的基本概念"><a href="#分页存储管理的基本概念" class="headerlink" title="分页存储管理的基本概念"></a>分页存储管理的基本概念</h2><p>将内存空间分为一个个大小相等的分区（比如:每个分区4KB），每个分区就是一个“页框”，或称“页帧”、“内存块”、“物理块”。每个页框有一个编号，即“页框号”(或者“内存块号”、“页帧号”、“物理块号”)页框号从0开始。</p><p>将用户进程的地址空间也分为与页框大小相等的一个个区域，称为“页”或“页面”。每个页面也有一个编号，即“页号”，页号也是从0开始。（注:进程的最后一个页面可能没有一个页框那么大。因此，页框不能太大，否则可能产生过大的内部碎片）</p><p>操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的页面与内存的页框有一一对应的关系。</p><p>各个页面不必连续存放，也不必按先后顺序来，可以放到不相邻的各个页框中。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211227202745.png"></p><h3 id="实现地址转换"><a href="#实现地址转换" class="headerlink" title="实现地址转换"></a>实现地址转换</h3><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211227203210.png"></p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211227203335.png"></p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211227203543.png"></p><p>结论:如果每个页面大小为2^K B，用二进制数表示逻辑地址，则末尾K位即为页内偏移量，其余部分就是页号。因此，如果让每个页面的大小为2的整数幂，计算机就可以很方便地得出一个逻辑地址对应的页号和页内偏移量。</p><p>分页存储管理的逻辑地址结构如下所示:</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211227204258.png"></p><p>地址结构包含两个部分:前一部分为页号，后一部分为页内偏移量w。在上图所示的例子中，地址长度为32位，其中0<del>11位为“页内偏移量”，或称“页内地址”，12</del>31位为“页号”。</p><ul><li>如果有K位表示“页内偏移量”，则说明该系统中一个页面的大小是2^K个内存单元</li><li>如果有M位表示“页号”，则说明在该系统中，一个进程最多允许有2^M个页面</li></ul><p>要如何知道该页号对应在内存中的起始地址</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211227204930.png"></p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211227205435.png"></p><h2 id="基本地址变换机构"><a href="#基本地址变换机构" class="headerlink" title="基本地址变换机构"></a>基本地址变换机构</h2><p>（基本地址变换机构是用于实现逻辑地址到物理地址转换的一组硬件机构）</p><p>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。</p><p>通常会在系统中设置一个页表寄存器（PTR），存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的始址和页表长度放在进程控制块（PCB）中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211229164109.png"></p><p>设页面大小为L，逻辑地址A到物理地址E的变换过程如下：</p><ol><li>计算页号Р和页内偏移量W（如果用十进制数手算，则P=A/L，W=A%L;但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量）</li><li>比较页号P和页表长度M，若P&gt;=M，则产生越界中断，否则继续执行。（注意:页号是从O开始的，而页表长度至少是1，因此 P=M时也会越界）</li><li>页表中页号P对应的页表项地址=页表起始地址F+页号P<em>页表项长度，取出该页表项内容b，即为内存块号。（注意区分页表项长度、页表长度、页面大小的区别。页表长度指的是这个页表中总共有几个页表项，即总共有几个页;页表项长度指的是每个页表项占多大的存储空间;页面大小指的是一个页面占多大的存储空间）<br>④计算E= b</em>L+W，用得到的物理地址E去访问内存。（如果内存块号、页面偏移量是用二进制表示的,那么把二者拼接起来就是最终的物理地址了）</li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>例:若页面大小L为1K字节，页号2对应的内存块号b=8，将逻辑地址A=2500转换为物理地址E。</p><blockquote><p>等价描述:某系统按字节寻址，逻辑地址结构中，页内偏移量占10位，页号2对应的内存块号b=8，将逻辑地址A=2500转换为物理地址E。</p></blockquote><ol><li>计算页号、页内偏移量<ul><li>页号P=A/L = 2500/1024 =2</li><li>页内偏移量W=A%L= 2500%1024= 452</li></ul></li><li>根据题中条件可知，页号2没有越界，其存放的内存块号b=8</li><li>物理地址E=b*L+W=8*1024+425=8644</li></ol><p>在分页存储管理（页式管理）的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，页式管理中地址是一维的。即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。</p><h2 id="具有快表的地址变换机构"><a href="#具有快表的地址变换机构" class="headerlink" title="具有快表的地址变换机构"></a>具有快表的地址变换机构</h2><h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">100</span>)&#123;</span><br><span class="line">    a[i]=i;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211229175757.png"></p><p>以上面这段代码为例，10号内存块中存放了程序执行涉及到的相关指令，23号代码块中存放了程序定义的变量，在程序执行过程中，显而易见会频繁的访问到10号和23号代码块</p><p>在此基础上，我们引申出来时间与空间的局部性</p><ul><li>时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再次被访问。(因为程序中存在大量的循环)<ul><li>以上面代码为例，我们定义了变量i，那么我们极有可能在之后频繁的调用变量i（在上文的while循环中不断执行累加操作）</li></ul></li><li>空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的)<ul><li>以上面的代码为例，我们创建了长度为100的数组a，并且为数组第一位赋值为0，那么我们接下来既有可能回去访问它的第二位第三位（在上文中按顺序为数组循环赋值）</li></ul></li></ul><p>上问介绍的基本地址变换机构中，每次要访问一个逻辑地址，都需要查询内存中的页表。由于局部性原理，可能连续很多次查到的都是同一个页表项。既然如此，人们就考虑利用这个特性减少访问页表的次数</p><h3 id="快表概念"><a href="#快表概念" class="headerlink" title="快表概念"></a>快表概念</h3><p>快表，又称联想寄存器（TLB），是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。</p><p>快表执行过程<br><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211229180721.png"></p><h3 id="引入快表后，地址变换的过程"><a href="#引入快表后，地址变换的过程" class="headerlink" title="引入快表后，地址变换的过程"></a>引入快表后，地址变换的过程</h3><ol><li>CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。</li><li>如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。</li><li>如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表未命中，则访问某个逻辑地址需要两次访存（注意:在找到页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换）</li></ol><p>由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。因为局部性原理，一般来说快表的命中率可以达到90%以上。</p><p>例：某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问一次快表耗时1us，访问一次内存耗时100us。若快表的命中率为90%，那么访问一个逻辑地址的平均耗时是多少?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(1+100)* 0.9+(1+100+100)* 0.1 =111 us</span><br><span class="line"></span><br><span class="line">有的系统支持快表和慢表同时查找，如果是这样，平均耗时应该是</span><br><span class="line">(1+100)*0.9+(100+100)* 0.1=110.9 us</span><br><span class="line"></span><br><span class="line">若未采用快表机制，则访问一个逻辑地址需要</span><br><span class="line">100+100= 200us</span><br></pre></td></tr></table></figure><p>显然，引入快表机制后，访问一个逻辑地址的速度快多了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;非连续分配管理方式-基本分页存储管理&quot;&gt;&lt;a href=&quot;#非连续分配管理方式-基本分页存储管理&quot; class=&quot;headerlink&quot; title=&quot;非连续分配管理方式-基本分页存储管理&quot;&gt;&lt;/a&gt;非连续分配管理方式-基本分页存储管理&lt;/h1&gt;&lt;p&gt;从之前文章介</summary>
      
    
    
    
    <category term="计算机基础" scheme="http://ywrby.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="操作系统" scheme="http://ywrby.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://ywrby.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>23-内存空间的分配与回收</title>
    <link href="http://ywrby.com/2021/12/26/23-%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6/"/>
    <id>http://ywrby.com/2021/12/26/23-%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6/</id>
    <published>2021-12-25T11:12:46.000Z</published>
    <updated>2023-06-15T06:44:56.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h1><blockquote><p>连续分配：指系统为用户进程分配的必须是一个连续的内存空间</p></blockquote><h2 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h2><p>在单一连续分配方式中，内存被分为系统区和用户区。</p><ul><li>系统区通常位于内存的低地址部分，用于存放操作系统相关数据</li><li>用户区用于存放用户进程相关数据。内存中只能有一道用户程序，用户程序独占整个用户区空间。</li></ul><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211225191718.png"></p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点：实现简单，无外部碎片，可以采用覆盖技术扩充内存，不一定需要内存保护机制</li><li>缺点：只能用于单用户，单任务的操作系统中，有内部碎片，存储器利用率极低</li></ul><blockquote><p>内部碎片：分配给某进程的内存区域中，如果有些部分没有用上，这些内存部分就被称为“内部碎片”</p></blockquote><h2 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h2><p>20世纪60年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。</p><p>固定分区分配又可以细分为分区大小相等与分区大小不等两种情况</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211225192123.png"></p><p>针对分区大小不等的情况，系统为了维护分区状态以及管理各个分区，需要建立一个数据结构–分区说明表：</p><table><thead><tr><th>分区号</th><th>大小（MB）</th><th>起始地址（M）</th><th>状态</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>8</td><td>未分配</td></tr><tr><td>2</td><td>2</td><td>10</td><td>未分配</td></tr><tr><td>3</td><td>4</td><td>12</td><td>已分配</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table><p>当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为“已分配”。</p><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>分区大小相等：<ul><li>优点：适用于计算机控制多个相同对象的场合</li><li>缺点：缺乏灵活性</li></ul></li><li>分区大小不等：<ul><li>优点：实现简单，无外部碎片，增加了灵活性，可以按照不同大小的进程需求，根据系统中运行的作业大小情况进行划分</li><li>缺点：当用户程序过大时，可能所有分区都不能满足需求，此时不得不采用覆盖技术解决，但这又会降低性能，会产生内部碎片，内存效率低</li></ul></li></ul><h2 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h2><p>动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。(eg:假设某计算机内存大小为64MB，系统区8MB，用户区共56 MB..)</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.jpg"></p><p>动态分区分配中首先我们要考虑“系统要用什么样的数据结构记录内存使用情况？”，另外从进程4进入过程中我们看到，有多个空闲分区满足它的要求，所以我们要考虑“当很多空闲分区都能满足需求时，应该选择哪个分区进行分配”，最后我们看到，在进程3执行结束后，几个空闲分区在物理位置上相连，是否要将它们几个结合，所以我们还需要考虑“如何进行分区的分配与回收”</p><h3 id="系统要用什么样的数据结构记录内存使用情况？"><a href="#系统要用什么样的数据结构记录内存使用情况？" class="headerlink" title="系统要用什么样的数据结构记录内存使用情况？"></a>系统要用什么样的数据结构记录内存使用情况？</h3><p>最长采用两种常用的数据结构：空闲分区表和空闲分区链</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211225194753.png"></p><h3 id="当很多空闲分区都能满足需求时，应该选择哪个分区进行分配"><a href="#当很多空闲分区都能满足需求时，应该选择哪个分区进行分配" class="headerlink" title="当很多空闲分区都能满足需求时，应该选择哪个分区进行分配"></a>当很多空闲分区都能满足需求时，应该选择哪个分区进行分配</h3><p>把一个新作业装入内存时，须按照一定的动态分区分配算法，从空闲分区表（或空闲分区链）中选出一个分区分配给该作业。由于分配算法算法对系统性能有很大的影响，因此人们对它进行了广泛的研究。并在此基础上完成了<a href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95">多种动态分区分配算法</a></p><h3 id="如何进行分区的分配与回收"><a href="#如何进行分区的分配与回收" class="headerlink" title="如何进行分区的分配与回收"></a>如何进行分区的分配与回收</h3><p>首先是在分配过程中，可能会出现将进程大小与空闲分区大小不相等的情况，此时对于空闲分区表来说就需要修改对应分区大小以及起始地址。也可能出现进程大小恰好等于空闲分区大小的情况，此时就需要删除空闲分区表中的一行，对空闲分区链也同理</p><p>而对于回收过程，需要注意的就是，如果一个进程执行结束，其所在分区由分配状态变为空闲状态，就需要检查该分区前后是否还存在空闲分区，如果前方或后方存在空闲分区，就需要将他们合并为一个分区，并修改空闲分区表。如果前后都不存在空闲分区，则需要在空闲分区表中新增一行</p><p>动态分区分配没有内部碎片，但是有外部碎片。</p><blockquote><ul><li>内部碎片：分配给某进程的内存区域中，如果有些部分没有用上。</li><li>外部碎片：是指内存中的某些空闲分区由于太小而难以利用。</li><li>紧凑技术：如果内存中空闲空间的总和本来可以满足某进程的要求,但由于进程需要的是一整块连续的内存空间，因此这些“碎片”不能满足进程的需求。可以通过紧凑（拼凑，Compaction)技术来解决外部碎片。</li></ul></blockquote><h2 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h2><h3 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h3><ul><li>算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。</li><li>如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</li></ul><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211227170023.png"></p><h3 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h3><ul><li>算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即优先使用更小的空闲区。</li><li>如何实现：空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</li></ul><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211227170350.png"></p><p>缺点：每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多的外部碎片。</p><h3 id="最坏适应算法"><a href="#最坏适应算法" class="headerlink" title="最坏适应算法"></a>最坏适应算法</h3><p>又称最大适应算法（Largest Fit）</p><ul><li>算法思想：为了解决最佳适应算法的问题–即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。</li><li>如何实现：空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</li></ul><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211227170723.png"></p><p>缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后有“大进程”到达，就没有内存分区可用了。</p><h3 id="临近适应算法"><a href="#临近适应算法" class="headerlink" title="临近适应算法"></a>临近适应算法</h3><p>基于首次适应算法的一种改良</p><ul><li>算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。</li><li>如何实现：空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</li></ul><p>首次适应算法每次都要从头查找，每次都需要检索低地址的小分区。但是这种规则也决定了当低地址部分有更小的分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的天分区保留下来（最佳适应算法的优点）</p><p>邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用（最大适应算法的缺点）</p><h3 id="四种动态分配算法比较"><a href="#四种动态分配算法比较" class="headerlink" title="四种动态分配算法比较"></a>四种动态分配算法比较</h3><table><thead><tr><th>算法</th><th>算法思想</th><th>分区排列顺序</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>首次适应</td><td>从头到尾找适合的分区</td><td>空闲分区以地址递增次序排列</td><td>综合看性能最好。算法开销小,回收分区后一般不需要对空闲分区队列重新排序</td><td></td></tr><tr><td>最佳适应</td><td>优先使用更小的分区，以保留更多大分区</td><td>空闲分区以容量递增次序排列</td><td>会有更多的大分区被保留下来，更能满足大进程需求</td><td>会产生很多的，难以利用的碎片;算法开销大,回收分区后可能需要对空闲分区队列重新排序</td></tr><tr><td>最坏适应</td><td>优先使用更大的分区，以防止产生太小的不可用的碎片</td><td>空闲分区以容量递减次序排列</td><td>可以减少难以利用的小碎片</td><td>大分区容易被用完，不利于大进程:算法开销大(原因同上)</td></tr><tr><td>临近适应</td><td>由首次适应演变而来，每次从上次查找结束位置开始查找</td><td>空闲分区以地址递增次序排列（可排列成循环链表）</td><td>不用灭磁都从低地址的小分区开始检索，算法开销小</td><td>会使高地址的大分区也被用完</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;连续分配管理方式&quot;&gt;&lt;a href=&quot;#连续分配管理方式&quot; class=&quot;headerlink&quot; title=&quot;连续分配管理方式&quot;&gt;&lt;/a&gt;连续分配管理方式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;连续分配：指系统为用户进程分配的必须是一个连续的内存空间&lt;/p&gt;
</summary>
      
    
    
    
    <category term="计算机基础" scheme="http://ywrby.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="操作系统" scheme="http://ywrby.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://ywrby.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>22-内存空间扩充（覆盖与交换）</title>
    <link href="http://ywrby.com/2021/12/25/22-%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E6%89%A9%E5%85%85%EF%BC%88%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2%EF%BC%89/"/>
    <id>http://ywrby.com/2021/12/25/22-%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E6%89%A9%E5%85%85%EF%BC%88%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2%EF%BC%89/</id>
    <published>2021-12-25T08:15:49.000Z</published>
    <updated>2023-06-15T06:44:46.070Z</updated>
    
    <content type="html"><![CDATA[<h1 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h1><p>早期计算机内存很小，因此经常出现内存大小不够使用的情况，因此人们引入了覆盖技术，用来解决“程序大小超过物理内存总和”的问题</p><p>覆盖技术的思想在于，将程序分为多个段（多个执行模块），常用的模块常驻在内存中，不常用的模块在需要时调入，使用后调出。实现这种功能还需要将内存划分为固定区和若干个覆盖区</p><p>需要常驻在内存的模块进入固定区后就不再调出，直到整个程序运行结束，不常用的模块在需要时调入覆盖区，用不到时调出</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211225163447.png"></p><p>以上图为例，A模块作为需要常驻的模块，在程序开始运行后就进入常驻区，直到程序运行结束。B，C模块只能由A调用，并且不可能同时调用，所以B，C共用一个覆盖区，覆盖区大小由最大模块决定，而D模块只能由B模块调用，E，F模块只能由C模块调用，显而易见，DEF三个模块同一时间只可能有一个运行，所以DEF可以共用一个覆盖区，同时由最大的程序D决定覆盖区大小</p><p>这种覆盖技术的缺点在于：必须由程序员声明覆盖结构，操作系统完成自动覆盖。对用户不透明，增加了用户编程负担。覆盖技术只用于早期的操作系统中，现在已成为历史。</p><h1 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h1><p>交换（对换）技术的设计思想:内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）</p><p>之前所讲过的中级调度（内存调度），就是要决定哪个处于挂起状态的进程重新调入内存</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211225164351.png"></p><p>可以看到，在将进程存入外存的过程中，内存保留了这些进程的PCB，并将他们添加到挂起队列中，这是因为PCB中保存了这些进程的运行情况以及在外存中的位置信息，必须保留它们才能重新将这些挂起进程调回内存中</p><blockquote><p>回忆部分： 暂时换出外存等待的进程状态称为挂起状态（挂起态，suspend）挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态</p></blockquote><p><a href="https://ywrby.cn/2021/11/01/8-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%EF%BC%8C%E6%8E%A7%E5%88%B6%E4%B8%8E%E9%80%9A%E4%BF%A1/">进程的状态，控制与通信</a></p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211225165109.png" alt="七状态模型"></p><h2 id="交换技术需要考虑的问题"><a href="#交换技术需要考虑的问题" class="headerlink" title="交换技术需要考虑的问题"></a>交换技术需要考虑的问题</h2><ol><li>应该在外存（磁盘）的什么位置保存被换出的进程?<ul><li>具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式。对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式。总之，对换区的I/O速度比文件区的更快。</li></ul></li><li>什么时候应该交换?<ul><li>交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如:在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程;如果缺页率明显下降，就可以暂停换出。</li></ul></li><li>应该换出哪些进程?<ul><li>可优先换出阻塞进程;可换出优先级低的进程;为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间…</li></ul></li></ol><p>需要注意的一点就是整个过程中，进程的PCB始终还是存放在内存队列中的，不会被换出到外存中</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;覆盖技术&quot;&gt;&lt;a href=&quot;#覆盖技术&quot; class=&quot;headerlink&quot; title=&quot;覆盖技术&quot;&gt;&lt;/a&gt;覆盖技术&lt;/h1&gt;&lt;p&gt;早期计算机内存很小，因此经常出现内存大小不够使用的情况，因此人们引入了覆盖技术，用来解决“程序大小超过物理内存总和”的问题&lt;</summary>
      
    
    
    
    <category term="计算机基础" scheme="http://ywrby.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="操作系统" scheme="http://ywrby.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://ywrby.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>21-内存与内存管理</title>
    <link href="http://ywrby.com/2021/12/19/21-%E5%86%85%E5%AD%98%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://ywrby.com/2021/12/19/21-%E5%86%85%E5%AD%98%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2021-12-19T09:57:53.000Z</published>
    <updated>2023-06-15T06:44:35.740Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存基础知识"><a href="#内存基础知识" class="headerlink" title="内存基础知识"></a>内存基础知识</h1><blockquote><p>内存(Memory)是计算机的重要部件之一，也称内存储器和主存储器，它用于暂时存放CPU中的运算数据，与硬盘等外部存储器交换的数据。它是外存与CPU进行沟通的桥梁。只要计算机开始运行，操作系统就会把需要运算的数据从内存调到CPU中进行运算，当运算完成，CPU将结果传送出来。</p></blockquote><p>在多道程序环境下，同一时间可能会有多个程序并发执行，即有多个程序的数据需要同时存放在内存中，此时，为了区分内存中不同数据存放的位置，就需要引入存储单元的概念</p><blockquote><p>存储单元：一般应具有存储数据和读写数据的功能，以8位二进制作为一个存储单元，也就是一个字节。每个单元有一个地址，是一个整数编码，可以表示为二进制整数。程序中的变量和主存储器的存储单元相对应。变量的名字对应着存储单元的地址，变量内容对应着单元所存储的数据。存储地址一般用十六进制数表示，而每一个存储器地址中又存放着一组二进制（或十六进制）表示的数，通常称为该地址的内容。</p><ol><li>如果计算机“按字节编址”则每个存储单元大小为1字节即1B，即8个二进制位</li><li>如果字长为16位的计算机“按字编址”，则每个存储单元大小为1字，每个字大小为16个二进制位</li></ol></blockquote><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/dhauidhwuiahuidwhaui.png"></p><p>内存在进程运行过程中的操作</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211220184336.png"></p><p>可见，我们写的代码要翻译成CPU能识别的指令。这些指令会告诉CPU应该去内存的哪个地址存/取数据，这个数据应该做什么样的处理。在这个例子中，指令中直接给出了变量x的实际存放地址（物理地址）。但实际在生成机器指令的时候并不知道该进程的数据会被放到什么位置。所以编译生成的指令中一般是使用逻辑地址（相对地址)</p><p>逻辑地址与相对地址的区别</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211220184704.png"></p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211220184911.png"></p><p>链接的三种方式</p><ol><li>静态链接:在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块)，之后不再拆开。</li><li>装入时动态链接:将各目标模块装入内存时，边装入边链接的链接方式。</li><li>运行时动态链接:在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。</li></ol><p>装入的三种方式：<br><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211220185617.png"></p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211220190022.png"></p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211220190215.png"></p><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>操作系统作为系统资源的管理者，当然也需要对内存进行管理，这些管理涉及到：</p><ol><li>操作系统负责<strong>内存控件的分配与回收</strong></li><li>操作系统需要提供某种技术从逻辑上<strong>对内存控件进行扩充</strong></li><li>操作系统需要提供<strong>地址转换功能</strong>，负责程序的逻辑地址与物理地址的转换（通过上文所说的三种装入方法）</li><li>操作系统需要提供<strong>内存保护</strong>功能，保证各个进程在各自的存储空间内运行，互不干扰</li></ol><h2 id="内存保护的概念与实现方法"><a href="#内存保护的概念与实现方法" class="headerlink" title="内存保护的概念与实现方法"></a>内存保护的概念与实现方法</h2><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211221210302.png"></p><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>在CPU中设置一堆上下限寄存器，存放进程的上下限地址。进程的指令要访问某个地址时，CPU检查是否越界</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211221210449.png"></p><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>采用重定位寄存器（又称基址寄存器）和界地址寄存器(又称限长寄存器)进行越界检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址。</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211221210621.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;内存基础知识&quot;&gt;&lt;a href=&quot;#内存基础知识&quot; class=&quot;headerlink&quot; title=&quot;内存基础知识&quot;&gt;&lt;/a&gt;内存基础知识&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;内存(Memory)是计算机的重要部件之一，也称内存储器和主存储器，它用于暂时存放</summary>
      
    
    
    
    <category term="计算机基础" scheme="http://ywrby.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="操作系统" scheme="http://ywrby.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://ywrby.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>20-死锁</title>
    <link href="http://ywrby.com/2021/12/11/20-%E6%AD%BB%E9%94%81/"/>
    <id>http://ywrby.com/2021/12/11/20-%E6%AD%BB%E9%94%81/</id>
    <published>2021-12-11T06:20:20.000Z</published>
    <updated>2023-06-15T06:44:24.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="死锁的基本概念"><a href="#死锁的基本概念" class="headerlink" title="死锁的基本概念"></a>死锁的基本概念</h1><p>在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里资源，导致各个进程都阻塞，无法向前推进的现象，称为“死锁”。发生死锁后若无外力的干涉，这些进程都将无法向前推进</p><p>要注意的是，死锁，饥饿和死循环是三个比较容易混淆的概念</p><ul><li>饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。例如：在短进程优先算法（SPF）中，若有源源不断的短进程到来，则长进程一直得不到处理机，从而发生长进程“饥饿”</li><li>死循环：某进程执行过程中一直跳不出某个循环的现象，有时是因为程序逻辑bug导致，有时也可能是程序故意设计</li></ul><p>综上，可以总结三者的异同点：</p><table><thead><tr><th>-</th><th>共同点</th><th>区别</th></tr></thead><tbody><tr><td>死锁</td><td>都是进程无法顺利向前推进的现象</td><td>死锁一定是“循环等待对方手里的资源”导致的，因此如果有死锁现象，那至少有两个或以上的进程同时发生死锁。同时，由于是始终处于等待对方资源的状态，所以发生死锁的进程一定处于阻塞态</td></tr><tr><td>饥饿</td><td>-</td><td>可能只有一个进程发生饥饿（例如上文所提到的长进程饥饿）。发生饥饿的进程既可能是阻塞态（例如长期得不到I/O设备），也可能是就绪态（长期得不到处理机）</td></tr><tr><td>死循环</td><td>-</td><td>可能只有一个进程发生死循环。死循环的进程可以上处理机运行，即发生死循环的进程可能处于运行态。只不过无法像期待的那样顺利推进。死锁和饥饿的问题是由于操作系统分配资源的策略不合理所导致，而死循环是由于代码逻辑错误所导致。因此死锁和饥饿是操作系统的问题，死循环是程序员的问题</td></tr></tbody></table><h2 id="死锁的必要条件"><a href="#死锁的必要条件" class="headerlink" title="死锁的必要条件"></a>死锁的必要条件</h2><p>产生死锁必须同时满足以下的四个条件，任意条件不成立，死锁都不会发生</p><ul><li>互斥条件：只有对必须互斥使用的资源进行争抢才会导致死锁。例如哲学家就餐问题，打印机设备等。像内存，扬声器这种可以同时被多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这种资源）</li><li>不剥夺条件：进程获得的资源，在未使用完之前，不能被其他进程强行夺走，只能主动释放</li><li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放</li><li>循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求</li></ul><p>发生死锁一定又循环等待，但发生循环等待不一定有死锁</p><h2 id="发生死锁的时机"><a href="#发生死锁的时机" class="headerlink" title="发生死锁的时机"></a>发生死锁的时机</h2><ul><li>对系统资源的竞争：各个进程对不可剥夺资源的竞争（例如打印机）可能引起死锁，对可剥夺资源（CPU）的竞争不会引起死锁</li><li>进程推进顺序非法：请求和释放资源的顺序不当，同样会导致死锁。例如：并发执行的进程P1，P2分别申请并占有了资源R1，R2，之后进程P1又紧接着申请资源R2，P2申请资源R1，就会导致死锁</li><li>信号量的使用不当：例如在生产者与消费者问题中，如果实现互斥操作的P操作在实现同步操作的P操作之前，就可能导致死锁（这里可以把互斥信号量和同步信号量也堪称一种抽象的系统资源）</li></ul><p>总之，对不可剥夺资源的不合理分配，可能导致死锁</p><h2 id="死锁的处理策略–不允许死锁发生"><a href="#死锁的处理策略–不允许死锁发生" class="headerlink" title="死锁的处理策略–不允许死锁发生"></a>死锁的处理策略–不允许死锁发生</h2><ol><li>预防死锁：破坏死锁产生必要条件中的一个或几个</li><li>避免死锁：用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）</li></ol><h2 id="死锁的处理策略–允许死锁发生"><a href="#死锁的处理策略–允许死锁发生" class="headerlink" title="死锁的处理策略–允许死锁发生"></a>死锁的处理策略–允许死锁发生</h2><ol><li>死锁的检测和解除：允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁</li></ol><h1 id="静态策略：预防死锁"><a href="#静态策略：预防死锁" class="headerlink" title="静态策略：预防死锁"></a>静态策略：预防死锁</h1><p>破坏死锁产生必要条件中的一个或几个</p><h2 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h2><ul><li>互斥条件：只有对必须互斥使用的资源进行争抢才会导致死锁。</li></ul><p>如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。例如SPOOLing技术，操作系统可以使用SPOOLing技术把独占设备在逻辑上改造成共享设备，比如用SPOOLing技术将打印机改造为共享设备</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211211153530.png"></p><p>该策略的缺点：并不是所有资源都可以改造成可共享使用的资源。并且处于系统安全角度考虑，很多地方必须保护这种互斥性，所以破坏互斥条件的应用范围不广</p><h2 id="破坏不可剥夺条件"><a href="#破坏不可剥夺条件" class="headerlink" title="破坏不可剥夺条件"></a>破坏不可剥夺条件</h2><ul><li>不剥夺条件：进程获得的资源，在未使用完之前，不能被其他进程强行夺走，只能主动释放</li></ul><ol><li>方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时重新申请，也就是说，即使资源尚未使用完，也需要主动释放，从而破坏不可剥夺条件</li><li>方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑进程之间的优先级（优先级高的进程可以剥夺低优先级进程的资源）</li></ol><p>该策略的缺点：</p><ul><li>实现起来比较复杂</li><li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方式一般只适用于易保存和恢复状态的资源，例如CPU</li><li>反复申请和释放资源会增加系统开销，降低系统吞吐量</li><li>若采用方案一，意味着只要暂时得不到资源，之前的资源需要全部放弃，后面重新申请，如果该现象一直发生，会导致饥饿</li></ul><h2 id="破坏请求和保持条件"><a href="#破坏请求和保持条件" class="headerlink" title="破坏请求和保持条件"></a>破坏请求和保持条件</h2><ul><li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放</li></ul><p>可以采用静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行，一旦投入运行，这些资源就一直归他所有，该进程不会请求别的任何资源</p><p>该策略缺点：有些资源可能只需要使用很短的时间，因此如果进程的整个运行期间都保持所有资源，就会造成部分资源的严重浪费，资源利用率低。另外策略也可能导致某些进程饥饿</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211211155245.png"></p><p>例如上图中A类进程与B类进程分别需要使用资源1和资源2就可以运行，而C类进程需要同时等待两种资源全部空闲才可执行，此时若A类B类进程交替不断到来，则C类进程会由于没有全部资源陷入饥饿</p><h2 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h2><ul><li>循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求</li></ul><p>可采用顺序资源分配法。首先给系统中的资源编号，并且规定每个进程必须按照编号递增的顺序请求资源，同类资源（编号相同的资源）一次申请完</p><p>原理分析：一个进程已占有小编号资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程无法逆向申请小编号的资源，从而打破循环等待</p><p>该策略的缺点</p><ol><li>不方便新增设备，因为可能需要重新分配所有的编号</li><li>进程时机使用资源的顺序和编号递增顺序不一致，会导致资源浪费。例如某进程需要申请5号打印机资源和7号扫描仪资源，使用顺序是先使用扫描仪后使用打印机，但由于5号打印机编号较小，所以必须提前申请该资源并一直占用，知道申请并使用完7号扫描仪后，才能使用并释放，导致5号打印机被浪费</li><li>必须按规定次序申请资源，用户编程麻烦</li></ol><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211211160546.png"></p><h1 id="动态策略：避免死锁"><a href="#动态策略：避免死锁" class="headerlink" title="动态策略：避免死锁"></a>动态策略：避免死锁</h1><h2 id="基本概念-安全序列"><a href="#基本概念-安全序列" class="headerlink" title="基本概念-安全序列"></a>基本概念-安全序列</h2><blockquote><p>银行家算法:在银行中，客户申请贷款的数量是有限的，每个客户在第一次申请贷款时要声明完成该项目所需的最大资金量，在满足所有贷款要求时，客户应及时归还。银行家在客户申请的贷款数量不超过自己拥有的最大值时，都应尽量满足客户的需要。在这样的描述中，银行家就好比操作系统，资金就是资源，客户就相当于要申请资源的进程。</p></blockquote><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211215174819.png"></p><p>不合理请求<br><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211215175214.png"></p><p>合理请求<br><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211215174453.png"></p><p>根据上面的两个示例我们可以看到，在给B借30亿的情况下，如果B，A，T同时提出20亿借贷的请求，则我们所有企业都无法满足，此时系统陷入死锁状态，而与之相对的，在给A借20亿的情况下，我们有T-&gt;B-&gt;A这样的能够保证系统安全的系列存在</p><p>上面给出的T-&gt;B-&gt;A序列，就是一个安全序列，所谓安全序列，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个。</p><p>如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态，不过我们在分配资源之前总是要考虑到最坏的情况。</p><p>如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁（处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态）</p><p>因此可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。这也是“银行家算法”的核心思想。</p><h2 id="银行家算法核心思想"><a href="#银行家算法核心思想" class="headerlink" title="银行家算法核心思想"></a>银行家算法核心思想</h2><p>在进程提出资源申请时，预先判断此次分配是否会导致系统进入不安全状态(不存在安全序列)，如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待</p><p>但是上面的例子中，只涉及一种资源的分配（钱），而在计算机这种可能涉及多种资源分配的环境下，就需要通过高维向量来解决上述问题：例如系统中有五个进程P0-P4，三种资源R0-R2，初始数量为(10,5,7)则某一时刻的情况可以表示如下</p><table><thead><tr><th>进程</th><th>最大需求</th><th>已分配</th><th>最多还需要</th></tr></thead><tbody><tr><td>P0</td><td>(7,5,3)</td><td>(0,1,1)</td><td>(7,4,3)</td></tr><tr><td>P1</td><td>(3,2,2)</td><td>(2,0,0)</td><td>(1,2,2)</td></tr><tr><td>P2</td><td>(9,0,2)</td><td>(3,0,2)</td><td>(6,0,0)</td></tr><tr><td>P3</td><td>(2,2,2)</td><td>(2,1,1)</td><td>(0,1,1)</td></tr><tr><td>P4</td><td>(4,3,3)</td><td>(0,0,2)</td><td>(4,3,3)</td></tr></tbody></table><p>此时系统剩余可用资源(3,3,2)要判断系统是否处于安全状态，思路就是尝试找到一条安全序列，而方法就是自上而下依次检查剩余可用资源(3,3,2)是否能满足各进程需求</p><p>检查过程：</p><ol><li>首先P0最多需要资源(7,4,3)&gt;剩余资源(3,3,2)，所以P0暂时无法进入安全序列</li><li>接下来P1(1,2,2)&lt;(3,3,2)所以P1可以进入安全序列</li><li>P1进入安全序列分配资源并等待P1归还所有已分配资源</li><li>P1归还所有已分配资源，所以系统剩余资源(2,0,0)+(3,3,2)=(5,3,2)</li><li>继续向下执行P2(6,0,0)&gt;(5,3,2)，所以P2暂时不能进入安全序列</li><li>P3(0,1,1)&lt;(5,3,2)所以P3进入安全序列，分配资源，并等待P3归还所有已分配资源</li><li>P3归还资源，系统剩余资源(2,1,1)+(5,3,2)=(7,4,3)</li><li>继续向下执行P4(4,3,1)&lt;(7,4,3)，P4进入安全序列，分配资源，并归还</li><li>P4归还资源，系统剩余资源(0,0,2)+(7,4,3)=(7,4,5)</li><li>不断执行，此时所有进程都可进入安全序列</li><li>最终得到安全序列P1-&gt;P3-&gt;P4-&gt;P0-&gt;P2(安全序列不唯一)</li></ol><p>成功找到一条安全序列表明系统处于安全状态，不可能发生死锁</p><h2 id="银行家算法实现思路"><a href="#银行家算法实现思路" class="headerlink" title="银行家算法实现思路"></a>银行家算法实现思路</h2><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211215182345.png"></p><h1 id="死锁的检测和解除"><a href="#死锁的检测和解除" class="headerlink" title="死锁的检测和解除"></a>死锁的检测和解除</h1><h2 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h2><p>为了能对系统是否已经发生了死锁进行检测，我们需要：</p><ol><li>用某种数据结构来保存资源的请求和分配信息</li><li>提供一种算法，利用上述信息来检测系统是否已经进入死锁状态</li></ol><p>能够用来保存资源的请求与分配信息的结构就是资源分配图，资源分配图具有如下特点：</p><ul><li>具有两种节点<ul><li>进程节点：对应一个进程</li><li>资源节点：对应一类资源，一类资源可能有多个</li></ul></li><li>具有两种边<ul><li>请求边：从进程节点指向资源节点，表示进程想申请几个资源（一条边表示想要申请一个）</li><li>分配边：从资源节点指向进程节点，表示已经为该进程分配了几个资源（一条边表示已分配一个资源）</li></ul></li></ul><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211219172358.png"></p><p>介绍了一种保存资源和请求分配信息的数据结构后，我们就应该考虑如何利用算法，检测整个过程中系统是否发生死锁。</p><p>以上面这张资源分配图为例，P1进程请求一个R2资源，此时R2资源一共两个，其中一个被分配给P2进程，所以剩余资源足够分配给P1进程，此时P1进程不需要额外资源，可以正常执行。待执行结束后归还一个R2资源和两个R1资源，此时P2请求一个额外的R1资源，R1资源一共三个，其中一个已经分配给P2进程，剩余两个空闲，所以能够分配一个额外的R1资源给P2，P2进程也可顺利执行，则该情况下未发生死锁</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211219173206.png"></p><p>相对的，如果资源分配图变成这种情况，则P1进程请求两个R2资源，但空闲R2资源为0，P1被阻塞，P2进程请求一个R1资源，空闲R1资源为0，P2被阻塞，P3进程不请求额外资源，只有P3进程可以正常执行，执行后归还一个R2资源，但此时P1进程仍无法执行，P2进程也无法请求到额外资源，系统进入死锁状态</p><p>所以说，如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利地执行下去。如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。相应的，这些被激活的进程执行完了之后又会归还一些资源,这样可能又会激活另外一些阻塞的进程…</p><p>如果按照上述的过程分析最终能够消除所有边，则称该图是“可完全简化的”，此时一定没有死锁，如果最终不能消除所有边，则此时就发生了死锁，最终还连这边的进程就是处于死锁状态的进程</p><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211219173937.png"></p><p>综上，检测死锁的算法就可以描述为：</p><ol><li>在资源分配图中，找出既不阻塞又不是孤点的进程Pi(即找出一条存在有向边与它相连，且该有向边对应资源的申请数量小于等于系统中己有空闲资源数量。如下图中，R1没有空闲资源，R2有一个空闲资源。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源）。消去它所有的请求边和分配边，使之称为孤立的结点。在下图中，P1是满足这一条件的进程结点,于是将P1的所有边消去。</li><li>进程Pi所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。在下图中，P2就满足这样的条件。根据1)中的方法进行一系列简化后，若能消去途中所有的边，则称该图是可完全简化的。<br><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211219172358.png"></li></ol><h2 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h2><p>一旦检测出死锁的发生，就应该立即解除死锁。</p><p>注意:并不是系统中所有的进程都是死锁状态，用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程</p><p>解除死锁的主要方法有:</p><ol><li>资源剥夺法。挂起（暂时放到外存上)某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li><li>撤销进程法（或称终止进程法)。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，己经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。</li><li>进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息,设置还原点。</li></ol><h3 id="如何绝对挂起或剥夺哪些进程"><a href="#如何绝对挂起或剥夺哪些进程" class="headerlink" title="如何绝对挂起或剥夺哪些进程"></a>如何绝对挂起或剥夺哪些进程</h3><ol><li>考虑进程的优先级，对优先级低的进程进行剥夺</li><li>考虑已执行的时间，避免剥夺已经长时间运行的进程，造成损失</li><li>考虑进程完成时间，优先为可快速完成的进程分配资源</li><li>考虑进程已经使用了多少资源</li><li>考虑进程是交互式的还是批处理式的，避免交互式进程被剥夺影响用户体验</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;死锁的基本概念&quot;&gt;&lt;a href=&quot;#死锁的基本概念&quot; class=&quot;headerlink&quot; title=&quot;死锁的基本概念&quot;&gt;&lt;/a&gt;死锁的基本概念&lt;/h1&gt;&lt;p&gt;在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里资源，导致各个进程都阻塞，无法向前推进的现</summary>
      
    
    
    
    <category term="计算机基础" scheme="http://ywrby.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="操作系统" scheme="http://ywrby.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://ywrby.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>19-管程</title>
    <link href="http://ywrby.com/2021/11/28/19-%E7%AE%A1%E7%A8%8B/"/>
    <id>http://ywrby.com/2021/11/28/19-%E7%AE%A1%E7%A8%8B/</id>
    <published>2021-11-28T08:39:08.000Z</published>
    <updated>2023-06-15T06:43:59.753Z</updated>
    
    <content type="html"><![CDATA[<h1 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h1><h2 id="信号量机制存在的问题"><a href="#信号量机制存在的问题" class="headerlink" title="信号量机制存在的问题"></a>信号量机制存在的问题</h2><p>编写程序困难，容易出错。因此人们考虑使用另外设计的机制，保证程序员在编写程序过程中不需要关注复杂的PV操作。</p><h2 id="管程的定义和组成"><a href="#管程的定义和组成" class="headerlink" title="管程的定义和组成"></a>管程的定义和组成</h2><p>管程是一种特殊的软件模块，其组成部分为：</p><ol><li>局部与管程的共享数据结构（类似于局部变量的概念，该数据结构只能被管程所访问）</li><li>对该数据结构进行操作的一组过程（类似于局部方法）</li><li>对局部于管程的共享数据设置初始值的语句（初始化方法）</li><li>管程的名字</li></ol><h2 id="管程的基本特征"><a href="#管程的基本特征" class="headerlink" title="管程的基本特征"></a>管程的基本特征</h2><ol><li>局部与管程的数据只能被局部与管程的过程（方法）所访问</li><li>一个进程只有通过调用管程内的方法，才能进入管程并访问共享数据</li><li>每次仅允许一个进程在管程内执行某个内部过程（方法）</li></ol><h2 id="管程示例"><a href="#管程示例" class="headerlink" title="管程示例"></a>管程示例</h2><p><img src="https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211128165547.png"></p><p>这个过程中由编译器负责实现各个进程互斥的进入管程中的方法</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>引入管程的目的无非是为了更方便的实现进程的互斥与同步</li><li>需要在管程中定义共享数据（例如生产者消费者问题中的缓冲区）</li><li>需要在管程中定义用于访问共享数据的“入口”，即函数</li><li>只有通过管程中定义的方法才能进入管程，才能访问共享数据</li><li>管程存在很多方法，但每次只能开放其中一个方法作为“入口”，并且只允许一个进程或线程进入（这种互斥的特性是由编译器实现的，程序员不需要关心）</li><li>可在管程中设置条件变量以及等待/唤醒操作来解决进程同步问题</li><li>管程体现了一种封装思想，将复杂的PV操作进行封装方便程序设计人员使用</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;管程&quot;&gt;&lt;a href=&quot;#管程&quot; class=&quot;headerlink&quot; title=&quot;管程&quot;&gt;&lt;/a&gt;管程&lt;/h1&gt;&lt;h2 id=&quot;信号量机制存在的问题&quot;&gt;&lt;a href=&quot;#信号量机制存在的问题&quot; class=&quot;headerlink&quot; title=&quot;信号量机制</summary>
      
    
    
    
    <category term="计算机基础" scheme="http://ywrby.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="操作系统" scheme="http://ywrby.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://ywrby.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
